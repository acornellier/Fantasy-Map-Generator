{"remainingRequest":"/Users/acornellier/git/Fantasy-Map-Generator/vue/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/acornellier/git/Fantasy-Map-Generator/vue/src/components/FantasyMapGenerator.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/acornellier/git/Fantasy-Map-Generator/vue/src/components/FantasyMapGenerator.vue","mtime":1550936225548},{"path":"/Users/acornellier/git/Fantasy-Map-Generator/vue/node_modules/cache-loader/dist/cjs.js","mtime":1550636236327},{"path":"/Users/acornellier/git/Fantasy-Map-Generator/vue/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/acornellier/git/Fantasy-Map-Generator/vue/node_modules/cache-loader/dist/cjs.js","mtime":1550636236327},{"path":"/Users/acornellier/git/Fantasy-Map-Generator/vue/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport seedrandom from 'seedrandom'\nimport * as d3 from 'd3'\nimport * as d3chromatic from 'd3-scale-chromatic'\nimport * as polylabel from 'polylabel'\nimport * as quantize from 'quantize'\nimport * as PriorityQueue from 'js-priority-queue'\nimport * as $ from 'jquery'\nimport 'jquery-ui-bundle'\nimport 'jquery-ui-bundle/jquery-ui.css'\nimport * as _ from 'lodash'\nimport {toHEX, round, si, getInteger, GFontToDataURI, ifDefined} from './utils'\nimport Dialogs from './dialogs/Dialogs.vue'\nimport Graphic from './Graphic.vue'\nimport Options from './options/Options.vue'\n\n/* eslint-disable */\n\nexport default {\n  name: 'FantasyMapGenerator',\n  mounted() {\n    fantasyMap()\n  },\n  components: {\n    Dialogs,\n    Graphic,\n    Options,\n  },\n  methods: {\n    updateLabelGroups() { updateLabelGroups() },\n    applyDefaultStyle() { applyDefaultStyle() },\n    toggleHeight() { toggleHeight() },\n  },\n}\n\n'use strict'\n\n// consants\nconst ICONS = [\n  // emoticons in FF:\n  ['2693', '⚓', 'Anchor'],\n  ['26EA', '⛪', 'Church'],\n  ['1F3EF', '🏯', 'Japanese Castle'],\n  ['1F3F0', '🏰', 'Castle'],\n  ['1F5FC', '🗼', 'Tower'],\n  ['1F3E0', '🏠', 'House'],\n  ['1F3AA', '🎪', 'Tent'],\n  ['1F3E8', '🏨', 'Hotel'],\n  ['1F4B0', '💰', 'Money bag'],\n  ['1F4A8', '💨', 'Dashing away'],\n  ['1F334', '🌴', 'Palm'],\n  ['1F335', '🌵', 'Cactus'],\n  ['1F33E', '🌾', 'Sheaf'],\n  ['1F5FB', '🗻', 'Mountain'],\n  ['1F30B', '🌋', 'Volcano'],\n  ['1F40E', '🐎', 'Horse'],\n  ['1F434', '🐴', 'Horse Face'],\n  ['1F42E', '🐮', 'Cow'],\n  ['1F43A', '🐺', 'Wolf Face'],\n  ['1F435', '🐵', 'Monkey face'],\n  ['1F437', '🐷', 'Pig face'],\n  ['1F414', '🐔', 'Chiken'],\n  ['1F411', '🐑', 'Eve'],\n  ['1F42B', '🐫', 'Camel'],\n  ['1F418', '🐘', 'Elephant'],\n  ['1F422', '🐢', 'Turtle'],\n  ['1F40C', '🐌', 'Snail'],\n  ['1F40D', '🐍', 'Snake'],\n  ['1F433', '🐳', 'Whale'],\n  ['1F42C', '🐬', 'Dolphin'],\n  ['1F420', '🐟', 'Fish'],\n  ['1F432', '🐲', 'Dragon Head'],\n  ['1F479', '👹', 'Ogre'],\n  ['1F47B', '👻', 'Ghost'],\n  ['1F47E', '👾', 'Alien'],\n  ['1F480', '💀', 'Skull'],\n  ['1F374', '🍴', 'Fork and knife'],\n  ['1F372', '🍲', 'Food'],\n  ['1F35E', '🍞', 'Bread'],\n  ['1F357', '🍗', 'Poultry leg'],\n  ['1F347', '🍇', 'Grapes'],\n  ['1F34F', '🍏', 'Apple'],\n  ['1F352', '🍒', 'Cherries'],\n  ['1F36F', '🍯', 'Honey pot'],\n  ['1F37A', '🍺', 'Beer'],\n  ['1F377', '🍷', 'Wine glass'],\n  ['1F3BB', '🎻', 'Violin'],\n  ['1F3B8', '🎸', 'Guitar'],\n  ['26A1', '⚡', 'Electricity'],\n  ['1F320', '🌠', 'Shooting star'],\n  ['1F319', '🌙', 'Crescent moon'],\n  ['1F525', '🔥', 'Fire'],\n  ['1F4A7', '💧', 'Droplet'],\n  ['1F30A', '🌊', 'Wave'],\n  ['231B', '⌛', 'Hourglass'],\n  ['1F3C6', '🏆', 'Goblet'],\n  ['26F2', '⛲', 'Fountain'],\n  ['26F5', '⛵', 'Sailboat'],\n  ['26FA', '⛺', 'Tend'],\n  ['1F489', '💉', 'Syringe'],\n  ['1F4D6', '📚', 'Books'],\n  ['1F3AF', '🎯', 'Archery'],\n  ['1F52E', '🔮', 'Magic ball'],\n  ['1F3AD', '🎭', 'Performing arts'],\n  ['1F3A8', '🎨', 'Artist palette'],\n  ['1F457', '👗', 'Dress'],\n  ['1F451', '👑', 'Crown'],\n  ['1F48D', '💍', 'Ring'],\n  ['1F48E', '💎', 'Gem'],\n  ['1F514', '🔔', 'Bell'],\n  ['1F3B2', '🎲', 'Die'],\n  // black and white icons in FF:\n  ['26A0', '⚠', 'Alert'],\n  ['2317', '⌗', 'Hash'],\n  ['2318', '⌘', 'POI'],\n  ['2307', '⌇', 'Wavy'],\n  ['21E6', '⇦', 'Left arrow'],\n  ['21E7', '⇧', 'Top arrow'],\n  ['21E8', '⇨', 'Right arrow'],\n  ['21E9', '⇩', 'Left arrow'],\n  ['21F6', '⇶', 'Three arrows'],\n  ['2699', '⚙', 'Gear'],\n  ['269B', '⚛', 'Atom'],\n  ['0024', '$', 'Dollar'],\n  ['2680', '⚀', 'Die1'],\n  ['2681', '⚁', 'Die2'],\n  ['2682', '⚂', 'Die3'],\n  ['2683', '⚃', 'Die4'],\n  ['2684', '⚄', 'Die5'],\n  ['2685', '⚅', 'Die6'],\n  ['26B4', '⚴', 'Pallas'],\n  ['26B5', '⚵', 'Juno'],\n  ['26B6', '⚶', 'Vesta'],\n  ['26B7', '⚷', 'Chiron'],\n  ['26B8', '⚸', 'Lilith'],\n  ['263F', '☿', 'Mercury'],\n  ['2640', '♀', 'Venus'],\n  ['2641', '♁', 'Earth'],\n  ['2642', '♂', 'Mars'],\n  ['2643', '♃', 'Jupiter'],\n  ['2644', '♄', 'Saturn'],\n  ['2645', '♅', 'Uranus'],\n  ['2646', '♆', 'Neptune'],\n  ['2647', '♇', 'Pluto'],\n  ['26B3', '⚳', 'Ceres'],\n  ['2654', '♔', 'Chess king'],\n  ['2655', '♕', 'Chess queen'],\n  ['2656', '♖', 'Chess rook'],\n  ['2657', '♗', 'Chess bishop'],\n  ['2658', '♘', 'Chess knight'],\n  ['2659', '♙', 'Chess pawn'],\n  ['2660', '♠', 'Spade'],\n  ['2663', '♣', 'Club'],\n  ['2665', '♥', 'Heart'],\n  ['2666', '♦', 'Diamond'],\n  ['2698', '⚘', 'Flower'],\n  ['2625', '☥', 'Ankh'],\n  ['2626', '☦', 'Orthodox'],\n  ['2627', '☧', 'Chi Rho'],\n  ['2628', '☨', 'Lorraine'],\n  ['2629', '☩', 'Jerusalem'],\n  ['2670', '♰', 'Syriac cross'],\n  ['2020', '†', 'Dagger'],\n  ['262A', '☪', 'Muslim'],\n  ['262D', '☭', 'Soviet'],\n  ['262E', '☮', 'Peace'],\n  ['262F', '☯', 'Yin yang'],\n  ['26A4', '⚤', 'Heterosexuality'],\n  ['26A2', '⚢', 'Female homosexuality'],\n  ['26A3', '⚣', 'Male homosexuality'],\n  ['26A5', '⚥', 'Male and female'],\n  ['26AD', '⚭', 'Rings'],\n  ['2690', '⚐', 'White flag'],\n  ['2691', '⚑', 'Black flag'],\n  ['263C', '☼', 'Sun'],\n  ['263E', '☾', 'Moon'],\n  ['2668', '♨', 'Hot springs'],\n  ['2600', '☀', 'Black sun'],\n  ['2601', '☁', 'Cloud'],\n  ['2602', '☂', 'Umbrella'],\n  ['2603', '☃', 'Snowman'],\n  ['2604', '☄', 'Comet'],\n  ['2605', '★', 'Black star'],\n  ['2606', '☆', 'White star'],\n  ['269D', '⚝', 'Outlined star'],\n  ['2618', '☘', 'Shamrock'],\n  ['21AF', '↯', 'Lightning'],\n  ['269C', '⚜', 'FleurDeLis'],\n  ['2622', '☢', 'Radiation'],\n  ['2623', '☣', 'Biohazard'],\n  ['2620', '☠', 'Skull'],\n  ['2638', '☸', 'Dharma'],\n  ['2624', '☤', 'Caduceus'],\n  ['2695', '⚕', 'Aeculapius staff'],\n  ['269A', '⚚', 'Hermes staff'],\n  ['2697', '⚗', 'Alembic'],\n  ['266B', '♫', 'Music'],\n  ['2702', '✂', 'Scissors'],\n  ['2696', '⚖', 'Scales'],\n  ['2692', '⚒', 'Hammer and pick'],\n  ['2694', '⚔', 'Swords']\n]\nconst FONTS = ['Almendra+SC', 'Georgia', 'Times+New+Roman', 'Comic+Sans+MS', 'Lucida+Sans+Unicode', 'Courier+New']\nconst VOWELS = 'aeiouy'\n\n// global variables\nlet svg\nlet defs\nlet viewbox\nlet ocean\nlet oceanLayers\nlet oceanPattern\nlet landmass\nlet terrs\nlet grid\nlet overlay\nlet rivers\nlet terrain\nlet cults\nlet regions\nlet borders\nlet stateBorders\nlet neutralBorders\nlet lakes\nlet routes\nlet roads\nlet trails\nlet searoutes\nlet coastline\nlet labels\nlet burgLabels\nlet icons\nlet burgIcons\nlet markers\nlet ruler\nlet debug\nlet seed\nlet params\nlet voronoi\nlet diagram\nlet polygons\nlet spacing\nlet points = []\nlet heights\nlet modules = []\nlet customization = 0\nlet history = []\nlet historyStage = 0\nlet elSelected\nlet autoResize = true\nlet graphSize\nlet cells = []\nlet land = []\nlet riversData = []\nlet manors = []\nlet states = []\nlet features = []\nlet notes = []\nlet queue = []\nlet defaultCultures = []\nlet cultures = []\nlet chain = []\nlet nameBases = []\nlet nameBase = []\nlet cultureTree\n\n// global methods\n\n// download map as SVG or PNG file\nfunction saveAsImage(type) {\n  console.time('saveAsImage')\n  const webSafe = ['Georgia', 'Times+New+Roman', 'Comic+Sans+MS', 'Lucida+Sans+Unicode', 'Courier+New', 'Verdana', 'Arial', 'Impact']\n  // get non-standard fonts used for labels to fetch them from web\n  const fontsInUse = [] // to store fonts currently in use\n  labels.selectAll('g').each(function(d) {\n    const font = d3.select(this).attr('data-font')\n    if (!font) return\n    if (webSafe.indexOf(font) !== -1) return // do not fetch web-safe fonts\n    if (fontsInUse.indexOf(font) === -1) fontsInUse.push(font)\n  })\n  const fontsToLoad = 'https://fonts.googleapis.com/css?family=' + fontsInUse.join('|')\n\n  // clone svg\n  const cloneEl = document.getElementsByTagName('svg')[0].cloneNode(true)\n  cloneEl.id = 'fantasyMap'\n  document.getElementsByTagName('body')[0].appendChild(cloneEl)\n  const clone = d3.select('#fantasyMap')\n\n  // rteset transform for svg\n  if (type === 'svg') {\n    clone.attr('width', graphWidth).attr('height', graphHeight)\n    clone.select('#viewbox').attr('transform', null)\n    if (svgWidth !== graphWidth || svgHeight !== graphHeight) {\n      // move scale bar to right bottom corner\n      const el = clone.select('#scaleBar')\n      if (!el.size()) return\n      const bbox = el.select('rect').node().getBBox()\n      const tr = [graphWidth - bbox.width, graphHeight - (bbox.height - 10)]\n      el.attr('transform', 'translate(' + Math.round(tr[0]) + ',' + Math.round(tr[1]) + ')')\n    }\n\n    // to fix use elements sizing\n    clone.selectAll('use').each(function() {\n      const size = this.parentNode.getAttribute('size') || 1\n      this.setAttribute('width', size + 'px')\n      this.setAttribute('height', size + 'px')\n    })\n\n    // clean attributes\n    //clone.selectAll(\"*\").each(function() {\n    //  const attributes = this.attributes;\n    //  for (let i = 0; i < attributes.length; i++) {\n    //    const attr = attributes[i];\n    //    if (attr.value === \"\" || attr.name.includes(\"data\")) {\n    //      this.removeAttribute(attr.name);\n    //    }\n    //  }\n    //});\n\n  }\n\n  // for each g element get inline style\n  const emptyG = clone.append('g').node()\n  const defaultStyles = window.getComputedStyle(emptyG)\n\n  // show hidden labels but in reduced size\n  clone.select('#labels').selectAll('.hidden').each(function(e) {\n    const size = d3.select(this).attr('font-size')\n    d3.select(this).classed('hidden', false).attr('font-size', _.round(size * 0.4, 2))\n  })\n\n  // save group css to style attribute\n  clone.selectAll('g, #ruler > g > *, #scaleBar > text').each(function(d) {\n    const compStyle = window.getComputedStyle(this)\n    let style = ''\n    for (let i = 0; i < compStyle.length; i++) {\n      const key = compStyle[i]\n      const value = compStyle.getPropertyValue(key)\n      // Firefox mask hack\n      if (key === 'mask-image' && value !== defaultStyles.getPropertyValue(key)) {\n        style += 'mask-image: url(\\'#shape\\');'\n        continue\n      }\n      if (key === 'cursor') continue // cursor should be default\n      if (this.hasAttribute(key)) continue // don't add style if there is the same attribute\n      if (value === defaultStyles.getPropertyValue(key)) continue\n      style += key + ':' + value + ';'\n    }\n    if (style != '') this.setAttribute('style', style)\n  })\n  emptyG.remove()\n\n  // load fonts as dataURI so they will be available in downloaded svg/png\n  GFontToDataURI(fontsToLoad).then(cssRules => {\n    clone.select('defs').append('style').text(cssRules.join('\\n'))\n    const svg_xml = (new XMLSerializer()).serializeToString(clone.node())\n    clone.remove()\n    const blob = new Blob([svg_xml], {type: 'image/svg+xml;charset=utf-8'})\n    const url = window.URL.createObjectURL(blob)\n    const link = document.createElement('a')\n    link.target = '_blank'\n    if (type === 'png') {\n      const ratio = svgHeight / svgWidth\n      canvas.width = svgWidth * pngResolutionInput.value\n      canvas.height = svgHeight * pngResolutionInput.value\n      const img = new Image()\n      img.src = url\n      img.onload = function() {\n        window.URL.revokeObjectURL(url)\n        ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\n        link.download = 'fantasy_map_' + Date.now() + '.png'\n        canvas.toBlob(function(blob) {\n          link.href = window.URL.createObjectURL(blob)\n          document.body.appendChild(link)\n          link.click()\n          window.setTimeout(function() {window.URL.revokeObjectURL(link.href)}, 5000)\n        })\n        canvas.style.opacity = 0\n        canvas.width = svgWidth\n        canvas.height = svgHeight\n      }\n    } else {\n      link.download = 'fantasy_map_' + Date.now() + '.svg'\n      link.href = url\n      document.body.appendChild(link)\n      link.click()\n    }\n    console.timeEnd('saveAsImage')\n    window.setTimeout(function() {window.URL.revokeObjectURL(url)}, 5000)\n  })\n}\n\n// get user-friendly (real-world) height value from map data\nfunction getFriendlyHeight(h) {\n  let exponent = +heightExponent.value\n  let unit = heightUnit.value\n  let unitRatio = 1 // default calculations are in meters\n  if (unit === 'ft') unitRatio = 3.28 // if foot\n  if (unit === 'f') unitRatio = 0.5468 // if fathom\n  let height = -990\n  if (h >= 20) height = Math.pow(h - 18, exponent)\n  if (h < 20 && h > 0) height = (h - 20) / h * 50\n  return h + ' (' + Math.round(height * unitRatio) + ' ' + unit + ')'\n}\n\n// Get cell info on mouse move (useful for debugging)\nfunction moved() {\n  const point = d3.mouse(this)\n  const i = diagram.find(point[0], point[1]).index\n\n  // update cellInfo\n  if (i) {\n    const p = cells[i] // get cell\n    infoX.innerHTML = Math.round(point[0])\n    infoY.innerHTML = Math.round(point[1])\n    infoCell.innerHTML = i\n    infoArea.innerHTML = ifDefined(p.area, 'n/a', 2)\n    if (customization === 1) {\n      infoHeight.innerHTML = getFriendlyHeight(heights[i])\n    } else {infoHeight.innerHTML = getFriendlyHeight(p.height)}\n    infoFlux.innerHTML = ifDefined(p.flux, 'n/a', 2)\n    let country = p.region === undefined ? 'n/a' : p.region === 'neutral' ? 'neutral' :\n                                                   states[p.region].name + ' (' + p.region + ')'\n    infoCountry.innerHTML = country\n    let culture = ifDefined(p.culture) !== 'no' ?\n                  cultures[p.culture].name + ' (' + p.culture + ')' : 'n/a'\n    infoCulture.innerHTML = culture\n    infoPopulation.innerHTML = ifDefined(p.pop, 'n/a', 2)\n    infoBurg.innerHTML =\n      ifDefined(p.manor) !== 'no' ? manors[p.manor].name + ' (' + p.manor + ')' : 'no'\n    const feature = features[p.fn]\n    if (feature !== undefined) {\n      const fType = feature.land ? 'Island' : feature.border ? 'Ocean' : 'Lake'\n      infoFeature.innerHTML = fType + ' (' + p.fn + ')'\n    } else {\n      infoFeature.innerHTML = 'n/a'\n    }\n  }\n\n  // update tooltip\n  if (toggleTooltips.checked) {\n    tooltip.innerHTML = tooltip.getAttribute('data-main')\n    const tag = event.target.tagName\n    const path = event.composedPath()\n    const group = path[path.length - 7].id\n    const subgroup = path[path.length - 8].id\n    if (group === 'rivers') tip('Click to open River Editor')\n    if (group === 'routes') tip('Click to open Route Editor')\n    if (group === 'terrain') tip('Click to open Relief Icon Editor')\n    if (group === 'labels') tip('Click to open Label Editor')\n    if (group === 'icons') tip('Click to open Icon Editor')\n    if (group === 'markers') tip('Click to open Marker Editor')\n    if (group === 'ruler') {\n      if (tag === 'path' || tag === 'line') tip('Drag to move the measurer')\n      if (tag === 'text') tip('Click to remove the measurer')\n      if (tag === 'circle') tip('Drag to adjust the measurer')\n    }\n    if (subgroup === 'burgIcons') tip('Click to open Burg Editor')\n    if (subgroup === 'burgLabels') tip('Click to open Burg Editor')\n\n    // show legend on hover (if any)\n    let id = event.target.id\n    if (id === '') id = event.target.parentNode.id\n    if (subgroup === 'burgLabels') id = 'burg' + event.target.getAttribute('data-id')\n\n    let note = notes.find(note => note.id === id)\n    let legend = document.getElementById('legend')\n    let legendHeader = document.getElementById('legendHeader')\n    let legendBody = document.getElementById('legendBody')\n    if (note !== undefined && note.legend !== '') {\n      legend.style.display = 'block'\n      legendHeader.innerHTML = note.name\n      legendBody.innerHTML = note.legend\n    } else {\n      legend.style.display = 'none'\n      legendHeader.innerHTML = ''\n      legendBody.innerHTML = ''\n    }\n  }\n\n  // draw line for ranges placing for heightmap Customization\n  if (customization === 1) {\n    const line = debug.selectAll('.line')\n    if (debug.selectAll('.tag').size() === 1) {\n      const x = +debug.select('.tag').attr('cx')\n      const y = +debug.select('.tag').attr('cy')\n      if (line.size()) {\n        line.attr('x1', x).attr('y1', y).attr('x2', point[0]).attr('y2', point[1])\n      } else {\n        debug.insert('line', ':first-child').attr('class', 'line')\n             .attr('x1', x).attr('y1', y).attr('x2', point[0]).attr('y2', point[1])\n      }\n    } else {\n      line.remove()\n    }\n  }\n\n  // change radius circle for Customization\n  if (customization > 0) {\n    const brush = $('#brushesButtons > .pressed')\n    const brushId = brush.attr('id')\n    if (brushId === 'brushRange' || brushId === 'brushTrough') return\n    if (customization !== 5 && !brush.length && !$('div.selected').length) return\n    let radius = 0\n    if (customization === 1) {\n      radius = brushRadius.value\n      if (brushId === 'brushHill' || brushId === 'brushPit') {\n        radius = Math.pow(brushPower.value * 4, .5)\n      }\n    } else if (customization === 2) radius = countriesManuallyBrush.value\n    else if (customization === 4) radius = culturesManuallyBrush.value\n    else if (customization === 5) radius = reliefBulkRemoveRadius.value\n\n    const r = _.round(6 / graphSize * radius, 1)\n    let clr = '#373737'\n    if (customization === 2) {\n      const state = +$('div.selected').attr('id').slice(5)\n      clr = states[state].color === 'neutral' ? 'white' : states[state].color\n    }\n    if (customization === 4) {\n      const culture = +$('div.selected').attr('id').slice(7)\n      clr = cultures[culture].color\n    }\n    moveCircle(point[0], point[1], r, clr)\n  }\n}\n\nfunction updateLabelGroups() {\n  if ($('#styleElementSelect').value !== 'labels') return\n  const cont = d3.select('#styleLabelGroupItems')\n  cont.selectAll('button').remove()\n  labels.selectAll('g').each(function() {\n    const el = d3.select(this)\n    const id = el.attr('id')\n    const name = id.charAt(0).toUpperCase() + id.substr(1)\n    const state = el.classed('hidden')\n    if (id === 'burgLabels') return\n    cont.append('button').attr('id', id).text(name).classed('buttonoff', state)\n        .on('click', function() {\n          // toggle label group on click\n          if ($('#hideLabels').checked) $('#hideLabels').click()\n          const el = d3.select('#' + this.id)\n          const state = !el.classed('hidden')\n          el.classed('hidden', state)\n          d3.select(this).classed('buttonoff', state)\n        })\n  })\n}\n\nfunction applyDefaultStyle() {\n  viewbox.on('touchmove mousemove', moved)\n  landmass.attr('opacity', 1).attr('fill', '#eef6fb')\n  coastline.attr('opacity', .5).attr('stroke', '#1f3846').attr('stroke-width', .7)\n           .attr('filter', 'url(#dropShadow)')\n  regions.attr('opacity', .4)\n  stateBorders.attr('opacity', .8).attr('stroke', '#56566d').attr('stroke-width', .7)\n              .attr('stroke-dasharray', '1.2 1.5').attr('stroke-linecap', 'butt')\n  neutralBorders.attr('opacity', .8).attr('stroke', '#56566d').attr('stroke-width', .5)\n                .attr('stroke-dasharray', '1 1.5').attr('stroke-linecap', 'butt')\n  cults.attr('opacity', .6)\n  rivers.attr('opacity', 1).attr('fill', '#5d97bb')\n  lakes.attr('opacity', .5).attr('fill', '#a6c1fd').attr('stroke', '#5f799d')\n       .attr('stroke-width', .7)\n  icons.selectAll('g').attr('opacity', 1).attr('fill', '#ffffff').attr('stroke', '#3e3e4b')\n  roads.attr('opacity', .9).attr('stroke', '#d06324').attr('stroke-width', .35)\n       .attr('stroke-dasharray', '1.5').attr('stroke-linecap', 'butt')\n  trails.attr('opacity', .9).attr('stroke', '#d06324').attr('stroke-width', .15)\n        .attr('stroke-dasharray', '.8 1.6').attr('stroke-linecap', 'butt')\n  searoutes.attr('opacity', .8).attr('stroke', '#ffffff').attr('stroke-width', .35)\n           .attr('stroke-dasharray', '1 2').attr('stroke-linecap', 'round')\n  grid.attr('opacity', 1).attr('stroke', '#808080').attr('stroke-width', .1)\n  ruler.attr('opacity', 1).style('display', 'none').attr('filter', 'url(#dropShadow)')\n  overlay.attr('opacity', .8).attr('stroke', '#808080').attr('stroke-width', .5)\n  markers.attr('filter', 'url(#dropShadow01)')\n\n  // ocean style\n  svg.style('background-color', '#000000')\n  ocean.attr('opacity', 1)\n  oceanLayers.select('rect').attr('fill', '#53679f')\n  oceanLayers.attr('filter', '')\n  oceanPattern.attr('opacity', 1)\n  oceanLayers.selectAll('path').attr('display', null)\n  styleOceanPattern.checked = true\n  styleOceanLayers.checked = true\n\n  labels.attr('opacity', 1).attr('stroke', '#3a3a3a').attr('stroke-width', 0)\n  let size = Math.round(8 - regionsInput.value / 20)\n  if (size < 3) size = 3\n  burgLabels.select('#capitals').attr('fill', '#3e3e4b').attr('opacity', 1)\n            .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n            .attr('font-size', size).attr('data-size', size)\n  burgLabels.select('#towns').attr('fill', '#3e3e4b').attr('opacity', 1)\n            .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n            .attr('font-size', 3).attr('data-size', 4)\n  burgIcons.select('#capitals').attr('size', 1).attr('stroke-width', .24)\n           .attr('fill', '#ffffff').attr('stroke', '#3e3e4b').attr('fill-opacity', .7)\n           .attr('stroke-opacity', 1).attr('opacity', 1)\n  burgIcons.select('#towns').attr('size', .5).attr('stroke-width', .12).attr('fill', '#ffffff')\n           .attr('stroke', '#3e3e4b').attr('fill-opacity', .7).attr('stroke-opacity', 1)\n           .attr('opacity', 1)\n  size = Math.round(16 - regionsInput.value / 6)\n  if (size < 6) size = 6\n  labels.select('#countries').attr('fill', '#3e3e4b').attr('opacity', 1)\n        .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n        .attr('font-size', size).attr('data-size', size)\n  icons.select('#capital-anchors').attr('fill', '#ffffff').attr('stroke', '#3e3e4b')\n       .attr('stroke-width', 1.2).attr('size', 2)\n  icons.select('#town-anchors').attr('fill', '#ffffff').attr('stroke', '#3e3e4b')\n       .attr('stroke-width', 1.2).attr('size', 1)\n}\n\n// draw the heightmap\nfunction toggleHeight() {\n  const scheme = $('#styleSchemeInput').value\n  let hColor = color\n  if (scheme === 'light') hColor = d3.scaleSequential(d3chromatic.interpolateRdYlGn)\n  if (scheme === 'green') hColor = d3.scaleSequential(d3chromatic.interpolateGreens)\n  if (scheme === 'monochrome') hColor = d3.scaleSequential(d3chromatic.interpolateGreys)\n  if (!terrs.selectAll('path').size()) {\n    cells.map(function(i, d) {\n      let height = i.height\n      if (height < 20 && !i.lake) return\n      if (i.lake) {\n        const nHeights = i.neighbors.map(\n          function(e) {if (cells[e].height >= 20) return cells[e].height})\n        const mean = d3.mean(nHeights)\n        if (!mean) return\n        height = Math.trunc(mean)\n        if (height < 20 || isNaN(height)) height = 20\n      }\n      const clr = hColor((100 - height) / 100)\n      terrs.append('path')\n           .attr('d', 'M' + polygons[d].join('L') + 'Z')\n           .attr('fill', clr).attr('stroke', clr)\n    })\n  } else {\n    terrs.selectAll('path').remove()\n  }\n}\n\nfunction fantasyMap() {\n  const version = '0.60b'\n  document.title += ' v. ' + version\n\n  // Declare variables\n  svg = d3.select('svg')\n  defs = svg.select('#deftemp')\n  viewbox = svg.append('g').attr('id', 'viewbox')\n  ocean = viewbox.append('g').attr('id', 'ocean')\n  oceanLayers = ocean.append('g').attr('id', 'oceanLayers')\n  oceanPattern = ocean.append('g').attr('id', 'oceanPattern')\n  landmass = viewbox.append('g').attr('id', 'landmass')\n  terrs = viewbox.append('g').attr('id', 'terrs')\n  grid = viewbox.append('g').attr('id', 'grid')\n  overlay = viewbox.append('g').attr('id', 'overlay')\n  rivers = viewbox.append('g').attr('id', 'rivers')\n  terrain = viewbox.append('g').attr('id', 'terrain')\n  cults = viewbox.append('g').attr('id', 'cults')\n  regions = viewbox.append('g').attr('id', 'regions')\n  borders = viewbox.append('g').attr('id', 'borders')\n  stateBorders = borders.append('g').attr('id', 'stateBorders')\n  neutralBorders = borders.append('g').attr('id', 'neutralBorders')\n  lakes = viewbox.append('g').attr('id', 'lakes')\n  routes = viewbox.append('g').attr('id', 'routes')\n  roads = routes.append('g').attr('id', 'roads').attr('data-type', 'land')\n  trails = routes.append('g').attr('id', 'trails').attr('data-type', 'land')\n  searoutes = routes.append('g').attr('id', 'searoutes').attr('data-type', 'sea')\n  coastline = viewbox.append('g').attr('id', 'coastline')\n  labels = viewbox.append('g').attr('id', 'labels')\n  burgLabels = labels.append('g').attr('id', 'burgLabels')\n  icons = viewbox.append('g').attr('id', 'icons')\n  burgIcons = icons.append('g').attr('id', 'burgIcons')\n  markers = viewbox.append('g').attr('id', 'markers')\n  ruler = viewbox.append('g').attr('id', 'ruler')\n  debug = viewbox.append('g').attr('id', 'debug')\n\n  labels.append('g').attr('id', 'countries')\n  burgIcons.append('g').attr('id', 'capitals')\n  burgLabels.append('g').attr('id', 'capitals')\n  burgIcons.append('g').attr('id', 'towns')\n  burgLabels.append('g').attr('id', 'towns')\n  icons.append('g').attr('id', 'capital-anchors')\n  icons.append('g').attr('id', 'town-anchors')\n  terrain.append('g').attr('id', 'hills')\n  terrain.append('g').attr('id', 'mounts')\n  terrain.append('g').attr('id', 'swamps')\n  terrain.append('g').attr('id', 'forests')\n\n  // append ocean pattern\n  oceanPattern.append('rect').attr('fill', 'url(#oceanic)').attr('stroke', 'none')\n  oceanLayers.append('rect').attr('id', 'oceanBase')\n\n  // canvas element for raster images\n  const canvas = document.getElementById('canvas')\n  const ctx = canvas.getContext('2d')\n\n  // Color schemes\n  let color = d3.scaleSequential(d3chromatic.interpolateSpectral)\n  const colors8 = d3.scaleOrdinal(d3chromatic.schemeSet2)\n  const colors20 = d3.scaleOrdinal(d3.schemeCategory20)\n\n  // D3 drag and zoom behavior\n  let scale = 1, viewX = 0, viewY = 0\n  const zoom = d3.zoom().scaleExtent([1, 20]).on('zoom', zoomed)\n  svg.call(zoom)\n\n  // D3 Line generator variables\n  const lineGen = d3.line().x(function(d) {\n    return d.scX\n  }).y(function(d) {\n    return d.scY\n  }).curve(d3.curveCatmullRom)\n\n  applyStoredOptions()\n  graphWidth = +mapWidthInput.value // voronoi graph extention, should be stable for each map\n  graphHeight = +mapHeightInput.value\n  svgWidth = graphWidth\n  svgHeight = graphHeight  // svg canvas resolution, can vary for each map\n\n  // toggle off loading screen and on menus\n  $('#loading, #initial').remove()\n  svg.style('background-color', '#000000')\n  if (localStorage.getItem('disable_click_arrow_tooltip')) {\n    tooltip.innerHTML = ''\n    tooltip.setAttribute('data-main', '')\n    $('#optionsTrigger').removeClass('glow')\n  }\n\n  $('#mapLayers').sortable({items: 'li:not(.solid)', cancel: '.solid', update: moveLayer})\n  $('#templateBody').sortable({items: 'div:not(div[data-type=\\'Mountain\\'])'})\n  $('#mapLayers, #templateBody').disableSelection()\n\n  function zoomed() {\n    const scaleDiff = Math.abs(scale - d3.event.transform.k)\n    scale = d3.event.transform.k\n    viewX = d3.event.transform.x\n    viewY = d3.event.transform.y\n    viewbox.attr('transform', d3.event.transform)\n    // rescale only if zoom is significally changed\n    if (scaleDiff > 0.001) {\n      invokeActiveZooming()\n      drawScaleBar()\n    }\n  }\n\n  // Zoom to specific point (x,y - coods, z - scale, d - duration)\n  function zoomTo(x, y, z, d) {\n    const transform = d3.zoomIdentity.translate(x * -z + graphWidth / 2, y * -z + graphHeight / 2)\n                        .scale(z)\n    svg.transition().duration(d).call(zoom.transform, transform)\n  }\n\n  // Reset zoom to initial\n  function resetZoom(duration) {\n    zoom.transform(svg, d3.zoomIdentity)\n  }\n\n  // Active zooming\n  function invokeActiveZooming() {\n    // toggle shade/blur filter on zoom\n    let filter = scale > 2.6 ? 'url(#blurFilter)' : 'url(#dropShadow)'\n    if (scale > 1.5 && scale <= 2.6) filter = null\n    coastline.attr('filter', filter)\n    // rescale lables on zoom (active zooming)\n    labels.selectAll('g').each(function(d) {\n      const el = d3.select(this)\n      if (el.attr('id') === 'burgLabels') return\n      const desired = +el.attr('data-size')\n      let relative = _.round((desired + desired / scale) / 2, 2)\n      if (relative < 2) relative = 2\n      el.attr('font-size', relative)\n      if ($('#hideLabels').checked) {\n        el.classed('hidden', relative * scale < 6)\n        updateLabelGroups()\n      }\n    })\n\n    // rescale map markers\n    markers.selectAll('use').each(function(d) {\n      const el = d3.select(this)\n      let x = +el.attr('data-x'), y = +el.attr('data-y')\n      const desired = +el.attr('data-size')\n      let size = desired * 5 + 25 / scale\n      if (size < 1) size = 1\n      el.attr('x', x - size / 2).attr('y', y - size).attr('width', size).attr('height', size)\n    })\n\n    if (ruler.size()) {\n      if (ruler.style('display') !== 'none') {\n        if (ruler.selectAll('g').size() < 1) {return}\n        const factor = _.round(1 / Math.pow(scale, 0.3), 1)\n        ruler.selectAll('circle:not(.center)').attr('r', 2 * factor)\n             .attr('stroke-width', 0.5 * factor)\n        ruler.selectAll('circle.center').attr('r', 1.2 * factor)\n             .attr('stroke-width', 0.3 * factor)\n        ruler.selectAll('text').attr('font-size', 10 * factor)\n        ruler.selectAll('line, path').attr('stroke-width', factor)\n      }\n    }\n  }\n\n  addDragToUpload()\n\n  // Changelog dialog window\n  const storedVersion = localStorage.getItem('version') // show message on load\n  if (storedVersion != version) {\n    alertMessage.innerHTML = `<b>2018-29-23</b>:\n    The <i>Fantasy Map Generator</i> is updated up to version <b>${version}</b>.\n    Main changes:<br><br>\n    <li>Map Markers</li>\n    <li>Legend Editor (text notes)</li>\n    <li>Bug fixes</li>\n    <br>See a <a href='https://www.reddit.com/r/FantasyMapGenerator/comments/9iarje/update_new_version_is_published_v060b' target='_blank'>dedicated post</a> for the details.\n    <br><br>\n    <i>Join our <a href='https://www.reddit.com/r/FantasyMapGenerator/' target='_blank'>Reddit community</a>\n    to share created maps, discuss the Generator, report bugs, ask questions and propose new features.\n    You may also report bugs <a href='https://github.com/Azgaar/Fantasy-Map-Generator/issues' target='_blank'>here</a>.</i>`\n\n    $('#alert').dialog(\n      {\n        resizable: false, title: 'Fantasy Map Generator update', width: 320,\n        buttons: {\n          'Don\\'t show again': function() {\n            localStorage.setItem('version', version)\n            $(this).dialog('close')\n          },\n          Close: function() {$(this).dialog('close')}\n        },\n        position: {my: 'center', at: 'center', of: 'svg'}\n      })\n  }\n\n  getSeed() // get and set random generator seed\n  applyNamesData() // apply default namesbase on load\n  generate() // generate map on load\n  applyDefaultStyle() // apply style on load\n  focusOn() // based on searchParams focus on point, cell or burg from MFCG\n  invokeActiveZooming() // to hide what need to be hidden\n\n  function generate() {\n    console.group('Random map')\n    console.time('TOTAL')\n    applyMapSize()\n    randomizeOptions()\n    placePoints()\n    calculateVoronoi(points)\n    detectNeighbors()\n    drawScaleBar()\n    defineHeightmap()\n    markFeatures()\n    drawOcean()\n    elevateLakes()\n    resolveDepressionsPrimary()\n    reGraph()\n    resolveDepressionsSecondary()\n    flux()\n    addLakes()\n    drawCoastline()\n    drawRelief()\n    generateCultures()\n    manorsAndRegions()\n    cleanData()\n    console.timeEnd('TOTAL')\n    console.groupEnd('Random map')\n  }\n\n  // get or generate map seed\n  function getSeed() {\n    const url = new URL(window.location.href)\n    params = url.searchParams\n    seed = params.get('seed') || Math.floor(Math.random() * 1e9)\n    console.log(' seed: ' + seed)\n    $('#optionsSeed').value = seed\n    seedrandom(seed)\n  }\n\n  // generate new map seed\n  function changeSeed() {\n    seed = Math.floor(Math.random() * 1e9)\n    console.log(' seed: ' + seed)\n    $('#optionsSeed').value = seed\n    seedrandom(seed)\n  }\n\n  // load options from LocalStorage is any\n  function applyStoredOptions() {\n    if (localStorage.getItem('mapWidth') && localStorage.getItem('mapHeight')) {\n      mapWidthInput.value = localStorage.getItem('mapWidth')\n      mapHeightInput.value = localStorage.getItem('mapHeight')\n    } else {\n      mapWidthInput.value = window.innerWidth\n      mapHeightInput.value = window.innerHeight\n    }\n    if (localStorage.getItem('graphSize')) {\n      graphSize = localStorage.getItem('graphSize')\n      sizeInput.value = sizeOutput.value = graphSize\n    } else {\n      graphSize = +sizeInput.value\n    }\n    if (localStorage.getItem('template')) {\n      templateInput.value = localStorage.getItem('template')\n      lockTemplateInput.setAttribute('data-locked', 1)\n      lockTemplateInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('manors')) {\n      manorsInput.value = manorsOutput.value = localStorage.getItem('manors')\n      lockManorsInput.setAttribute('data-locked', 1)\n      lockManorsInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('regions')) {\n      regionsInput.value = regionsOutput.value = localStorage.getItem('regions')\n      lockRegionsInput.setAttribute('data-locked', 1)\n      lockRegionsInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('power')) {\n      powerInput.value = powerOutput.value = localStorage.getItem('power')\n      lockPowerInput.setAttribute('data-locked', 1)\n      lockPowerInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('neutral')) neutralInput.value =\n      neutralOutput.value = localStorage.getItem('neutral')\n    if (localStorage.getItem('names')) {\n      namesInput.value = localStorage.getItem('names')\n      lockNamesInput.setAttribute('data-locked', 1)\n      lockNamesInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('cultures')) {\n      culturesInput.value = culturesOutput.value = localStorage.getItem('cultures')\n      lockCulturesInput.setAttribute('data-locked', 1)\n      lockCulturesInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('prec')) {\n      precInput.value = precOutput.value = localStorage.getItem('prec')\n      lockPrecInput.setAttribute('data-locked', 1)\n      lockPrecInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('swampiness')) swampinessInput.value =\n      swampinessOutput.value = localStorage.getItem('swampiness')\n    if (localStorage.getItem('outlineLayers')) outlineLayersInput.value =\n      localStorage.getItem('outlineLayers')\n    if (localStorage.getItem('pngResolution')) {\n      pngResolutionInput.value = localStorage.getItem('pngResolution')\n      pngResolutionOutput.value = pngResolutionInput.value + 'x'\n    }\n    if (localStorage.getItem('transparency')) {\n      transparencyInput.value = transparencyOutput.value = localStorage.getItem('transparency')\n      changeDialogsTransparency(transparencyInput.value)\n    } else {changeDialogsTransparency(0)}\n  }\n\n  function restoreDefaultOptions() {\n    // remove ALL saved data from LocalStorage\n    localStorage.clear()\n    // set defaut values\n    mapWidthInput.value = window.innerWidth\n    mapHeightInput.value = window.innerHeight\n    changeMapSize()\n    graphSize = sizeInput.value = sizeOutput.value = 1\n    $('#options i[class^=\\'icon-lock\\']').each(function() {\n      this.setAttribute('data-locked', 0)\n      this.className = 'icon-lock-open'\n      if (this.id === 'lockNeutralInput' || this.id === 'lockSwampinessInput') {\n        this.setAttribute('data-locked', 1)\n        this.className = 'icon-lock'\n      }\n    })\n    neutralInput.value = neutralOutput.value = 200\n    swampinessInput.value = swampinessOutput.value = 10\n    outlineLayersInput.value = '-6,-3,-1'\n    transparencyInput.value = transparencyOutput.value = 0\n    changeDialogsTransparency(0)\n    pngResolutionInput.value = 5\n    pngResolutionOutput.value = '5x'\n    randomizeOptions()\n  }\n\n  // apply names data from localStorage if available\n  function applyNamesData() {\n    applyDefaultNamesData()\n    defaultCultures = [\n      {name: 'Shwazen', color: '#b3b3b3', base: 0},\n      {name: 'Angshire', color: '#fca463', base: 1},\n      {name: 'Luari', color: '#99acfb', base: 2},\n      {name: 'Tallian', color: '#a6d854', base: 3},\n      {name: 'Toledi', color: '#ffd92f', base: 4},\n      {name: 'Slovian', color: '#e5c494', base: 5},\n      {name: 'Norse', color: '#dca3e4', base: 6},\n      {name: 'Elladian', color: '#66c4a0', base: 7},\n      {name: 'Latian', color: '#ff7174', base: 8},\n      {name: 'Soomi', color: '#85c8fa', base: 9},\n      {name: 'Koryo', color: '#578880', base: 10},\n      {name: 'Hantzu', color: '#becb8d', base: 11},\n      {name: 'Yamoto', color: '#ffd9da', base: 12}\n    ]\n  }\n\n  // apply default names data\n  function applyDefaultNamesData() {\n    nameBases = [                                                                   // min; max; mean; common\n      {name: 'German', method: 'let-to-syl', min: 4, max: 11, d: 'lt', m: 0.1},     // real: 3; 17; 8.6; 8\n      {name: 'English', method: 'let-to-syl', min: 5, max: 10, d: '', m: 0.3},      // real: 4; 13; 7.9; 8\n      {name: 'French', method: 'let-to-syl', min: 4, max: 10, d: 'lns', m: 0.3},    // real: 3; 15; 7.6; 6\n      {name: 'Italian', method: 'let-to-syl', min: 4, max: 11, d: 'clrt', m: 0.2},  // real: 4; 14; 7.7; 7\n      {name: 'Castillian', method: 'let-to-syl', min: 4, max: 10, d: 'lr', m: 0},   // real: 2; 13; 7.5; 8\n      {name: 'Ruthenian', method: 'let-to-syl', min: 4, max: 9, d: '', m: 0},       // real: 3; 12; 7.1; 7\n      {name: 'Nordic', method: 'let-to-syl', min: 5, max: 9, d: 'kln', m: 0.1},     // real: 3; 12; 7.5; 6\n      {name: 'Greek', method: 'let-to-syl', min: 4, max: 10, d: 'ls', m: 0.2},      // real: 3; 14; 7.1; 6\n      {name: 'Roman', method: 'let-to-syl', min: 5, max: 10, d: '', m: 1},          // real: 3; 15; 8.0; 7\n      {name: 'Finnic', method: 'let-to-syl', min: 3, max: 10, d: 'aktu', m: 0},     // real: 3; 13; 7.5; 6\n      {name: 'Korean', method: 'let-to-syl', min: 5, max: 10, d: '', m: 0},         // real: 3; 13; 6.8; 7\n      {name: 'Chinese', method: 'let-to-syl', min: 5, max: 9, d: '', m: 0},         // real: 4; 11; 6.9; 6\n      {name: 'Japanese', method: 'let-to-syl', min: 3, max: 9, d: '', m: 0}         // real: 2; 15; 6.8; 6\n    ]\n    nameBase = [\n      ['Achern', 'Aichhalden', 'Aitern', 'Albbruck', 'Alpirsbach', 'Altensteig', 'Althengstett', 'Appenweier', 'Auggen', 'Wildbad', 'Badenen', 'Badenweiler', 'Baiersbronn', 'Ballrechten', 'Bellingen', 'Berghaupten', 'Bernau', 'Biberach', 'Biederbach', 'Binzen', 'Birkendorf', 'Birkenfeld', 'Bischweier', 'Blumberg', 'Bollen', 'Bollschweil', 'Bonndorf', 'Bosingen', 'Braunlingen', 'Breisach', 'Breisgau', 'Breitnau', 'Brigachtal', 'Buchenbach', 'Buggingen', 'Buhl', 'Buhlertal', 'Calw', 'Dachsberg', 'Dobel', 'Donaueschingen', 'Dornhan', 'Dornstetten', 'Dottingen', 'Dunningen', 'Durbach', 'Durrheim', 'Ebhausen', 'Ebringen', 'Efringen', 'Egenhausen', 'Ehrenkirchen', 'Ehrsberg', 'Eimeldingen', 'Eisenbach', 'Elzach', 'Elztal', 'Emmendingen', 'Endingen', 'Engelsbrand', 'Enz', 'Enzklosterle', 'Eschbronn', 'Ettenheim', 'Ettlingen', 'Feldberg', 'Fischerbach', 'Fischingen', 'Fluorn', 'Forbach', 'Freiamt', 'Freiburg', 'Freudenstadt', 'Friedenweiler', 'Friesenheim', 'Frohnd', 'Furtwangen', 'Gaggenau', 'Geisingen', 'Gengenbach', 'Gernsbach', 'Glatt', 'Glatten', 'Glottertal', 'Gorwihl', 'Gottenheim', 'Grafenhausen', 'Grenzach', 'Griesbach', 'Gutach', 'Gutenbach', 'Hag', 'Haiterbach', 'Hardt', 'Harmersbach', 'Hasel', 'Haslach', 'Hausach', 'Hausen', 'Hausern', 'Heitersheim', 'Herbolzheim', 'Herrenalb', 'Herrischried', 'Hinterzarten', 'Hochenschwand', 'Hofen', 'Hofstetten', 'Hohberg', 'Horb', 'Horben', 'Hornberg', 'Hufingen', 'Ibach', 'Ihringen', 'Inzlingen', 'Kandern', 'Kappel', 'Kappelrodeck', 'Karlsbad', 'Karlsruhe', 'Kehl', 'Keltern', 'Kippenheim', 'Kirchzarten', 'Konigsfeld', 'Krozingen', 'Kuppenheim', 'Kussaberg', 'Lahr', 'Lauchringen', 'Lauf', 'Laufenburg', 'Lautenbach', 'Lauterbach', 'Lenzkirch', 'Liebenzell', 'Loffenau', 'Loffingen', 'Lorrach', 'Lossburg', 'Mahlberg', 'Malsburg', 'Malsch', 'March', 'Marxzell', 'Marzell', 'Maulburg', 'Monchweiler', 'Muhlenbach', 'Mullheim', 'Munstertal', 'Murg', 'Nagold', 'Neubulach', 'Neuenburg', 'Neuhausen', 'Neuried', 'Neuweiler', 'Niedereschach', 'Nordrach', 'Oberharmersbach', 'Oberkirch', 'Oberndorf', 'Oberbach', 'Oberried', 'Oberwolfach', 'Offenburg', 'Ohlsbach', 'Oppenau', 'Ortenberg', 'otigheim', 'Ottenhofen', 'Ottersweier', 'Peterstal', 'Pfaffenweiler', 'Pfalzgrafenweiler', 'Pforzheim', 'Rastatt', 'Renchen', 'Rheinau', 'Rheinfelden', 'Rheinmunster', 'Rickenbach', 'Rippoldsau', 'Rohrdorf', 'Rottweil', 'Rummingen', 'Rust', 'Sackingen', 'Sasbach', 'Sasbachwalden', 'Schallbach', 'Schallstadt', 'Schapbach', 'Schenkenzell', 'Schiltach', 'Schliengen', 'Schluchsee', 'Schomberg', 'Schonach', 'Schonau', 'Schonenberg', 'Schonwald', 'Schopfheim', 'Schopfloch', 'Schramberg', 'Schuttertal', 'Schwenningen', 'Schworstadt', 'Seebach', 'Seelbach', 'Seewald', 'Sexau', 'Simmersfeld', 'Simonswald', 'Sinzheim', 'Solden', 'Staufen', 'Stegen', 'Steinach', 'Steinen', 'Steinmauern', 'Straubenhardt', 'Stuhlingen', 'Sulz', 'Sulzburg', 'Teinach', 'Tiefenbronn', 'Tiengen', 'Titisee', 'Todtmoos', 'Todtnau', 'Todtnauberg', 'Triberg', 'Tunau', 'Tuningen', 'uhlingen', 'Unterkirnach', 'Reichenbach', 'Utzenfeld', 'Villingen', 'Villingendorf', 'Vogtsburg', 'Vohrenbach', 'Waldachtal', 'Waldbronn', 'Waldkirch', 'Waldshut', 'Wehr', 'Weil', 'Weilheim', 'Weisenbach', 'Wembach', 'Wieden', 'Wiesental', 'Wildberg', 'Winzeln', 'Wittlingen', 'Wittnau', 'Wolfach', 'Wutach', 'Wutoschingen', 'Wyhlen', 'Zavelstein'],\n      ['Abingdon', 'Albrighton', 'Alcester', 'Almondbury', 'Altrincham', 'Amersham', 'Andover', 'Appleby', 'Ashboume', 'Atherstone', 'Aveton', 'Axbridge', 'Aylesbury', 'Baldock', 'Bamburgh', 'Barton', 'Basingstoke', 'Berden', 'Bere', 'Berkeley', 'Berwick', 'Betley', 'Bideford', 'Bingley', 'Birmingham', 'Blandford', 'Blechingley', 'Bodmin', 'Bolton', 'Bootham', 'Boroughbridge', 'Boscastle', 'Bossinney', 'Bramber', 'Brampton', 'Brasted', 'Bretford', 'Bridgetown', 'Bridlington', 'Bromyard', 'Bruton', 'Buckingham', 'Bungay', 'Burton', 'Calne', 'Cambridge', 'Canterbury', 'Carlisle', 'Castleton', 'Caus', 'Charmouth', 'Chawleigh', 'Chichester', 'Chillington', 'Chinnor', 'Chipping', 'Chisbury', 'Cleobury', 'Clifford', 'Clifton', 'Clitheroe', 'Cockermouth', 'Coleshill', 'Combe', 'Congleton', 'Crafthole', 'Crediton', 'Cuddenbeck', 'Dalton', 'Darlington', 'Dodbrooke', 'Drax', 'Dudley', 'Dunstable', 'Dunster', 'Dunwich', 'Durham', 'Dymock', 'Exeter', 'Exning', 'Faringdon', 'Felton', 'Fenny', 'Finedon', 'Flookburgh', 'Fowey', 'Frampton', 'Gateshead', 'Gatton', 'Godmanchester', 'Grampound', 'Grantham', 'Guildford', 'Halesowen', 'Halton', 'Harbottle', 'Harlow', 'Hatfield', 'Hatherleigh', 'Haydon', 'Helston', 'Henley', 'Hertford', 'Heytesbury', 'Hinckley', 'Hitchin', 'Holme', 'Hornby', 'Horsham', 'Kendal', 'Kenilworth', 'Kilkhampton', 'Kineton', 'Kington', 'Kinver', 'Kirby', 'Knaresborough', 'Knutsford', 'Launceston', 'Leighton', 'Lewes', 'Linton', 'Louth', 'Luton', 'Lyme', 'Lympstone', 'Macclesfield', 'Madeley', 'Malborough', 'Maldon', 'Manchester', 'Manningtree', 'Marazion', 'Marlborough', 'Marshfield', 'Mere', 'Merryfield', 'Middlewich', 'Midhurst', 'Milborne', 'Mitford', 'Modbury', 'Montacute', 'Mousehole', 'Newbiggin', 'Newborough', 'Newbury', 'Newenden', 'Newent', 'Norham', 'Northleach', 'Noss', 'Oakham', 'Olney', 'Orford', 'Ormskirk', 'Oswestry', 'Padstow', 'Paignton', 'Penkneth', 'Penrith', 'Penzance', 'Pershore', 'Petersfield', 'Pevensey', 'Pickering', 'Pilton', 'Pontefract', 'Portsmouth', 'Preston', 'Quatford', 'Reading', 'Redcliff', 'Retford', 'Rockingham', 'Romney', 'Rothbury', 'Rothwell', 'Salisbury', 'Saltash', 'Seaford', 'Seasalter', 'Sherston', 'Shifnal', 'Shoreham', 'Sidmouth', 'Skipsea', 'Skipton', 'Solihull', 'Somerton', 'Southam', 'Southwark', 'Standon', 'Stansted', 'Stapleton', 'Stottesdon', 'Sudbury', 'Swavesey', 'Tamerton', 'Tarporley', 'Tetbury', 'Thatcham', 'Thaxted', 'Thetford', 'Thornbury', 'Tintagel', 'Tiverton', 'Torksey', 'Totnes', 'Towcester', 'Tregoney', 'Trematon', 'Tutbury', 'Uxbridge', 'Wallingford', 'Wareham', 'Warenmouth', 'Wargrave', 'Warton', 'Watchet', 'Watford', 'Wendover', 'Westbury', 'Westcheap', 'Weymouth', 'Whitford', 'Wickwar', 'Wigan', 'Wigmore', 'Winchelsea', 'Winkleigh', 'Wiscombe', 'Witham', 'Witheridge', 'Wiveliscombe', 'Woodbury', 'Yeovil'],\n      ['Adon', 'Aillant', 'Amilly', 'Andonville', 'Ardon', 'Artenay', 'Ascheres', 'Ascoux', 'Attray', 'Aubin', 'Audeville', 'Aulnay', 'Autruy', 'Auvilliers', 'Auxy', 'Aveyron', 'Baccon', 'Bardon', 'Barville', 'Batilly', 'Baule', 'Bazoches', 'Beauchamps', 'Beaugency', 'Beaulieu', 'Beaune', 'Bellegarde', 'Boesses', 'Boigny', 'Boiscommun', 'Boismorand', 'Boisseaux', 'Bondaroy', 'Bonnee', 'Bonny', 'Bordes', 'Bou', 'Bougy', 'Bouilly', 'Boulay', 'Bouzonville', 'Bouzy', 'Boynes', 'Bray', 'Breteau', 'Briare', 'Briarres', 'Bricy', 'Bromeilles', 'Bucy', 'Cepoy', 'Cercottes', 'Cerdon', 'Cernoy', 'Cesarville', 'Chailly', 'Chaingy', 'Chalette', 'Chambon', 'Champoulet', 'Chanteau', 'Chantecoq', 'Chapell', 'Charme', 'Charmont', 'Charsonville', 'Chateau', 'Chateauneuf', 'Chatel', 'Chatenoy', 'Chatillon', 'Chaussy', 'Checy', 'Chevannes', 'Chevillon', 'Chevilly', 'Chevry', 'Chilleurs', 'Choux', 'Chuelles', 'Clery', 'Coinces', 'Coligny', 'Combleux', 'Combreux', 'Conflans', 'Corbeilles', 'Corquilleroy', 'Cortrat', 'Coudroy', 'Coullons', 'Coulmiers', 'Courcelles', 'Courcy', 'Courtemaux', 'Courtempierre', 'Courtenay', 'Cravant', 'Crottes', 'Dadonville', 'Dammarie', 'Dampierre', 'Darvoy', 'Desmonts', 'Dimancheville', 'Donnery', 'Dordives', 'Dossainville', 'Douchy', 'Dry', 'Echilleuses', 'Egry', 'Engenville', 'Epieds', 'Erceville', 'Ervauville', 'Escrennes', 'Escrignelles', 'Estouy', 'Faverelles', 'Fay', 'Feins', 'Ferolles', 'Ferrieres', 'Fleury', 'Fontenay', 'Foret', 'Foucherolles', 'Freville', 'Gatinais', 'Gaubertin', 'Gemigny', 'Germigny', 'Gidy', 'Gien', 'Girolles', 'Givraines', 'Gondreville', 'Grangermont', 'Greneville', 'Griselles', 'Guigneville', 'Guilly', 'Gyleslonains', 'Huetre', 'Huisseau', 'Ingrannes', 'Ingre', 'Intville', 'Isdes', 'Jargeau', 'Jouy', 'Juranville', 'Bussiere', 'Laas', 'Ladon', 'Lailly', 'Langesse', 'Leouville', 'Ligny', 'Lombreuil', 'Lorcy', 'Lorris', 'Loury', 'Louzouer', 'Malesherbois', 'Marcilly', 'Mardie', 'Mareau', 'Marigny', 'Marsainvilliers', 'Melleroy', 'Menestreau', 'Merinville', 'Messas', 'Meung', 'Mezieres', 'Migneres', 'Mignerette', 'Mirabeau', 'Montargis', 'Montbarrois', 'Montbouy', 'Montcresson', 'Montereau', 'Montigny', 'Montliard', 'Mormant', 'Morville', 'Moulinet', 'Moulon', 'Nancray', 'Nargis', 'Nesploy', 'Neuville', 'Neuvy', 'Nevoy', 'Nibelle', 'Nogent', 'Noyers', 'Ocre', 'Oison', 'Olivet', 'Ondreville', 'Onzerain', 'Orleans', 'Ormes', 'Orville', 'Oussoy', 'Outarville', 'Ouzouer', 'Pannecieres', 'Pannes', 'Patay', 'Paucourt', 'Pers', 'Pierrefitte', 'Pithiverais', 'Pithiviers', 'Poilly', 'Potier', 'Prefontaines', 'Presnoy', 'Pressigny', 'Puiseaux', 'Quiers', 'Ramoulu', 'Rebrechien', 'Rouvray', 'Rozieres', 'Rozoy', 'Ruan', 'Sandillon', 'Santeau', 'Saran', 'Sceaux', 'Seichebrieres', 'Semoy', 'Sennely', 'Sermaises', 'Sigloy', 'Solterre', 'Sougy', 'Sully', 'Sury', 'Tavers', 'Thignonville', 'Thimory', 'Thorailles', 'Thou', 'Tigy', 'Tivernon', 'Tournoisis', 'Trainou', 'Treilles', 'Trigueres', 'Trinay', 'Vannes', 'Varennes', 'Vennecy', 'Vieilles', 'Vienne', 'Viglain', 'Vignes', 'Villamblain', 'Villemandeur', 'Villemoutiers', 'Villemurlin', 'Villeneuve', 'Villereau', 'Villevoques', 'Villorceau', 'Vimory', 'Vitry', 'Vrigny', 'Ivre'],\n      ['Accumoli', 'Acquafondata', 'Acquapendente', 'Acuto', 'Affile', 'Agosta', 'Alatri', 'Albano', 'Allumiere', 'Alvito', 'Amaseno', 'Amatrice', 'Anagni', 'Anguillara', 'Anticoli', 'Antrodoco', 'Anzio', 'Aprilia', 'Aquino', 'Arce', 'Arcinazzo', 'Ardea', 'Ariccia', 'Arlena', 'Arnara', 'Arpino', 'Arsoli', 'Artena', 'Ascrea', 'Atina', 'Ausonia', 'Bagnoregio', 'Barbarano', 'Bassano', 'Bassiano', 'Bellegra', 'Belmonte', 'Blera', 'Bolsena', 'Bomarzo', 'Borbona', 'Borgo', 'Borgorose', 'Boville', 'Bracciano', 'Broccostella', 'Calcata', 'Camerata', 'Campagnano', 'Campodimele', 'Campoli', 'Canale', 'Canepina', 'Canino', 'Cantalice', 'Cantalupo', 'Canterano', 'Capena', 'Capodimonte', 'Capranica', 'Caprarola', 'Carbognano', 'Casalattico', 'Casalvieri', 'Casape', 'Casaprota', 'Casperia', 'Cassino', 'Castelforte', 'Castelliri', 'Castello', 'Castelnuovo', 'Castiglione', 'Castro', 'Castrocielo', 'Cave', 'Ceccano', 'Celleno', 'Cellere', 'Ceprano', 'Cerreto', 'Cervara', 'Cervaro', 'Cerveteri', 'Ciampino', 'Ciciliano', 'Cineto', 'Cisterna', 'Cittaducale', 'Cittareale', 'Civita', 'Civitavecchia', 'Civitella', 'Colfelice', 'Collalto', 'Colle', 'Colleferro', 'Collegiove', 'Collepardo', 'Collevecchio', 'Colli', 'Colonna', 'Concerviano', 'Configni', 'Contigliano', 'Corchiano', 'Coreno', 'Cori', 'Cottanello', 'Esperia', 'Fabrica', 'Faleria', 'Falvaterra', 'Fara', 'Farnese', 'Ferentino', 'Fiamignano', 'Fiano', 'Filacciano', 'Filettino', 'Fiuggi', 'Fiumicino', 'Fondi', 'Fontana', 'Fonte', 'Fontechiari', 'Forano', 'Formello', 'Formia', 'Frascati', 'Frasso', 'Frosinone', 'Fumone', 'Gaeta', 'Gallese', 'Gallicano', 'Gallinaro', 'Gavignano', 'Genazzano', 'Genzano', 'Gerano', 'Giuliano', 'Gorga', 'Gradoli', 'Graffignano', 'Greccio', 'Grottaferrata', 'Grotte', 'Guarcino', 'Guidonia', 'Ischia', 'Isola', 'Itri', 'Jenne', 'Labico', 'Labro', 'Ladispoli', 'Lanuvio', 'Lariano', 'Latera', 'Lenola', 'Leonessa', 'Licenza', 'Longone', 'Lubriano', 'Maenza', 'Magliano', 'Mandela', 'Manziana', 'Marano', 'Marcellina', 'Marcetelli', 'Marino', 'Marta', 'Mazzano', 'Mentana', 'Micigliano', 'Minturno', 'Mompeo', 'Montalto', 'Montasola', 'Monte', 'Montebuono', 'Montefiascone', 'Monteflavio', 'Montelanico', 'Monteleone', 'Montelibretti', 'Montenero', 'Monterosi', 'Monterotondo', 'Montopoli', 'Montorio', 'Moricone', 'Morlupo', 'Morolo', 'Morro', 'Nazzano', 'Nemi', 'Nepi', 'Nerola', 'Nespolo', 'Nettuno', 'Norma', 'Olevano', 'Onano', 'Oriolo', 'Orte', 'Orvinio', 'Paganico', 'Palestrina', 'Paliano', 'Palombara', 'Pastena', 'Patrica', 'Percile', 'Pescorocchiano', 'Pescosolido', 'Petrella', 'Piansano', 'Picinisco', 'Pico', 'Piedimonte', 'Piglio', 'Pignataro', 'Pisoniano', 'Pofi', 'Poggio', 'Poli', 'Pomezia', 'Pontecorvo', 'Pontinia', 'Ponza', 'Ponzano', 'Posta', 'Pozzaglia', 'Priverno', 'Proceno', 'Prossedi', 'Riano', 'Rieti', 'Rignano', 'Riofreddo', 'Ripi', 'Rivodutri', 'Rocca', 'Roccagiovine', 'Roccagorga', 'Roccantica', 'Roccasecca', 'Roiate', 'Ronciglione', 'Roviano', 'Sabaudia', 'Sacrofano', 'Salisano', 'Sambuci', 'Santa', 'Santi', 'Santopadre', 'Saracinesco', 'Scandriglia', 'Segni', 'Selci', 'Sermoneta', 'Serrone', 'Settefrati', 'Sezze', 'Sgurgola', 'Sonnino', 'Sora', 'Soriano', 'Sperlonga', 'Spigno', 'Stimigliano', 'Strangolagalli', 'Subiaco', 'Supino', 'Sutri', 'Tarano', 'Tarquinia', 'Terelle', 'Terracina', 'Tessennano', 'Tivoli', 'Toffia', 'Tolfa', 'Torre', 'Torri', 'Torrice', 'Torricella', 'Torrita', 'Trevi', 'Trevignano', 'Trivigliano', 'Turania', 'Tuscania', 'Vacone', 'Valentano', 'Vallecorsa', 'Vallemaio', 'Vallepietra', 'Vallerano', 'Vallerotonda', 'Vallinfreda', 'Valmontone', 'Varco', 'Vasanello', 'Vejano', 'Velletri', 'Ventotene', 'Veroli', 'Vetralla', 'Vicalvi', 'Vico', 'Vicovaro', 'Vignanello', 'Viterbo', 'Viticuso', 'Vitorchiano', 'Vivaro', 'Zagarolo'],\n      ['Abanades', 'Ablanque', 'Adobes', 'Ajofrin', 'Alameda', 'Alaminos', 'Alarilla', 'Albalate', 'Albares', 'Albarreal', 'Albendiego', 'Alcabon', 'Alcanizo', 'Alcaudete', 'Alcocer', 'Alcolea', 'Alcoroches', 'Aldea', 'Aldeanueva', 'Algar', 'Algora', 'Alhondiga', 'Alique', 'Almadrones', 'Almendral', 'Almoguera', 'Almonacid', 'Almorox', 'Alocen', 'Alovera', 'Alustante', 'Angon', 'Anguita', 'Anover', 'Anquela', 'Arbancon', 'Arbeteta', 'Arcicollar', 'Argecilla', 'Arges', 'Armallones', 'Armuna', 'Arroyo', 'Atanzon', 'Atienza', 'Aunon', 'Azuqueca', 'Azutan', 'Baides', 'Banos', 'Banuelos', 'Barcience', 'Bargas', 'Barriopedro', 'Belvis', 'Berninches', 'Borox', 'Brihuega', 'Budia', 'Buenaventura', 'Bujalaro', 'Burguillos', 'Burujon', 'Bustares', 'Cabanas', 'Cabanillas', 'Calera', 'Caleruela', 'Calzada', 'Camarena', 'Campillo', 'Camunas', 'Canizar', 'Canredondo', 'Cantalojas', 'Cardiel', 'Carmena', 'Carranque', 'Carriches', 'Casa', 'Casarrubios', 'Casas', 'Casasbuenas', 'Caspuenas', 'Castejon', 'Castellar', 'Castilforte', 'Castillo', 'Castilnuevo', 'Cazalegas', 'Cebolla', 'Cedillo', 'Cendejas', 'Centenera', 'Cervera', 'Checa', 'Chequilla', 'Chillaron', 'Chiloeches', 'Chozas', 'Chueca', 'Cifuentes', 'Cincovillas', 'Ciruelas', 'Ciruelos', 'Cobeja', 'Cobeta', 'Cobisa', 'Cogollor', 'Cogolludo', 'Condemios', 'Congostrina', 'Consuegra', 'Copernal', 'Corduente', 'Corral', 'Cuerva', 'Domingo', 'Dosbarrios', 'Driebes', 'Duron', 'El', 'Embid', 'Erustes', 'Escalona', 'Escalonilla', 'Escamilla', 'Escariche', 'Escopete', 'Espinosa', 'Espinoso', 'Esplegares', 'Esquivias', 'Estables', 'Estriegana', 'Fontanar', 'Fuembellida', 'Fuensalida', 'Fuentelsaz', 'Gajanejos', 'Galve', 'Galvez', 'Garciotum', 'Gascuena', 'Gerindote', 'Guadamur', 'Henche', 'Heras', 'Herreria', 'Herreruela', 'Hijes', 'Hinojosa', 'Hita', 'Hombrados', 'Hontanar', 'Hontoba', 'Horche', 'Hormigos', 'Huecas', 'Huermeces', 'Huerta', 'Hueva', 'Humanes', 'Illan', 'Illana', 'Illescas', 'Iniestola', 'Irueste', 'Jadraque', 'Jirueque', 'Lagartera', 'Las', 'Layos', 'Ledanca', 'Lillo', 'Lominchar', 'Loranca', 'Los', 'Lucillos', 'Lupiana', 'Luzaga', 'Luzon', 'Madridejos', 'Magan', 'Majaelrayo', 'Malaga', 'Malaguilla', 'Malpica', 'Mandayona', 'Mantiel', 'Manzaneque', 'Maqueda', 'Maranchon', 'Marchamalo', 'Marjaliza', 'Marrupe', 'Mascaraque', 'Masegoso', 'Matarrubia', 'Matillas', 'Mazarete', 'Mazuecos', 'Medranda', 'Megina', 'Mejorada', 'Mentrida', 'Mesegar', 'Miedes', 'Miguel', 'Millana', 'Milmarcos', 'Mirabueno', 'Miralrio', 'Mocejon', 'Mochales', 'Mohedas', 'Molina', 'Monasterio', 'Mondejar', 'Montarron', 'Mora', 'Moratilla', 'Morenilla', 'Muduex', 'Nambroca', 'Navalcan', 'Negredo', 'Noblejas', 'Noez', 'Nombela', 'Noves', 'Numancia', 'Nuno', 'Ocana', 'Ocentejo', 'Olias', 'Olmeda', 'Ontigola', 'Orea', 'Orgaz', 'Oropesa', 'Otero', 'Palmaces', 'Palomeque', 'Pantoja', 'Pardos', 'Paredes', 'Pareja', 'Parrillas', 'Pastrana', 'Pelahustan', 'Penalen', 'Penalver', 'Pepino', 'Peralejos', 'Peralveche', 'Pinilla', 'Pioz', 'Piqueras', 'Polan', 'Portillo', 'Poveda', 'Pozo', 'Pradena', 'Prados', 'Puebla', 'Puerto', 'Pulgar', 'Quer', 'Quero', 'Quintanar', 'Quismondo', 'Rebollosa', 'Recas', 'Renera', 'Retamoso', 'Retiendas', 'Riba', 'Rielves', 'Rillo', 'Riofrio', 'Robledillo', 'Robledo', 'Romanillos', 'Romanones', 'Rueda', 'Sacecorbo', 'Sacedon', 'Saelices', 'Salmeron', 'San', 'Santa', 'Santiuste', 'Santo', 'Sartajada', 'Sauca', 'Sayaton', 'Segurilla', 'Selas', 'Semillas', 'Sesena', 'Setiles', 'Sevilleja', 'Sienes', 'Siguenza', 'Solanillos', 'Somolinos', 'Sonseca', 'Sotillo', 'Sotodosos', 'Talavera', 'Tamajon', 'Taragudo', 'Taravilla', 'Tartanedo', 'Tembleque', 'Tendilla', 'Terzaga', 'Tierzo', 'Tordellego', 'Tordelrabano', 'Tordesilos', 'Torija', 'Torralba', 'Torre', 'Torrecilla', 'Torrecuadrada', 'Torrejon', 'Torremocha', 'Torrico', 'Torrijos', 'Torrubia', 'Tortola', 'Tortuera', 'Tortuero', 'Totanes', 'Traid', 'Trijueque', 'Trillo', 'Turleque', 'Uceda', 'Ugena', 'Ujados', 'Urda', 'Utande', 'Valdarachas', 'Valdesotos', 'Valhermoso', 'Valtablado', 'Valverde', 'Velada', 'Viana', 'Vinuelas', 'Yebes', 'Yebra', 'Yelamos', 'Yeles', 'Yepes', 'Yuncler', 'Yunclillos', 'Yuncos', 'Yunquera', 'Zaorejas', 'Zarzuela', 'Zorita'],\n      ['Belgorod', 'Beloberezhye', 'Belyi', 'Belz', 'Berestiy', 'Berezhets', 'Berezovets', 'Berezutsk', 'Bobruisk', 'Bolonets', 'Borisov', 'Borovsk', 'Bozhesk', 'Bratslav', 'Bryansk', 'Brynsk', 'Buryn', 'Byhov', 'Chechersk', 'Chemesov', 'Cheremosh', 'Cherlen', 'Chern', 'Chernigov', 'Chernitsa', 'Chernobyl', 'Chernogorod', 'Chertoryesk', 'Chetvertnia', 'Demyansk', 'Derevesk', 'Devyagoresk', 'Dichin', 'Dmitrov', 'Dorogobuch', 'Dorogobuzh', 'Drestvin', 'Drokov', 'Drutsk', 'Dubechin', 'Dubichi', 'Dubki', 'Dubkov', 'Dveren', 'Galich', 'Glebovo', 'Glinsk', 'Goloty', 'Gomiy', 'Gorodets', 'Gorodische', 'Gorodno', 'Gorohovets', 'Goroshin', 'Gorval', 'Goryshon', 'Holm', 'Horobor', 'Hoten', 'Hotin', 'Hotmyzhsk', 'Ilovech', 'Ivan', 'Izborsk', 'Izheslavl', 'Kamenets', 'Kanev', 'Karachev', 'Karna', 'Kavarna', 'Klechesk', 'Klyapech', 'Kolomyya', 'Kolyvan', 'Kopyl', 'Korec', 'Kornik', 'Korochunov', 'Korshev', 'Korsun', 'Koshkin', 'Kotelno', 'Kovyla', 'Kozelsk', 'Kozelsk', 'Kremenets', 'Krichev', 'Krylatsk', 'Ksniatin', 'Kulatsk', 'Kursk', 'Kursk', 'Lebedev', 'Lida', 'Logosko', 'Lomihvost', 'Loshesk', 'Loshichi', 'Lubech', 'Lubno', 'Lubutsk', 'Lutsk', 'Luchin', 'Luki', 'Lukoml', 'Luzha', 'Lvov', 'Mtsensk', 'Mdin', 'Medniki', 'Melecha', 'Merech', 'Meretsk', 'Mescherskoe', 'Meshkovsk', 'Metlitsk', 'Mezetsk', 'Mglin', 'Mihailov', 'Mikitin', 'Mikulino', 'Miloslavichi', 'Mogilev', 'Mologa', 'Moreva', 'Mosalsk', 'Moschiny', 'Mozyr', 'Mstislav', 'Mstislavets', 'Muravin', 'Nemech', 'Nemiza', 'Nerinsk', 'Nichan', 'Novgorod', 'Novogorodok', 'Obolichi', 'Obolensk', 'Obolensk', 'Oleshsk', 'Olgov', 'Omelnik', 'Opoka', 'Opoki', 'Oreshek', 'Orlets', 'Osechen', 'Oster', 'Ostrog', 'Ostrov', 'Perelai', 'Peremil', 'Peremyshl', 'Pererov', 'Peresechen', 'Perevitsk', 'Pereyaslav', 'Pinsk', 'Ples', 'Polotsk', 'Pronsk', 'Proposhesk', 'Punia', 'Putivl', 'Rechitsa', 'Rodno', 'Rogachev', 'Romanov', 'Romny', 'Roslavl', 'Rostislavl', 'Rostovets', 'Rsha', 'Ruza', 'Rybchesk', 'Rylsk', 'Rzhavesk', 'Rzhev', 'Rzhischev', 'Sambor', 'Serensk', 'Serensk', 'Serpeysk', 'Shilov', 'Shuya', 'Sinech', 'Sizhka', 'Skala', 'Slovensk', 'Slutsk', 'Smedin', 'Sneporod', 'Snitin', 'Snovsk', 'Sochevo', 'Sokolec', 'Starica', 'Starodub', 'Stepan', 'Sterzh', 'Streshin', 'Sutesk', 'Svinetsk', 'Svisloch', 'Terebovl', 'Ternov', 'Teshilov', 'Teterin', 'Tiversk', 'Torchevsk', 'Toropets', 'Torzhok', 'Tripolye', 'Trubchevsk', 'Tur', 'Turov', 'Usvyaty', 'Uteshkov', 'Vasilkov', 'Velil', 'Velye', 'Venev', 'Venicha', 'Verderev', 'Vereya', 'Veveresk', 'Viazma', 'Vidbesk', 'Vidychev', 'Voino', 'Volodimer', 'Volok', 'Volyn', 'Vorobesk', 'Voronich', 'Voronok', 'Vorotynsk', 'Vrev', 'Vruchiy', 'Vselug', 'Vyatichsk', 'Vyatka', 'Vyshegorod', 'Vyshgorod', 'Vysokoe', 'Yagniatin', 'Yaropolch', 'Yasenets', 'Yuryev', 'Yuryevets', 'Zaraysk', 'Zhitomel', 'Zholvazh', 'Zizhech', 'Zubkov', 'Zudechev', 'Zvenigorod'],\n      ['Akureyri', 'Aldra', 'Alftanes', 'Andenes', 'Austbo', 'Auvog', 'Bakkafjordur', 'Ballangen', 'Bardal', 'Beisfjord', 'Bifrost', 'Bildudalur', 'Bjerka', 'Bjerkvik', 'Bjorkosen', 'Bliksvaer', 'Blokken', 'Blonduos', 'Bolga', 'Bolungarvik', 'Borg', 'Borgarnes', 'Bosmoen', 'Bostad', 'Bostrand', 'Botsvika', 'Brautarholt', 'Breiddalsvik', 'Bringsli', 'Brunahlid', 'Budardalur', 'Byggdakjarni', 'Dalvik', 'Djupivogur', 'Donnes', 'Drageid', 'Drangsnes', 'Egilsstadir', 'Eiteroga', 'Elvenes', 'Engavogen', 'Ertenvog', 'Eskifjordur', 'Evenes', 'Eyrarbakki', 'Fagernes', 'Fallmoen', 'Fellabaer', 'Fenes', 'Finnoya', 'Fjaer', 'Fjelldal', 'Flakstad', 'Flateyri', 'Flostrand', 'Fludir', 'Gardabær', 'Gardur', 'Gimstad', 'Givaer', 'Gjeroy', 'Gladstad', 'Godoya', 'Godoynes', 'Granmoen', 'Gravdal', 'Grenivik', 'Grimsey', 'Grindavik', 'Grytting', 'Hafnir', 'Halsa', 'Hauganes', 'Haugland', 'Hauknes', 'Hella', 'Helland', 'Hellissandur', 'Hestad', 'Higrav', 'Hnifsdalur', 'Hofn', 'Hofsos', 'Holand', 'Holar', 'Holen', 'Holkestad', 'Holmavik', 'Hopen', 'Hovden', 'Hrafnagil', 'Hrisey', 'Husavik', 'Husvik', 'Hvammstangi', 'Hvanneyri', 'Hveragerdi', 'Hvolsvollur', 'Igeroy', 'Indre', 'Inndyr', 'Innhavet', 'Innes', 'Isafjordur', 'Jarklaustur', 'Jarnsreykir', 'Junkerdal', 'Kaldvog', 'Kanstad', 'Karlsoy', 'Kavosen', 'Keflavik', 'Kjelde', 'Kjerstad', 'Klakk', 'Kopasker', 'Kopavogur', 'Korgen', 'Kristnes', 'Krutoga', 'Krystad', 'Kvina', 'Lande', 'Laugar', 'Laugaras', 'Laugarbakki', 'Laugarvatn', 'Laupstad', 'Leines', 'Leira', 'Leiren', 'Leland', 'Lenvika', 'Loding', 'Lodingen', 'Lonsbakki', 'Lopsmarka', 'Lovund', 'Luroy', 'Maela', 'Melahverfi', 'Meloy', 'Mevik', 'Misvaer', 'Mornes', 'Mosfellsbær', 'Moskenes', 'Myken', 'Naurstad', 'Nesberg', 'Nesjahverfi', 'Nesset', 'Nevernes', 'Obygda', 'Ofoten', 'Ogskardet', 'Okervika', 'Oknes', 'Olafsfjordur', 'Oldervika', 'Olstad', 'Onstad', 'Oppeid', 'Oresvika', 'Orsnes', 'Orsvog', 'Osmyra', 'Overdal', 'Prestoya', 'Raudalaekur', 'Raufarhofn', 'Reipo', 'Reykholar', 'Reykholt', 'Reykjahlid', 'Rif', 'Rinoya', 'Rodoy', 'Rognan', 'Rosvika', 'Rovika', 'Salhus', 'Sanden', 'Sandgerdi', 'Sandoker', 'Sandset', 'Sandvika', 'Saudarkrokur', 'Selfoss', 'Selsoya', 'Sennesvik', 'Setso', 'Siglufjordur', 'Silvalen', 'Skagastrond', 'Skjerstad', 'Skonland', 'Skorvogen', 'Skrova', 'Sleneset', 'Snubba', 'Softing', 'Solheim', 'Solheimar', 'Sorarnoy', 'Sorfugloy', 'Sorland', 'Sormela', 'Sorvaer', 'Sovika', 'Stamsund', 'Stamsvika', 'Stave', 'Stokka', 'Stokkseyri', 'Storjord', 'Storo', 'Storvika', 'Strand', 'Straumen', 'Strendene', 'Sudavik', 'Sudureyri', 'Sundoya', 'Sydalen', 'Thingeyri', 'Thorlakshofn', 'Thorshofn', 'Tjarnabyggd', 'Tjotta', 'Tosbotn', 'Traelnes', 'Trofors', 'Trones', 'Tverro', 'Ulvsvog', 'Unnstad', 'Utskor', 'Valla', 'Vandved', 'Varmahlid', 'Vassos', 'Vevelstad', 'Vidrek', 'Vik', 'Vikholmen', 'Vogar', 'Vogehamn', 'Vopnafjordur'],\n      ['Abdera', 'Abila', 'Abydos', 'Acanthus', 'Acharnae', 'Actium', 'Adramyttium', 'Aegae', 'Aegina', 'Aegium', 'Aenus', 'Agrinion', 'Aigosthena', 'Akragas', 'Akrai', 'Akrillai', 'Akroinon', 'Akrotiri', 'Alalia', 'Alexandreia', 'Alexandretta', 'Alexandria', 'Alinda', 'Amarynthos', 'Amaseia', 'Ambracia', 'Amida', 'Amisos', 'Amnisos', 'Amphicaea', 'Amphigeneia', 'Amphipolis', 'Amphissa', 'Ankon', 'Antigona', 'Antipatrea', 'Antioch', 'Antioch', 'Antiochia', 'Andros', 'Apamea', 'Aphidnae', 'Apollonia', 'Argos', 'Arsuf', 'Artanes', 'Artemita', 'Argyroupoli', 'Asine', 'Asklepios', 'Aspendos', 'Assus', 'Astacus', 'Athenai', 'Athmonia', 'Aytos', 'Ancient', 'Baris', 'Bhrytos', 'Borysthenes', 'Berge', 'Boura', 'Bouthroton', 'Brauron', 'Byblos', 'Byllis', 'Byzantium', 'Bythinion', 'Callipolis', 'Cebrene', 'Chalcedon', 'Calydon', 'Carystus', 'Chamaizi', 'Chalcis', 'Chersonesos', 'Chios', 'Chytri', 'Clazomenae', 'Cleonae', 'Cnidus', 'Colosse', 'Corcyra', 'Croton', 'Cyme', 'Cyrene', 'Cythera', 'Decelea', 'Delos', 'Delphi', 'Demetrias', 'Dicaearchia', 'Dimale', 'Didyma', 'Dion', 'Dioscurias', 'Dodona', 'Dorylaion', 'Dyme', 'Edessa', 'Elateia', 'Eleusis', 'Eleutherna', 'Emporion', 'Ephesus', 'Ephyra', 'Epidamnos', 'Epidauros', 'Eresos', 'Eretria', 'Erythrae', 'Eubea', 'Gangra', 'Gaza', 'Gela', 'Golgi', 'Gonnos', 'Gorgippia', 'Gournia', 'Gortyn', 'Gythium', 'Hagios', 'Hagia', 'Halicarnassus', 'Halieis', 'Helike', 'Heliopolis', 'Hellespontos', 'Helorus', 'Hemeroskopeion', 'Heraclea', 'Hermione', 'Hermonassa', 'Hierapetra', 'Hierapolis', 'Himera', 'Histria', 'Hubla', 'Hyele', 'Ialysos', 'Iasus', 'Idalium', 'Imbros', 'Iolcus', 'Itanos', 'Ithaca', 'Juktas', 'Kallipolis', 'Kamares', 'Kameiros', 'Kannia', 'Kamarina', 'Kasmenai', 'Katane', 'Kerkinitida', 'Kepoi', 'Kimmerikon', 'Kios', 'Klazomenai', 'Knidos', 'Knossos', 'Korinthos', 'Kos', 'Kourion', 'Kume', 'Kydonia', 'Kynos', 'Kyrenia', 'Lamia', 'Lampsacus', 'Laodicea', 'Lapithos', 'Larissa', 'Lato', 'Laus', 'Lebena', 'Lefkada', 'Lekhaion', 'Leibethra', 'Leontinoi', 'Lepreum', 'Lessa', 'Lilaea', 'Lindus', 'Lissus', 'Epizephyrian', 'Madytos', 'Magnesia', 'Mallia', 'Mantineia', 'Marathon', 'Marmara', 'Maroneia', 'Masis', 'Massalia', 'Megalopolis', 'Megara', 'Mesembria', 'Messene', 'Metapontum', 'Methana', 'Methone', 'Methumna', 'Miletos', 'Misenum', 'Mochlos', 'Monastiraki', 'Morgantina', 'Mulai', 'Mukenai', 'Mylasa', 'Myndus', 'Myonia', 'Myra', 'Myrmekion', 'Mutilene', 'Myos', 'Nauplios', 'Naucratis', 'Naupactus', 'Naxos', 'Neapoli', 'Neapolis', 'Nemea', 'Nicaea', 'Nicopolis', 'Nirou', 'Nymphaion', 'Nysa', 'Oenoe', 'Oenus', 'Odessos', 'Olbia', 'Olous', 'Olympia', 'Olynthus', 'Opus', 'Orchomenus', 'Oricos', 'Orestias', 'Oreus', 'Oropus', 'Onchesmos', 'Pactye', 'Pagasae', 'Palaikastro', 'Pandosia', 'Panticapaeum', 'Paphos', 'Parium', 'Paros', 'Parthenope', 'Patrae', 'Pavlopetri', 'Pegai', 'Pelion', 'Peiraieús', 'Pella', 'Percote', 'Pergamum', 'Petsofa', 'Phaistos', 'Phaleron', 'Phanagoria', 'Pharae', 'Pharnacia', 'Pharos', 'Phaselis', 'Philippi', 'Pithekussa', 'Philippopolis', 'Platanos', 'Phlius', 'Pherae', 'Phocaea', 'Pinara', 'Pisa', 'Pitane', 'Pitiunt', 'Pixous', 'Plataea', 'Poseidonia', 'Potidaea', 'Priapus', 'Priene', 'Prousa', 'Pseira', 'Psychro', 'Pteleum', 'Pydna', 'Pylos', 'Pyrgos', 'Rhamnus', 'Rhegion', 'Rhithymna', 'Rhodes', 'Rhypes', 'Rizinia', 'Salamis', 'Same', 'Samos', 'Scyllaeum', 'Selinus', 'Seleucia', 'Semasus', 'Sestos', 'Scidrus', 'Sicyon', 'Side', 'Sidon', 'Siteia', 'Sinope', 'Siris', 'Sklavokampos', 'Smyrna', 'Soli', 'Sozopolis', 'Sparta', 'Stagirus', 'Stratos', 'Stymphalos', 'Sybaris', 'Surakousai', 'Taras', 'Tanagra', 'Tanais', 'Tauromenion', 'Tegea', 'Temnos', 'Tenedos', 'Tenea', 'Teos', 'Thapsos', 'Thassos', 'Thebai', 'Theodosia', 'Therma', 'Thespiae', 'Thronion', 'Thoricus', 'Thurii', 'Thyreum', 'Thyria', 'Tiruns', 'Tithoraea', 'Tomis', 'Tragurion', 'Trapeze', 'Trapezus', 'Tripolis', 'Troizen', 'Troliton', 'Troy', 'Tylissos', 'Tyras', 'Tyros', 'Tyritake', 'Vasiliki', 'Vathypetros', 'Zakynthos', 'Zakros', 'Zankle'],\n      ['Abila', 'Adflexum', 'Adnicrem', 'Aelia', 'Aelius', 'Aeminium', 'Aequum', 'Agrippina', 'Agrippinae', 'Ala', 'Albanianis', 'Ambianum', 'Andautonia', 'Apulum', 'Aquae', 'Aquaegranni', 'Aquensis', 'Aquileia', 'Aquincum', 'Arae', 'Argentoratum', 'Ariminum', 'Ascrivium', 'Atrebatum', 'Atuatuca', 'Augusta', 'Aurelia', 'Aurelianorum', 'Batavar', 'Batavorum', 'Belum', 'Biriciana', 'Blestium', 'Bonames', 'Bonna', 'Bononia', 'Borbetomagus', 'Bovium', 'Bracara', 'Brigantium', 'Burgodunum', 'Caesaraugusta', 'Caesarea', 'Caesaromagus', 'Calleva', 'Camulodunum', 'Cannstatt', 'Cantiacorum', 'Capitolina', 'Castellum', 'Castra', 'Castrum', 'Cibalae', 'Clausentum', 'Colonia', 'Concangis', 'Condate', 'Confluentes', 'Conimbriga', 'Corduba', 'Coria', 'Corieltauvorum', 'Corinium', 'Coriovallum', 'Cornoviorum', 'Danum', 'Deva', 'Divodurum', 'Dobunnorum', 'Drusi', 'Dubris', 'Dumnoniorum', 'Durnovaria', 'Durocobrivis', 'Durocornovium', 'Duroliponte', 'Durovernum', 'Durovigutum', 'Eboracum', 'Edetanorum', 'Emerita', 'Emona', 'Euracini', 'Faventia', 'Flaviae', 'Florentia', 'Forum', 'Gerulata', 'Gerunda', 'Glevensium', 'Hadriani', 'Herculanea', 'Isca', 'Italica', 'Iulia', 'Iuliobrigensium', 'Iuvavum', 'Lactodurum', 'Lagentium', 'Lauri', 'Legionis', 'Lemanis', 'Lentia', 'Lepidi', 'Letocetum', 'Lindinis', 'Lindum', 'Londinium', 'Lopodunum', 'Lousonna', 'Lucus', 'Lugdunum', 'Luguvalium', 'Lutetia', 'Mancunium', 'Marsonia', 'Martius', 'Massa', 'Matilo', 'Mattiacorum', 'Mediolanum', 'Mod', 'Mogontiacum', 'Moridunum', 'Mursa', 'Naissus', 'Nervia', 'Nida', 'Nigrum', 'Novaesium', 'Noviomagus', 'Olicana', 'Ovilava', 'Parisiorum', 'Partiscum', 'Paterna', 'Pistoria', 'Placentia', 'Pollentia', 'Pomaria', 'Pons', 'Portus', 'Praetoria', 'Praetorium', 'Pullum', 'Ragusium', 'Ratae', 'Raurica', 'Regina', 'Regium', 'Regulbium', 'Rigomagus', 'Roma', 'Romula', 'Rutupiae', 'Salassorum', 'Salernum', 'Salona', 'Scalabis', 'Segovia', 'Silurum', 'Sirmium', 'Siscia', 'Sorviodurum', 'Sumelocenna', 'Tarraco', 'Taurinorum', 'Theranda', 'Traiectum', 'Treverorum', 'Tungrorum', 'Turicum', 'Ulpia', 'Valentia', 'Venetiae', 'Venta', 'Verulamium', 'Vesontio', 'Vetera', 'Victoriae', 'Victrix', 'Villa', 'Viminacium', 'Vindelicorum', 'Vindobona', 'Vinovia', 'Viroconium'],\n      ['Aanekoski', 'Abjapaluoja', 'Ahlainen', 'Aholanvaara', 'Ahtari', 'Aijala', 'Aimala', 'Akaa', 'Alajarvi', 'Alatornio', 'Alavus', 'Antsla', 'Aspo', 'Bennas', 'Bjorkoby', 'Elva', 'Emasalo', 'Espoo', 'Esse', 'Evitskog', 'Forssa', 'Haapajarvi', 'Haapamaki', 'Haapavesi', 'Haapsalu', 'Haavisto', 'Hameenlinna', 'Hameenmaki', 'Hamina', 'Hanko', 'Harjavalta', 'Hattuvaara', 'Haukipudas', 'Hautajarvi', 'Havumaki', 'Heinola', 'Hetta', 'Hinkabole', 'Hirmula', 'Hossa', 'Huittinen', 'Husula', 'Hyryla', 'Hyvinkaa', 'Iisalmi', 'Ikaalinen', 'Ilmola', 'Imatra', 'Inari', 'Iskmo', 'Itakoski', 'Jamsa', 'Jarvenpaa', 'Jeppo', 'Jioesuu', 'Jiogeva', 'Joensuu', 'Jokela', 'Jokikyla', 'Jokisuu', 'Jormua', 'Juankoski', 'Jungsund', 'Jyvaskyla', 'Kaamasmukka', 'Kaarina', 'Kajaani', 'Kalajoki', 'Kallaste', 'Kankaanpaa', 'Kannus', 'Kardla', 'Karesuvanto', 'Karigasniemi', 'Karkkila', 'Karkku', 'Karksinuia', 'Karpankyla', 'Kaskinen', 'Kasnas', 'Kauhajoki', 'Kauhava', 'Kauniainen', 'Kauvatsa', 'Kehra', 'Keila', 'Kellokoski', 'Kelottijarvi', 'Kemi', 'Kemijarvi', 'Kerava', 'Keuruu', 'Kiikka', 'Kiipu', 'Kilinginiomme', 'Kiljava', 'Kilpisjarvi', 'Kitee', 'Kiuruvesi', 'Kivesjarvi', 'Kiviioli', 'Kivisuo', 'Klaukkala', 'Klovskog', 'Kohtlajarve', 'Kokemaki', 'Kokkola', 'Kolho', 'Koria', 'Koskue', 'Kotka', 'Kouva', 'Kouvola', 'Kristiina', 'Kaupunki', 'Kuhmo', 'Kunda', 'Kuopio', 'Kuressaare', 'Kurikka', 'Kusans', 'Kuusamo', 'Kylmalankyla', 'Lahti', 'Laitila', 'Lankipohja', 'Lansikyla', 'Lappeenranta', 'Lapua', 'Laurila', 'Lautiosaari', 'Lepsama', 'Liedakkala', 'Lieksa', 'Lihula', 'Littoinen', 'Lohja', 'Loimaa', 'Loksa', 'Loviisa', 'Luohuanylipaa', 'Lusi', 'Maardu', 'Maarianhamina', 'Malmi', 'Mantta', 'Masaby', 'Masala', 'Matasvaara', 'Maula', 'Miiluranta', 'Mikkeli', 'Mioisakula', 'Munapirtti', 'Mustvee', 'Muurahainen', 'Naantali', 'Nappa', 'Narpio', 'Nickby', 'Niinimaa', 'Niinisalo', 'Nikkila', 'Nilsia', 'Nivala', 'Nokia', 'Nummela', 'Nuorgam', 'Nurmes', 'Nuvvus', 'Obbnas', 'Oitti', 'Ojakkala', 'Ollola', 'onningeby', 'Orimattila', 'Orivesi', 'Otanmaki', 'Otava', 'Otepaa', 'Oulainen', 'Oulu', 'Outokumpu', 'Paavola', 'Paide', 'Paimio', 'Pakankyla', 'Paldiski', 'Parainen', 'Parkano', 'Parkumaki', 'Parola', 'Perttula', 'Pieksamaki', 'Pietarsaari', 'Pioltsamaa', 'Piolva', 'Pohjavaara', 'Porhola', 'Pori', 'Porrasa', 'Porvoo', 'Pudasjarvi', 'Purmo', 'Pussi', 'Pyhajarvi', 'Raahe', 'Raasepori', 'Raisio', 'Rajamaki', 'Rakvere', 'Rapina', 'Rapla', 'Rauma', 'Rautio', 'Reposaari', 'Riihimaki', 'Rovaniemi', 'Roykka', 'Ruonala', 'Ruottala', 'Rutalahti', 'Saarijarvi', 'Salo', 'Sastamala', 'Saue', 'Savonlinna', 'Seinajoki', 'Sillamae', 'Sindi', 'Siuntio', 'Somero', 'Sompujarvi', 'Suonenjoki', 'Suurejaani', 'Syrjantaka', 'Tampere', 'Tamsalu', 'Tapa', 'Temmes', 'Tiorva', 'Tormasenvaara', 'Tornio', 'Tottijarvi', 'Tulppio', 'Turenki', 'Turi', 'Tuukkala', 'Tuurala', 'Tuuri', 'Tuuski', 'Ulvila', 'Unari', 'Upinniemi', 'Utti', 'Uusikaarlepyy', 'Uusikaupunki', 'Vaaksy', 'Vaalimaa', 'Vaarinmaja', 'Vaasa', 'Vainikkala', 'Valga', 'Valkeakoski', 'Vantaa', 'Varkaus', 'Vehkapera', 'Vehmasmaki', 'Vieki', 'Vierumaki', 'Viitasaari', 'Viljandi', 'Vilppula', 'Viohma', 'Vioru', 'Virrat', 'Ylike', 'Ylivieska', 'Ylojarvi'],\n      ['Sabi', 'Wiryeseong', 'Hwando', 'Gungnae', 'Ungjin', 'Wanggeomseong', 'Ganggyeong', 'Jochiwon', 'Cheorwon', 'Beolgyo', 'Gangjin', 'Gampo', 'Yecheon', 'Geochang', 'Janghang', 'Hadong', 'Goseong', 'Yeongdong', 'Yesan', 'Sintaein', 'Geumsan', 'Boseong', 'Jangheung', 'Uiseong', 'Jumunjin', 'Janghowon', 'Hongseong', 'Gimhwa', 'Gwangcheon', 'Guryongpo', 'Jinyeong', 'Buan', 'Damyang', 'Jangseong', 'Wando', 'Angang', 'Okcheon', 'Jeungpyeong', 'Waegwan', 'Cheongdo', 'Gwangyang', 'Gochang', 'Haenam', 'Yeonggwang', 'Hanam', 'Eumseong', 'Daejeong', 'Hanrim', 'Samrye', 'Yongjin', 'Hamyang', 'Buyeo', 'Changnyeong', 'Yeongwol', 'Yeonmu', 'Gurye', 'Hwasun', 'Hampyeong', 'Namji', 'Samnangjin', 'Dogye', 'Hongcheon', 'Munsan', 'Gapyeong', 'Ganghwa', 'Geojin', 'Sangdong', 'Jeongseon', 'Sabuk', 'Seonghwan', 'Heunghae', 'Hapdeok', 'Sapgyo', 'Taean', 'Boeun', 'Geumwang', 'Jincheon', 'Bongdong', 'Doyang', 'Geoncheon', 'Pungsan', 'Punggi', 'Geumho', 'Wonju', 'Gaun', 'Hayang', 'Yeoju', 'Paengseong', 'Yeoncheon', 'Yangpyeong', 'Ganseong', 'Yanggu', 'Yangyang', 'Inje', 'Galmal', 'Pyeongchang', 'Hwacheon', 'Hoengseong', 'Seocheon', 'Cheongyang', 'Goesan', 'Danyang', 'Hamyeol', 'Muju', 'Sunchang', 'Imsil', 'Jangsu', 'Jinan', 'Goheung', 'Gokseong', 'Muan', 'Yeongam', 'Jindo', 'Seonsan', 'Daegaya', 'Gunwi', 'Bonghwa', 'Seongju', 'Yeongdeok', 'Yeongyang', 'Ulleung', 'Uljin', 'Cheongsong', 'wayang', 'Namhae', 'Sancheong', 'Uiryeong', 'Gaya', 'Hapcheon', 'Wabu', 'Dongsong', 'Sindong', 'Wondeok', 'Maepo', 'Anmyeon', 'Okgu', 'Sariwon', 'Dolsan', 'Daedeok', 'Gwansan', 'Geumil', 'Nohwa', 'Baeksu', 'Illo', 'Jido', 'Oedong', 'Ocheon', 'Yeonil', 'Hamchang', 'Pyeonghae', 'Gijang', 'Jeonggwan', 'Aewor', 'Gujwa', 'Seongsan', 'Jeongok', 'Seonggeo', 'Seungju', 'Hongnong', 'Jangan', 'Jocheon', 'Gohan', 'Jinjeop', 'Bubal', 'Beobwon', 'Yeomchi', 'Hwado', 'Daesan', 'Hwawon', 'Apo', 'Nampyeong', 'Munsan', 'Sinbuk', 'Munmak', 'Judeok', 'Bongyang', 'Ungcheon', 'Yugu', 'Unbong', 'Mangyeong', 'Dong', 'Naeseo', 'Sanyang', 'Soheul', 'Onsan', 'Eonyang', 'Nongong', 'Dasa', 'Goa', 'Jillyang', 'Bongdam', 'Naesu', 'Beomseo', 'Opo', 'Gongdo', 'Jingeon', 'Onam', 'Baekseok', 'Jiksan', 'Mokcheon', 'Jori', 'Anjung', 'Samho', 'Ujeong', 'Buksam', 'Tongjin', 'Chowol', 'Gonjiam', 'Pogok', 'Seokjeok', 'Poseung', 'Ochang', 'Hyangnam', 'Baebang', 'Gochon', 'Songak', 'Samhyang', 'Yangchon', 'Osong', 'Aphae', 'Ganam', 'Namyang', 'Chirwon', 'Andong', 'Ansan', 'Anseong', 'Anyang', 'Asan', 'Boryeong', 'Bucheon', 'Busan', 'Changwon', 'Cheonan', 'Cheongju', 'Chuncheon', 'Chungju', 'Daegu', 'Daejeon', 'Dangjin', 'Dongducheon', 'Donghae', 'Gangneung', 'Geoje', 'Gimcheon', 'Gimhae', 'Gimje', 'Gimpo', 'Gongju', 'Goyang', 'Gumi', 'Gunpo', 'Gunsan', 'Guri', 'Gwacheon', 'Gwangju', 'Gwangju', 'Gwangmyeong', 'Gyeongju', 'Gyeongsan', 'Gyeryong', 'Hwaseong', 'Icheon', 'Iksan', 'Incheon', 'Jecheon', 'Jeongeup', 'Jeonju', 'Jeju', 'Jinju', 'Naju', 'Namyangju', 'Namwon', 'Nonsan', 'Miryang', 'Mokpo', 'Mungyeong', 'Osan', 'Paju', 'Pocheon', 'Pohang', 'Pyeongtaek', 'Sacheon', 'Sangju', 'Samcheok', 'Sejong', 'Seogwipo', 'Seongnam', 'Seosan', 'Seoul', 'Siheung', 'Sokcho', 'Suncheon', 'Suwon', 'Taebaek', 'Tongyeong', 'Uijeongbu', 'Uiwang', 'Ulsan', 'Yangju', 'Yangsan', 'Yeongcheon', 'Yeongju', 'Yeosu', 'Yongin', 'Chungmu', 'Daecheon', 'Donggwangyang', 'Geumseong', 'Gyeongseong', 'Iri', 'Jangseungpo', 'Jeomchon', 'Jeongju', 'Migeum', 'Onyang', 'Samcheonpo', 'Busan', 'Busan', 'Cheongju', 'Chuncheon', 'Daegu', 'Daegu', 'Daejeon', 'Daejeon', 'Gunsan', 'Gwangju', 'Gwangju', 'Gyeongseong', 'Incheon', 'Incheon', 'Iri', 'Jeonju', 'Jinhae', 'Jinju', 'Masan', 'Masan', 'Mokpo', 'Songjeong', 'Songtan', 'Ulsan', 'Yeocheon', 'Cheongjin', 'Gaeseong', 'Haeju', 'Hamheung', 'Heungnam', 'Jinnampo', 'Najin', 'Pyeongyang', 'Seongjin', 'Sineuiju', 'Songnim', 'Wonsan'],\n      ['Anding', 'Anlu', 'Anqing', 'Anshun', 'Baan', 'Baixing', 'Banyang', 'Baoding', 'Baoqing', 'Binzhou', 'Caozhou', 'Changbai', 'Changchun', 'Changde', 'Changling', 'Changsha', 'Changtu', 'Changzhou', 'Chaozhou', 'Cheli', 'Chengde', 'Chengdu', 'Chenzhou', 'Chizhou', 'Chongqing', 'Chuxiong', 'Chuzhou', 'Dading', 'Dali', 'Daming', 'Datong', 'Daxing', 'Dean', 'Dengke', 'Dengzhou', 'Deqing', 'Dexing', 'Dihua', 'Dingli', 'Dongan', 'Dongchang', 'Dongchuan', 'Dongping', 'Duyun', 'Fengtian', 'Fengxiang', 'Fengyang', 'Fenzhou', 'Funing', 'Fuzhou', 'Ganzhou', 'Gaoyao', 'Gaozhou', 'Gongchang', 'Guangnan', 'Guangning', 'Guangping', 'Guangxin', 'Guangzhou', 'Guide', 'Guilin', 'Guiyang', 'Hailong', 'Hailun', 'Hangzhou', 'Hanyang', 'Hanzhong', 'Heihe', 'Hejian', 'Henan', 'Hengzhou', 'Hezhong', 'Huaian', 'Huaide', 'Huaiqing', 'Huanglong', 'Huangzhou', 'Huining', 'Huizhou', 'Hulan', 'Huzhou', 'Jiading', 'Jian', 'Jianchang', 'Jiande', 'Jiangning', 'Jiankang', 'Jianning', 'Jiaxing', 'Jiayang', 'Jilin', 'Jinan', 'Jingjiang', 'Jingzhao', 'Jingzhou', 'Jinhua', 'Jinzhou', 'Jiujiang', 'Kaifeng', 'Kaihua', 'Kangding', 'Kuizhou', 'Laizhou', 'Lanzhou', 'Leizhou', 'Liangzhou', 'Lianzhou', 'Liaoyang', 'Lijiang', 'Linan', 'Linhuang', 'Linjiang', 'Lintao', 'Liping', 'Liuzhou', 'Longan', 'Longjiang', 'Longqing', 'Longxing', 'Luan', 'Lubin', 'Lubin', 'Luzhou', 'Mishan', 'Nanan', 'Nanchang', 'Nandian', 'Nankang', 'Nanning', 'Nanyang', 'Nenjiang', 'Ningan', 'Ningbo', 'Ningguo', 'Ninguo', 'Ningwu', 'Ningxia', 'Ningyuan', 'Pingjiang', 'Pingle', 'Pingliang', 'Pingyang', 'Puer', 'Puzhou', 'Qianzhou', 'Qingyang', 'Qingyuan', 'Qingzhou', 'Qiongzhou', 'Qujing', 'Quzhou', 'Raozhou', 'Rende', 'Ruian', 'Ruizhou', 'Runing', 'Shafeng', 'Shajing', 'Shaoqing', 'Shaowu', 'Shaoxing', 'Shaozhou', 'Shinan', 'Shiqian', 'Shouchun', 'Shuangcheng', 'Shulei', 'Shunde', 'Shunqing', 'Shuntian', 'Shuoping', 'Sicheng', 'Sien', 'Sinan', 'Sizhou', 'Songjiang', 'Suiding', 'Suihua', 'Suining', 'Suzhou', 'Taian', 'Taibei', 'Tainan', 'Taiping', 'Taiwan', 'Taiyuan', 'Taizhou', 'Taonan', 'Tengchong', 'Tieli', 'Tingzhou', 'Tongchuan', 'Tongqing', 'Tongren', 'Tongzhou', 'Weihui', 'Wensu', 'Wenzhou', 'Wuchang', 'Wuding', 'Wuzhou', 'Xian', 'Xianchun', 'Xianping', 'Xijin', 'Xiliang', 'Xincheng', 'Xingan', 'Xingde', 'Xinghua', 'Xingjing', 'Xingqing', 'Xingyi', 'Xingyuan', 'Xingzhong', 'Xining', 'Xinmen', 'Xiping', 'Xuanhua', 'Xunzhou', 'Xuzhou', 'Yanan', 'Yangzhou', 'Yanji', 'Yanping', 'Yanqi', 'Yanzhou', 'Yazhou', 'Yichang', 'Yidu', 'Yilan', 'Yili', 'Yingchang', 'Yingde', 'Yingtian', 'Yingzhou', 'Yizhou', 'Yongchang', 'Yongping', 'Yongshun', 'Yongzhou', 'Yuanzhou', 'Yuezhou', 'Yulin', 'Yunnan', 'Yunyang', 'Zezhou', 'Zhangde', 'Zhangzhou', 'Zhaoqing', 'Zhaotong', 'Zhenan', 'Zhending', 'Zhengding', 'Zhenhai', 'Zhenjiang', 'Zhenxi', 'Zhenyun', 'Zhongshan', 'Zunyi'],\n      ['Nanporo', 'Naie', 'Kamisunagawa', 'Yuni', 'Naganuma', 'Kuriyama', 'Tsukigata', 'Urausu', 'Shintotsukawa', 'Moseushi', 'Chippubetsu', 'Uryu', 'Hokuryu', 'Numata', 'Tobetsu', 'Suttsu', 'Kuromatsunai', 'Rankoshi', 'Niseko', 'Kimobetsu', 'Kyogoku', 'Kutchan', 'Kyowa', 'Iwanai', 'Shakotan', 'Furubira', 'Niki', 'Yoichi', 'Toyoura', 'Toyako', 'Sobetsu', 'Shiraoi', 'Atsuma', 'Abira', 'Mukawa', 'Hidaka', 'Biratori', 'Niikappu', 'Urakawa', 'Samani', 'Erimo', 'Shinhidaka', 'Matsumae', 'Fukushima', 'Shiriuchi', 'Kikonai', 'Nanae', 'Shikabe', 'Mori', 'Yakumo', 'Oshamambe', 'Esashi', 'Kaminokuni', 'Assabu', 'Otobe', 'Okushiri', 'Imakane', 'Setana', 'Takasu', 'Higashikagura', 'Toma', 'Pippu', 'Aibetsu', 'Kamikawa', 'Higashikawa', 'Biei', 'Kamifurano', 'Nakafurano', 'Minamifurano', 'Horokanai', 'Wassamu', 'Kenbuchi', 'Shimokawa', 'Bifuka', 'Nakagawa', 'Mashike', 'Obira', 'Tomamae', 'Haboro', 'Enbetsu', 'Teshio', 'Hamatonbetsu', 'Nakatonbetsu', 'Esashi', 'Toyotomi', 'Horonobe', 'Rebun', 'Rishiri', 'Rishirifuji', 'Bihoro', 'Tsubetsu', 'Ozora', 'Shari', 'Kiyosato', 'Koshimizu', 'Kunneppu', 'Oketo', 'Saroma', 'Engaru', 'Yubetsu', 'Takinoue', 'Okoppe', 'Omu', 'Otofuke', 'Shihoro', 'Kamishihoro', 'Shikaoi', 'Shintoku', 'Shimizu', 'Memuro', 'Taiki', 'Hiroo', 'Makubetsu', 'Ikeda', 'Toyokoro', 'Honbetsu', 'Ashoro', 'Rikubetsu', 'Urahoro', 'Kushiro', 'Akkeshi', 'Hamanaka', 'Shibecha', 'Teshikaga', 'Shiranuka', 'Betsukai', 'Nakashibetsu', 'Shibetsu', 'Rausu', 'Hiranai', 'Imabetsu', 'Sotogahama', 'Ajigasawa', 'Fukaura', 'Fujisaki', 'Owani', 'Itayanagi', 'Tsuruta', 'Nakadomari', 'Noheji', 'Shichinohe', 'Rokunohe', 'Yokohama', 'Tohoku', 'Oirase', 'Oma', 'Sannohe', 'Gonohe', 'Takko', 'Nanbu', 'Hashikami', 'Shizukuishi', 'Kuzumaki', 'Iwate', 'Shiwa', 'Yahaba', 'Nishiwaga', 'Kanegasaki', 'Hiraizumi', 'Sumita', 'Otsuchi', 'Yamada', 'Iwaizumi', 'Karumai', 'Hirono', 'Ichinohe', 'Zao', 'Shichikashuku', 'Ogawara', 'Murata', 'Shibata', 'Kawasaki', 'Marumori', 'Watari', 'Yamamoto', 'Matsushima', 'Shichigahama', 'Rifu', 'Taiwa', 'Osato', 'Shikama', 'Kami', 'Wakuya', 'Misato', 'Onagawa', 'Minamisanriku', 'Kosaka', 'Fujisato', 'Mitane', 'Happo', 'Gojome', 'Hachirogata', 'Ikawa', 'Misato', 'Ugo', 'Yamanobe', 'Nakayama', 'Kahoku', 'Nishikawa', 'Asahi', 'Oe', 'Oishida', 'Kaneyama', 'Mogami', 'Funagata', 'Mamurogawa', 'Takahata', 'Kawanishi', 'Oguni', 'Shirataka', 'Iide', 'Mikawa', 'Shonai', 'Yuza', 'Koori', 'Kunimi', 'Kawamata', 'Kagamiishi', 'Shimogo', 'Tadami', 'Minamiaizu', 'Nishiaizu', 'Bandai', 'Inawashiro', 'Aizubange', 'Yanaizu', 'Mishima', 'Kaneyama', 'Aizumisato', 'Yabuki', 'Tanagura', 'Yamatsuri', 'Hanawa', 'Ishikawa', 'Asakawa', 'Furudono', 'Miharu', 'Ono', 'Hirono', 'Naraha', 'Tomioka', 'Okuma', 'Futaba', 'Namie', 'Shinchi', 'Ibaraki', 'Oarai', 'Shirosato', 'Daigo', 'Ami', 'Kawachi', 'Yachiyo', 'Goka', 'Sakai', 'Tone', 'Kaminokawa', 'Mashiko', 'Motegi', 'Ichikai', 'Haga', 'Mibu', 'Nogi', 'Shioya', 'Takanezawa', 'Nasu', 'Nakagawa', 'Yoshioka', 'Kanna', 'Shimonita', 'Kanra', 'Nakanojo', 'Naganohara', 'Kusatsu', 'Higashiagatsuma', 'Minakami', 'Tamamura', 'Itakura', 'Meiwa', 'Chiyoda', 'Oizumi', 'Ora', 'Ina', 'Miyoshi', 'Moroyama', 'Ogose', 'Namegawa', 'Ranzan', 'Ogawa', 'Kawajima', 'Yoshimi', 'Hatoyama', 'Tokigawa', 'Yokoze', 'Minano', 'Nagatoro', 'Ogano', 'Misato', 'Kamikawa', 'Kamisato', 'Yorii', 'Miyashiro', 'Sugito', 'Matsubushi', 'Shisui', 'Sakae', 'Kozaki', 'Tako', 'Tonosho', 'Kujukuri', 'Shibayama', 'Yokoshibahikari', 'Ichinomiya', 'Mutsuzawa', 'Shirako', 'Nagara', 'Chonan', 'Otaki', 'Onjuku', 'Kyonan', 'Mizuho', 'Hinode', 'Okutama', 'Oshima', 'Hachijo', 'Aikawa', 'Hayama', 'Samukawa', 'Oiso', 'Ninomiya', 'Nakai', 'Oi', 'Matsuda', 'Yamakita', 'Kaisei', 'Hakone', 'Manazuru', 'Yugawara', 'Seiro', 'Tagami', 'Aga', 'Izumozaki', 'Yuzawa', 'Tsunan', 'Kamiichi', 'Tateyama', 'Nyuzen', 'Asahi', 'Kawakita', 'Tsubata', 'Uchinada', 'Shika', 'Hodatsushimizu', 'Nakanoto', 'Anamizu', 'Noto', 'Eiheiji', 'Ikeda', 'Minamiechizen', 'Echizen', 'Mihama', 'Takahama', 'Oi', 'Wakasa', 'Ichikawamisato', 'Hayakawa', 'Minobu', 'Nanbu', 'Fujikawa', 'Showa', 'Nishikatsura', 'Fujikawaguchiko', 'Koumi', 'Sakuho', 'Karuizawa', 'Miyota', 'Tateshina', 'Nagawa', 'Shimosuwa', 'Fujimi', 'Tatsuno', 'Minowa', 'Iijima', 'Matsukawa', 'Takamori', 'Anan', 'Agematsu', 'Nagiso', 'Kiso', 'Ikeda', 'Sakaki', 'Obuse', 'Yamanouchi', 'Shinano', 'Iizuna', 'Ginan', 'Kasamatsu', 'Yoro', 'Tarui', 'Sekigahara', 'Godo', 'Wanouchi', 'Anpachi', 'Ibigawa', 'Ono', 'Ikeda', 'Kitagata', 'Sakahogi', 'Tomika', 'Kawabe', 'Hichiso', 'Yaotsu', 'Shirakawa', 'Mitake', 'Higashiizu', 'Kawazu', 'Minamiizu', 'Matsuzaki', 'Nishiizu', 'Kannami', 'Shimizu', 'Nagaizumi', 'Oyama', 'Yoshida', 'Kawanehon', 'Mori', 'Togo', 'Toyoyama', 'Oguchi', 'Fuso', 'Oharu', 'Kanie', 'Agui', 'Higashiura', 'Minamichita', 'Mihama', 'Taketoyo', 'Mihama', 'Kota', 'Shitara', 'Toei', 'Kisosaki', 'Toin', 'Komono', 'Asahi', 'Kawagoe', 'Taki', 'Meiwa', 'Odai', 'Tamaki', 'Watarai', 'Taiki', 'Minamiise', 'Kihoku', 'Mihama', 'Kiho', 'Hino', 'Ryuo', 'Aisho', 'Toyosato', 'Kora', 'Taga', 'Oyamazaki', 'Kumiyama', 'Ide', 'Ujitawara', 'Kasagi', 'Wazuka', 'Seika', 'Kyotamba', 'Ine', 'Yosano', 'Shimamoto', 'Toyono', 'Nose', 'Tadaoka', 'Kumatori', 'Tajiri', 'Misaki', 'Taishi', 'Kanan', 'Inagawa', 'Taka', 'Inami', 'Harima', 'Ichikawa', 'Fukusaki', 'Kamikawa', 'Taishi', 'Kamigori', 'Sayo', 'Kami', 'Shinonsen', 'Heguri', 'Sango', 'Ikaruga', 'Ando', 'Kawanishi', 'Miyake', 'Tawaramoto', 'Takatori', 'Kanmaki', 'Oji', 'Koryo', 'Kawai', 'Yoshino', 'Oyodo', 'Shimoichi', 'Kushimoto', 'Kimino', 'Katsuragi', 'Kudoyama', 'Koya', 'Yuasa', 'Hirogawa', 'Aridagawa', 'Mihama', 'Hidaka', 'Yura', 'Inami', 'Minabe', 'Hidakagawa', 'Shirahama', 'Kamitonda', 'Susami', 'Nachikatsuura', 'Taiji', 'Kozagawa', 'Iwami', 'Wakasa', 'Chizu', 'Yazu', 'Misasa', 'Yurihama', 'Kotoura', 'Hokuei', 'Daisen', 'Nanbu', 'Hoki', 'Nichinan', 'Hino', 'Kofu', 'Okuizumo', 'Iinan', 'Kawamoto', 'Misato', 'Onan', 'Tsuwano', 'Yoshika', 'Ama', 'Nishinoshima', 'Okinoshima', 'Wake', 'Hayashima', 'Satosho', 'Yakage', 'Kagamino', 'Shoo', 'Nagi', 'Kumenan', 'Misaki', 'Kibichuo', 'Fuchu', 'Kaita', 'Kumano', 'Saka', 'Kitahiroshima', 'Akiota', 'Osakikamijima', 'Sera', 'Jinsekikogen', 'Suooshima', 'Waki', 'Kaminoseki', 'Tabuse', 'Hirao', 'Abu', 'Katsuura', 'Kamikatsu', 'Ishii', 'Kamiyama', 'Naka', 'Mugi', 'Minami', 'Kaiyo', 'Matsushige', 'Kitajima', 'Aizumi', 'Itano', 'Kamiita', 'Tsurugi', 'Higashimiyoshi', 'Tonosho', 'Shodoshima', 'Miki', 'Naoshima', 'Utazu', 'Ayagawa', 'Kotohira', 'Tadotsu', 'Manno', 'Kamijima', 'Kumakogen', 'Masaki', 'Tobe', 'Uchiko', 'Ikata', 'Kihoku', 'Matsuno', 'Ainan', 'Toyo', 'Nahari', 'Tano', 'Yasuda', 'Motoyama', 'Otoyo', 'Tosa', 'Ino', 'Niyodogawa', 'Nakatosa', 'Sakawa', 'Ochi', 'Yusuhara', 'Tsuno', 'Shimanto', 'Otsuki', 'Kuroshio', 'Nakagawa', 'Umi', 'Sasaguri', 'Shime', 'Sue', 'Shingu', 'Hisayama', 'Kasuya', 'Ashiya', 'Mizumaki', 'Okagaki', 'Onga', 'Kotake', 'Kurate', 'Keisen', 'Chikuzen', 'Tachiarai', 'Oki', 'Hirokawa', 'Kawara', 'Soeda', 'Itoda', 'Kawasaki', 'Oto', 'Fukuchi', 'Kanda', 'Miyako', 'Yoshitomi', 'Koge', 'Chikujo', 'Yoshinogari', 'Kiyama', 'Kamimine', 'Miyaki', 'Genkai', 'Arita', 'Omachi', 'Kohoku', 'Shiroishi', 'Tara', 'Nagayo', 'Togitsu', 'Higashisonogi', 'Kawatana', 'Hasami', 'Ojika', 'Saza', 'Shinkamigoto', 'Misato', 'Gyokuto', 'Nankan', 'Nagasu', 'Nagomi', 'Ozu', 'Kikuyo', 'Minamioguni', 'Oguni', 'Takamori', 'Mifune', 'Kashima', 'Mashiki', 'Kosa', 'Yamato', 'Hikawa', 'Ashikita', 'Tsunagi', 'Nishiki', 'Taragi', 'Yunomae', 'Asagiri', 'Reihoku', 'Hiji', 'Kusu', 'Kokonoe', 'Mimata', 'Takaharu', 'Kunitomi', 'Aya', 'Takanabe', 'Shintomi', 'Kijo', 'Kawaminami', 'Tsuno', 'Kadogawa', 'Misato', 'Takachiho', 'Hinokage', 'Gokase', 'Satsuma', 'Nagashima', 'Yusui', 'Osaki', 'Higashikushira', 'Kinko', 'Minamiosumi', 'Kimotsuki', 'Nakatane', 'Minamitane', 'Yakushima', 'Setouchi', 'Tatsugo', 'Kikai', 'Tokunoshima', 'Amagi', 'Isen', 'Wadomari', 'China', 'Yoron', 'Motobu', 'Kin', 'Kadena', 'Chatan', 'Nishihara', 'Yonabaru', 'Haebaru', 'Kumejima', 'Yaese', 'Taketomi', 'Yonaguni']\n    ]\n  }\n\n  // randomize options if randomization is allowed in option\n  function randomizeOptions() {\n    const mod = _.round((graphWidth + graphHeight) / 1500, 2) // add mod for big screens\n    if (lockRegionsInput.getAttribute('data-locked') == 0) regionsInput.value =\n      regionsOutput.value = _.random(7, 17)\n    if (lockManorsInput.getAttribute('data-locked') == 0) {\n      const manors = regionsInput.value * 20 + _.random(180 * mod)\n      manorsInput.value = manorsOutput.innerHTML = manors\n    }\n    if (lockPowerInput.getAttribute('data-locked') == 0) powerInput.value =\n      powerOutput.value = _.random(2, 8)\n    if (lockNeutralInput.getAttribute('data-locked') == 0) neutralInput.value =\n      neutralOutput.value = _.random(100, 300)\n    if (lockNamesInput.getAttribute('data-locked') == 0) namesInput.value = _.random(0, 1)\n    if (lockCulturesInput.getAttribute('data-locked') == 0) culturesInput.value =\n      culturesOutput.value = _.random(5, 10)\n    if (lockPrecInput.getAttribute('data-locked') == 0) precInput.value =\n      precOutput.value = _.random(3, 12)\n    if (lockSwampinessInput.getAttribute('data-locked') == 0) swampinessInput.value =\n      swampinessOutput.value = _.random(100)\n  }\n\n  // Locate points to calculate Voronoi diagram\n  function placePoints() {\n    console.time('placePoints')\n    points = []\n    points = getJitteredGrid()\n    heights = new Uint8Array(points.length)\n    console.timeEnd('placePoints')\n  }\n\n  // Calculate Voronoi Diagram\n  function calculateVoronoi(points) {\n    console.time('calculateVoronoi')\n    diagram = voronoi(points)\n    // round edges to simplify future calculations\n    diagram.edges.forEach(function(e) {\n      e[0][0] = _.round(e[0][0], 2)\n      e[0][1] = _.round(e[0][1], 2)\n      e[1][0] = _.round(e[1][0], 2)\n      e[1][1] = _.round(e[1][1], 2)\n    })\n    polygons = diagram.polygons()\n    console.log(' cells: ' + points.length)\n    console.timeEnd('calculateVoronoi')\n  }\n\n  // move brush radius circle\n  function moveCircle(x, y, r, c) {\n    let circle = debug.selectAll('.circle')\n    if (!circle.size()) circle = debug.insert('circle', ':first-child').attr('class', 'circle')\n    circle.attr('cx', x).attr('cy', y)\n    if (r) circle.attr('r', r)\n    if (c) circle.attr('stroke', c)\n  }\n\n  // restore default drag (map panning) and cursor\n  function restoreDefaultEvents() {\n    viewbox.style('cursor', 'default').on('.drag', null).on('click', null)\n  }\n\n  // remove parent element (usually if child is clicked)\n  function removeParent() {\n    $(this.parentNode).remove()\n  }\n\n  // define selection based on radius\n  function defineBrushSelection(center, r) {\n    let radius = r\n    let selection = [center]\n    if (radius > 1) selection = selection.concat(cells[center].neighbors)\n    selection = $.grep(selection, function(e) {return cells[e].height >= 20})\n    if (radius === 2) return selection\n    let frontier = cells[center].neighbors\n    while (radius > 2) {\n      let cycle = frontier.slice()\n      frontier = []\n      cycle.map(function(s) {\n        cells[s].neighbors.forEach(function(e) {\n          if (selection.indexOf(e) !== -1) return\n          // if (cells[e].height < 20) return;\n          selection.push(e)\n          frontier.push(e)\n        })\n      })\n      radius--\n    }\n    selection = $.grep(selection, function(e) {return cells[e].height >= 20})\n    return selection\n  }\n\n  // Mouseclick events\n  function placeLinearFeature() {\n    const point = d3.mouse(this)\n    const index = getIndex(point)\n    let tag = debug.selectAll('.tag')\n    if (!tag.size()) {\n      tag = debug.append('circle').attr('data-cell', index).attr('class', 'tag')\n                 .attr('r', 3).attr('cx', point[0]).attr('cy', point[1])\n    } else {\n      const from = +tag.attr('data-cell')\n      debug.selectAll('.tag, .line').remove()\n      const power = +brushPower.value\n      const mod = $('#brushesButtons > .pressed').attr('id') === 'brushRange' ? 1 : -1\n      const selection = addRange(mod, power, from, index)\n      updateHeightmapSelection(selection)\n    }\n  }\n\n  // turn D3 polygons array into cell array, define neighbors for each cell\n  function detectNeighbors(withGrid) {\n    console.time('detectNeighbors')\n    let gridPath = '' // store grid as huge single path string\n    cells = []\n    polygons.map(function(i, d) {\n      const neighbors = []\n      let type // define cell type\n      if (withGrid) {gridPath += 'M' + i.join('L') + 'Z'} // grid path\n      diagram.cells[d].halfedges.forEach(function(e) {\n        const edge = diagram.edges[e]\n        if (edge.left && edge.right) {\n          const ea = edge.left.index === d ? edge.right.index : edge.left.index\n          neighbors.push(ea)\n        } else {\n          type = 'border' // polygon is on border if it has edge without opposite side polygon\n        }\n      })\n      cells.push({index: d, data: i.data, height: 0, type, neighbors})\n    })\n    if (withGrid) {grid.append('path').attr('d', round(gridPath, 1))}\n    console.timeEnd('detectNeighbors')\n  }\n\n  // Generate Heigtmap routine\n  function defineHeightmap() {\n    console.time('defineHeightmap')\n    if (lockTemplateInput.getAttribute('data-locked') == 0) {\n      const rnd = Math.random()\n      if (rnd > 0.95) {\n        templateInput.value = 'Volcano'\n      } else if (rnd > 0.75) {\n        templateInput.value = 'High Island'\n      } else if (rnd > 0.55) {\n        templateInput.value = 'Low Island'\n      } else if (rnd > 0.35) {\n        templateInput.value = 'Continents'\n      } else if (rnd > 0.15) {\n        templateInput.value = 'Archipelago'\n      } else if (rnd > 0.10) {\n        templateInput.value = 'Mainland'\n      } else if (rnd > 0.01) {templateInput.value = 'Peninsulas'} else {\n        templateInput.value = 'Atoll'\n      }\n    }\n    const mapTemplate = templateInput.value\n    if (mapTemplate === 'Volcano') templateVolcano()\n    if (mapTemplate === 'High Island') templateHighIsland()\n    if (mapTemplate === 'Low Island') templateLowIsland()\n    if (mapTemplate === 'Continents') templateContinents()\n    if (mapTemplate === 'Archipelago') templateArchipelago()\n    if (mapTemplate === 'Atoll') templateAtoll()\n    if (mapTemplate === 'Mainland') templateMainland()\n    if (mapTemplate === 'Peninsulas') templatePeninsulas()\n    console.log(' template: ' + mapTemplate)\n    console.timeEnd('defineHeightmap')\n  }\n\n  // Heighmap Template: Volcano\n  function templateVolcano(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(5, 0.35)\n    addRange(3)\n    addRange(-4)\n  }\n\n// Heighmap Template: High Island\n  function templateHighIsland(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addRange(6)\n    addHill(12, 0.25)\n    addRange(-3)\n    modifyHeights('land', 0, 0.75)\n    addPit(1)\n    addHill(3, 0.15)\n  }\n\n// Heighmap Template: Low Island\n  function templateLowIsland(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    smoothHeights(2)\n    addRange(2)\n    addHill(4, 0.4)\n    addHill(12, 0.2)\n    addRange(-8)\n    modifyHeights('land', 0, 0.35)\n  }\n\n  // Heighmap Template: Continents\n  function templateContinents(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(30, 0.25)\n    const count = Math.ceil(Math.random() * 4 + 4)\n    addStrait(count)\n    addPit(10)\n    addRange(-10)\n    modifyHeights('land', 0, 0.6)\n    smoothHeights(2)\n    addRange(3)\n  }\n\n  // Heighmap Template: Archipelago\n  function templateArchipelago(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(12, 0.15)\n    addRange(8)\n    const count = Math.ceil(Math.random() * 2 + 2)\n    addStrait(count)\n    addRange(-15)\n    addPit(10)\n    modifyHeights('land', -5, 0.7)\n    smoothHeights(3)\n  }\n\n  // Heighmap Template: Atoll\n  function templateAtoll(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(2, 0.35)\n    addRange(2)\n    smoothHeights(1)\n    modifyHeights('27-100', 0, 0.1)\n  }\n\n  // Heighmap Template: Mainland\n  function templateMainland(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(30, 0.2)\n    addRange(10)\n    addPit(20)\n    addHill(10, 0.15)\n    addRange(-10)\n    modifyHeights('land', 0, 0.4)\n    addRange(10)\n    smoothHeights(3)\n  }\n\n  // Heighmap Template: Peninsulas\n  function templatePeninsulas(mod) {\n    addMountain()\n    modifyHeights('all', 15, 1)\n    addHill(30, 0)\n    addRange(5)\n    addPit(15)\n    const count = Math.ceil(Math.random() * 5 + 15)\n    addStrait(count)\n  }\n\n  function addMountain() {\n    const x = Math.floor(Math.random() * graphWidth / 3 + graphWidth / 3)\n    const y = Math.floor(Math.random() * graphHeight * 0.2 + graphHeight * 0.4)\n    const cell = diagram.find(x, y).index\n    const height = Math.random() * 10 + 90 // 90-99\n    add(cell, 'mountain', height)\n  }\n\n  // place with shift 0-0.5\n  function addHill(count, shift) {\n    for (let c = 0; c < count; c++) {\n      let limit = 0, cell, height\n      do {\n        height = Math.random() * 40 + 10 // 10-50\n        const x = Math.floor(Math.random() * graphWidth * (1 - shift * 2) + graphWidth * shift)\n        const y = Math.floor(Math.random() * graphHeight * (1 - shift * 2) + graphHeight * shift)\n        cell = diagram.find(x, y).index\n        limit++\n      } while (heights[cell] + height > 90 && limit < 100)\n      add(cell, 'hill', height)\n    }\n  }\n\n  function add(start, type, height) {\n    const session = Math.ceil(Math.random() * 1e5)\n    let radius\n    let hRadius\n    let mRadius\n    switch (+graphSize) {\n      case 1:\n        hRadius = 0.991\n        mRadius = 0.91\n        break\n      case 2:\n        hRadius = 0.9967\n        mRadius = 0.951\n        break\n      case 3:\n        hRadius = 0.999\n        mRadius = 0.975\n        break\n      case 4:\n        hRadius = 0.9994\n        mRadius = 0.98\n        break\n    }\n    radius = type === 'mountain' ? mRadius : hRadius\n    const queue = [start]\n    if (type === 'mountain') heights[start] = height\n    for (let i = 0; i < queue.length && height >= 1; i++) {\n      if (type === 'mountain') {\n        height = heights[queue[i]] * radius - height / 100\n      } else {height *= radius}\n      cells[queue[i]].neighbors.forEach(function(e) {\n        if (cells[e].used === session) return\n        const mod = Math.random() * 0.2 + 0.9 // 0.9-1.1 random factor\n        heights[e] += height * mod\n        if (heights[e] > 100) heights[e] = 100\n        cells[e].used = session\n        queue.push(e)\n      })\n    }\n  }\n\n  function addRange(mod, height, from, to) {\n    const session = Math.ceil(Math.random() * 100000)\n    const count = Math.abs(mod)\n    let range = []\n    for (let c = 0; c < count; c++) {\n      range = []\n      let diff = 0, start = from, end = to\n      if (!start || !end) {\n        do {\n          const xf = Math.floor(Math.random() * (graphWidth * 0.7)) + graphWidth * 0.15\n          const yf = Math.floor(Math.random() * (graphHeight * 0.6)) + graphHeight * 0.2\n          start = diagram.find(xf, yf).index\n          const xt = Math.floor(Math.random() * (graphWidth * 0.7)) + graphWidth * 0.15\n          const yt = Math.floor(Math.random() * (graphHeight * 0.6)) + graphHeight * 0.2\n          end = diagram.find(xt, yt).index\n          diff = Math.hypot(xt - xf, yt - yf)\n        } while (diff < 150 / graphSize || diff > 300 / graphSize)\n      }\n      if (start && end) {\n        for (let l = 0; start != end && l < 10000; l++) {\n          let min = 10000\n          cells[start].neighbors.forEach(function(e) {\n            diff = Math.hypot(cells[end].data[0] - cells[e].data[0],\n              cells[end].data[1] - cells[e].data[1])\n            if (Math.random() > 0.8) diff = diff / 2\n            if (diff < min) {min = diff, start = e}\n          })\n          range.push(start)\n        }\n      }\n      const change = height ? height : Math.random() * 10 + 10\n      range.map(function(r) {\n        let rnd = Math.random() * 0.4 + 0.8\n        if (mod > 0) heights[r] += change * rnd\n        else if (heights[r] >= 10) {heights[r] -= change * rnd}\n        cells[r].neighbors.forEach(function(e) {\n          if (cells[e].used === session) return\n          cells[e].used = session\n          rnd = Math.random() * 0.4 + 0.8\n          const ch = change / 2 * rnd\n          if (mod > 0) {heights[e] += ch} else if (heights[e] >= 10) {heights[e] -= ch}\n          if (heights[e] > 100) heights[e] = mod > 0 ? 100 : 5\n        })\n        if (heights[r] > 100) heights[r] = mod > 0 ? 100 : 5\n      })\n    }\n    return range\n  }\n\n  function addStrait(width) {\n    const session = Math.ceil(Math.random() * 100000)\n    const top = Math.floor(Math.random() * graphWidth * 0.35 + graphWidth * 0.3)\n    const bottom = Math.floor(\n      (graphWidth - top) - (graphWidth * 0.1) + (Math.random() * graphWidth * 0.2))\n    let start = diagram.find(top, graphHeight * 0.1).index\n    const end = diagram.find(bottom, graphHeight * 0.9).index\n    let range = []\n    for (let l = 0; start !== end && l < 1000; l++) {\n      let min = 10000 // dummy value\n      cells[start].neighbors.forEach(function(e) {\n        let diff = Math.hypot(cells[end].data[0] - cells[e].data[0],\n          cells[end].data[1] - cells[e].data[1])\n        if (Math.random() > 0.8) {diff = diff / 2}\n        if (diff < min) {\n          min = diff\n          start = e\n        }\n      })\n      range.push(start)\n    }\n    const query = []\n    for (; width > 0; width--) {\n      range.map(function(r) {\n        cells[r].neighbors.forEach(function(e) {\n          if (cells[e].used === session) {return}\n          cells[e].used = session\n          query.push(e)\n          heights[e] *= 0.23\n          if (heights[e] > 100 || heights[e] < 5) heights[e] = 5\n        })\n        range = query.slice()\n      })\n    }\n  }\n\n  function addPit(count, height, cell) {\n    const session = Math.ceil(Math.random() * 1e5)\n    for (let c = 0; c < count; c++) {\n      let change = height ? height + 10 : Math.random() * 10 + 20\n      let start = cell\n      if (!start) {\n        const lowlands = $.grep(cells, function(e) {return (heights[e.index] >= 20)})\n        if (!lowlands.length) return\n        const rnd = Math.floor(Math.random() * lowlands.length)\n        start = lowlands[rnd].index\n      }\n      let query = [start], newQuery = []\n      // depress pit center\n      heights[start] -= change\n      if (heights[start] < 5 || heights[start] > 100) heights[start] = 5\n      cells[start].used = session\n      for (let i = 1; i < 10000; i++) {\n        const rnd = Math.random() * 0.4 + 0.8\n        change -= i / 0.6 * rnd\n        if (change < 1) break\n        query.map(function(p) {\n          cells[p].neighbors.forEach(function(e) {\n            if (cells[e].used === session) return\n            cells[e].used = session\n            if (Math.random() > 0.8) return\n            newQuery.push(e)\n            heights[e] -= change\n            if (heights[e] < 5 || heights[e] > 100) heights[e] = 5\n          })\n        })\n        query = newQuery.slice()\n        newQuery = []\n      }\n    }\n  }\n\n  // Modify heights adding or multiplying by value\n  function modifyHeights(range, add, mult) {\n    function modify(v) {\n      if (add) v += add\n      if (mult !== 1) {\n        if (mult === '^2') mult = (v - 20) / 100\n        if (mult === '^3') mult = ((v - 20) * (v - 20)) / 100\n        if (range === 'land') {v = 20 + (v - 20) * mult} else {v *= mult}\n      }\n      if (v < 0) v = 0\n      if (v > 100) v = 100\n      return v\n    }\n\n    const limMin = range === 'land' ? 20 : range === 'all' ? 0 : +range.split('-')[0]\n    const limMax = range === 'land' || range === 'all' ? 100 : +range.split('-')[1]\n\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] < limMin || heights[i] > limMax) continue\n      heights[i] = modify(heights[i])\n    }\n  }\n\n  // Smooth heights using mean of neighbors\n  function smoothHeights(fraction) {\n    const fr = fraction || 2\n    for (let i = 0; i < heights.length; i++) {\n      const nHeights = [heights[i]]\n      cells[i].neighbors.forEach(function(e) {nHeights.push(heights[e])})\n      heights[i] = (heights[i] * (fr - 1) + d3.mean(nHeights)) / fr\n    }\n  }\n\n  // Randomize heights a bit\n  function disruptHeights() {\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] < 18) continue\n      if (Math.random() < 0.5) continue\n      heights[i] += 2 - Math.random() * 4\n    }\n  }\n\n  // Mark features (ocean, lakes, islands)\n  function markFeatures() {\n    console.time('markFeatures')\n    seedrandom(seed) // reset seed to get the same result on heightmap edit\n    for (let i = 0, queue = [0]; queue.length > 0; i++) {\n      const cell = cells[queue[0]]\n      cell.fn = i // feature number\n      const land = heights[queue[0]] >= 20\n      let border = cell.type === 'border'\n      if (border && land) cell.ctype = 2\n\n      while (queue.length) {\n        const q = queue.pop()\n        if (cells[q].type === 'border') {\n          border = true\n          if (land) cells[q].ctype = 2\n        }\n\n        cells[q].neighbors.forEach(function(e) {\n          const eLand = heights[e] >= 20\n          if (land === eLand && cells[e].fn === undefined) {\n            cells[e].fn = i\n            queue.push(e)\n          }\n          if (land && !eLand) {\n            cells[q].ctype = 2\n            cells[e].ctype = -1\n            cells[q].harbor = cells[q].harbor ? cells[q].harbor + 1 : 1\n          }\n        })\n      }\n      features.push({i, land, border})\n\n      // find unmarked cell\n      for (let c = 0; c < cells.length; c++) {\n        if (cells[c].fn === undefined) {\n          queue[0] = c\n          break\n        }\n      }\n    }\n    console.timeEnd('markFeatures')\n  }\n\n  function drawOcean() {\n    console.time('drawOcean')\n    let limits = []\n    let odd = 0.8 // initial odd for ocean layer is 80%\n    // Define type of ocean cells based on cell distance form land\n    let frontier = $.grep(cells, function(e) {return e.ctype === -1})\n    if (Math.random() < odd) {\n      limits.push(-1)\n      odd = 0.2\n    }\n    for (let c = -2; frontier.length > 0 && c > -10; c--) {\n      if (Math.random() < odd) {\n        limits.unshift(c)\n        odd = 0.2\n      } else {odd += 0.2}\n      frontier.map(function(i) {\n        i.neighbors.forEach(function(e) {\n          if (!cells[e].ctype) cells[e].ctype = c\n        })\n      })\n      frontier = $.grep(cells, function(e) {return e.ctype === c})\n    }\n    if (outlineLayersInput.value === 'none') return\n    if (outlineLayersInput.value !== 'random') limits = outlineLayersInput.value.split(',')\n    // Define area edges\n    const opacity = _.round(0.4 / limits.length, 2)\n    for (let l = 0; l < limits.length; l++) {\n      const edges = []\n      const lim = +limits[l]\n      for (let i = 0; i < cells.length; i++) {\n        if (cells[i].ctype < lim || cells[i].ctype === undefined) continue\n        if (cells[i].ctype > lim && cells[i].type !== 'border') continue\n        const cell = diagram.cells[i]\n        cell.halfedges.forEach(function(e) {\n          const edge = diagram.edges[e]\n          const start = edge[0].join(' ')\n          const end = edge[1].join(' ')\n          if (edge.left && edge.right) {\n            const ea = edge.left.index === i ? edge.right.index : edge.left.index\n            if (cells[ea].ctype < lim) edges.push({start, end})\n          } else {\n            edges.push({start, end})\n          }\n        })\n      }\n      lineGen.curve(d3.curveBasis)\n      let relax = 0.8 - l / 10\n      if (relax < 0.2) relax = 0.2\n      const line = getContinuousLine(edges, 0, relax)\n      oceanLayers.append('path').attr('d', line).attr('fill', '#ecf2f9')\n                 .style('opacity', opacity)\n    }\n    console.timeEnd('drawOcean')\n  }\n\n  // recalculate Voronoi Graph to pack cells\n  function reGraph() {\n    console.time('reGraph')\n    const tempCells = [], newPoints = [] // to store new data\n    // get average precipitation based on graph size\n    const avPrec = precInput.value / 5000\n    const smallLakesMax = 500\n    let smallLakes = 0\n    const evaporation = 2\n    cells.map(function(i, d) {\n      let height = i.height || heights[d]\n      if (height > 100) height = 100\n      const pit = i.pit\n      const ctype = i.ctype\n      if (ctype !== -1 && ctype !== -2 && height < 20) return // exclude all deep ocean points\n      const x = _.round(i.data[0], 1), y = _.round(i.data[1], 1)\n      const fn = i.fn\n      const harbor = i.harbor\n      let lake = i.lake\n      // mark potential cells for small lakes to add additional point there\n      if (smallLakes < smallLakesMax && !lake && pit > evaporation && ctype !== 2) {\n        lake = 2\n        smallLakes++\n      }\n      const region = i.region // handle value for edit heightmap mode only\n      const culture = i.culture // handle value for edit heightmap mode only\n      let copy = $.grep(newPoints, function(e) {return (e[0] == x && e[1] == y)})\n      if (!copy.length) {\n        newPoints.push([x, y])\n        tempCells.push({\n          index: tempCells.length,\n          data: [x, y],\n          height,\n          pit,\n          ctype,\n          fn,\n          harbor,\n          lake,\n          region,\n          culture\n        })\n      }\n      // add additional points for cells along coast\n      if (ctype === 2 || ctype === -1) {\n        if (i.type === 'border') return\n        if (!features[fn].land && !features[fn].border) return\n        i.neighbors.forEach(function(e) {\n          if (cells[e].ctype === ctype) {\n            let x1 = (x * 2 + cells[e].data[0]) / 3\n            let y1 = (y * 2 + cells[e].data[1]) / 3\n            x1 = _.round(x1, 1), y1 = _.round(y1, 1)\n            copy = $.grep(newPoints, function(e) {return e[0] === x1 && e[1] === y1})\n            if (copy.length) return\n            newPoints.push([x1, y1])\n            tempCells.push({\n              index: tempCells.length,\n              data: [x1, y1],\n              height,\n              pit,\n              ctype,\n              fn,\n              harbor,\n              lake,\n              region,\n              culture\n            })\n          }\n        })\n      }\n      if (lake === 2) { // add potential small lakes\n        polygons[i.index].forEach(function(e) {\n          if (Math.random() > 0.8) return\n          let rnd = Math.random() * 0.6 + 0.8\n          const x1 = _.round((e[0] * rnd + i.data[0]) / (1 + rnd), 2)\n          rnd = Math.random() * 0.6 + 0.8\n          const y1 = _.round((e[1] * rnd + i.data[1]) / (1 + rnd), 2)\n          copy = $.grep(newPoints, function(c) {return x1 === c[0] && y1 === c[1]})\n          if (copy.length) return\n          newPoints.push([x1, y1])\n          tempCells.push(\n            {index: tempCells.length, data: [x1, y1], height, pit, ctype, fn, region, culture})\n        })\n      }\n    })\n    console.log('small lakes candidates: ' + smallLakes)\n    cells = tempCells // use tempCells as the only cells array\n    calculateVoronoi(newPoints) // recalculate Voronoi diagram using new points\n    let gridPath = '' // store grid as huge single path string\n    cells.map(function(i, d) {\n      if (i.height >= 20) {\n        // calc cell area\n        i.area = _.round(Math.abs(d3.polygonArea(polygons[d])), 2)\n        const prec = _.round(avPrec * i.area, 2)\n        i.flux = i.lake ? prec * 10 : prec\n      }\n      const neighbors = [] // re-detect neighbors\n      diagram.cells[d].halfedges.forEach(function(e) {\n        const edge = diagram.edges[e]\n        if (edge.left === undefined || edge.right === undefined) {\n          if (i.height >= 20) i.ctype = 99 // border cell\n          return\n        }\n        const ea = edge.left.index === d ? edge.right.index : edge.left.index\n        neighbors.push(ea)\n        if (d < ea && i.height >= 20 && i.lake !== 1 && cells[ea].height >= 20 && cells[ea].lake !== 1) {\n          gridPath += 'M' + edge[0][0] + ',' + edge[0][1] + 'L' + edge[1][0] + ',' + edge[1][1]\n        }\n      })\n      i.neighbors = neighbors\n      if (i.region === undefined) delete i.region\n      if (i.culture === undefined) delete i.culture\n    })\n    grid.append('path').attr('d', gridPath)\n    console.timeEnd('reGraph')\n  }\n\n  // redraw all cells for Customization 1 mode\n  function mockHeightmap() {\n    let landCells = 0\n    $('#landmass').empty()\n    const limit = renderOcean.checked ? 1 : 20\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] < limit) continue\n      if (heights[i] > 100) heights[i] = 100\n      const clr = color(1 - heights[i] / 100)\n      landmass.append('path').attr('id', 'cell' + i)\n              .attr('d', 'M' + polygons[i].join('L') + 'Z')\n              .attr('fill', clr).attr('stroke', clr)\n    }\n  }\n\n  $('#renderOcean').click(mockHeightmap)\n\n  // draw or update all cells\n  function updateHeightmap() {\n    const limit = renderOcean.checked ? 1 : 20\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] > 100) heights[i] = 100\n      let cell = landmass.select('#cell' + i)\n      const clr = color(1 - heights[i] / 100)\n      if (cell.size()) {\n        if (heights[i] < limit) {cell.remove()} else {\n          cell.attr('fill', clr).attr('stroke', clr)\n        }\n      } else if (heights[i] >= limit) {\n        cell = landmass.append('path').attr('id', 'cell' + i)\n                       .attr('d', 'M' + polygons[i].join('L') + 'Z')\n                       .attr('fill', clr).attr('stroke', clr)\n      }\n    }\n  }\n\n  // draw or update cells from the selection\n  function updateHeightmapSelection(selection) {\n    if (selection === undefined) return\n    const limit = renderOcean.checked ? 1 : 20\n    selection.map(function(s) {\n      if (heights[s] > 100) heights[s] = 100\n      let cell = landmass.select('#cell' + s)\n      const clr = color(1 - heights[s] / 100)\n      if (cell.size()) {\n        if (heights[s] < limit) {cell.remove()} else {\n          cell.attr('fill', clr).attr('stroke', clr)\n        }\n      } else if (heights[s] >= limit) {\n        cell = landmass.append('path').attr('id', 'cell' + s)\n                       .attr('d', 'M' + polygons[s].join('L') + 'Z')\n                       .attr('fill', clr).attr('stroke', clr)\n      }\n    })\n  }\n\n  function updateHistory() {\n    let landCells = 0 // count number of land cells\n    if (renderOcean.checked) {\n      landCells =\n        heights.reduce(function(s, v) {if (v >= 20) {return s + 1} else {return s}}, 0)\n    } else {\n      landCells = landmass.selectAll('*').size()\n    }\n    history = history.slice(0, historyStage)\n    history[historyStage] = heights.slice()\n    historyStage++\n    undo.disabled = templateUndo.disabled = historyStage <= 1\n    redo.disabled = templateRedo.disabled = true\n    const landMean = Math.trunc(d3.mean(heights))\n    const landRatio = _.round(landCells / heights.length * 100)\n    landmassCounter.innerHTML = landCells\n    landmassRatio.innerHTML = landRatio\n    landmassAverage.innerHTML = landMean\n    // if perspective view dialog is opened, update it\n    if ($('#perspectivePanel').is(':visible')) drawPerspective()\n  }\n\n  // restoreHistory\n  function restoreHistory(step) {\n    historyStage = step\n    redo.disabled = templateRedo.disabled = historyStage >= history.length\n    undo.disabled = templateUndo.disabled = historyStage <= 1\n    if (history[historyStage - 1] === undefined) return\n    heights = history[historyStage - 1].slice()\n    updateHeightmap()\n  }\n\n  // restart history from 1st step\n  function restartHistory() {\n    history = []\n    historyStage = 0\n    redo.disabled = templateRedo.disabled = true\n    undo.disabled = templateUndo.disabled = true\n    updateHistory()\n  }\n\n  // Detect and draw the coasline\n  function drawCoastline() {\n    console.time('drawCoastline')\n    seedrandom(seed) // reset seed to get the same result on heightmap edit\n    const shape = defs.append('mask').attr('id', 'shape').attr('fill', 'black').attr('x', 0)\n                      .attr('y', 0).attr('width', '100%').attr('height', '100%')\n    $('#landmass').empty()\n    let minX = graphWidth, maxX = 0 // extreme points\n    let minXedge, maxXedge // extreme edges\n    const oceanEdges = [], lakeEdges = []\n    for (let i = 0; i < land.length; i++) {\n      const id = land[i].index, cell = diagram.cells[id]\n      const f = land[i].fn\n      land[i].height = Math.trunc(land[i].height)\n      if (!oceanEdges[f]) {\n        oceanEdges[f] = []\n        lakeEdges[f] = []\n      }\n      cell.halfedges.forEach(function(e) {\n        const edge = diagram.edges[e]\n        const start = edge[0].join(' ')\n        const end = edge[1].join(' ')\n        if (edge.left && edge.right) {\n          const ea = edge.left.index === id ? edge.right.index : edge.left.index\n          cells[ea].height = Math.trunc(cells[ea].height)\n          if (cells[ea].height < 20) {\n            cells[ea].ctype = -1\n            if (land[i].ctype !== 1) {\n              land[i].ctype = 1 // mark coastal land cells\n              // move cell point closer to coast\n              const x = (land[i].data[0] + cells[ea].data[0]) / 2\n              const y = (land[i].data[1] + cells[ea].data[1]) / 2\n              land[i].haven = ea // harbor haven (oposite water cell)\n              land[i].coastX = _.round(x + (land[i].data[0] - x) * 0.1, 1)\n              land[i].coastY = _.round(y + (land[i].data[1] - y) * 0.1, 1)\n              land[i].data[0] = _.round(x + (land[i].data[0] - x) * 0.5, 1)\n              land[i].data[1] = _.round(y + (land[i].data[1] - y) * 0.5, 1)\n            }\n            if (features[cells[ea].fn].border) {\n              oceanEdges[f].push({start, end})\n              // island extreme points\n              if (edge[0][0] < minX) {\n                minX = edge[0][0]\n                minXedge = edge[0]\n              }\n              if (edge[1][0] < minX) {\n                minX = edge[1][0]\n                minXedge = edge[1]\n              }\n              if (edge[0][0] > maxX) {\n                maxX = edge[0][0]\n                maxXedge = edge[0]\n              }\n              if (edge[1][0] > maxX) {\n                maxX = edge[1][0]\n                maxXedge = edge[1]\n              }\n            } else {\n              const l = cells[ea].fn\n              if (!lakeEdges[f][l]) lakeEdges[f][l] = []\n              lakeEdges[f][l].push({start, end})\n            }\n          }\n        } else {\n          oceanEdges[f].push({start, end})\n        }\n      })\n    }\n\n    for (let f = 0; f < features.length; f++) {\n      if (!oceanEdges[f]) continue\n      if (!oceanEdges[f].length && lakeEdges[f].length) {\n        const m = lakeEdges[f].indexOf(d3.max(lakeEdges[f]))\n        oceanEdges[f] = lakeEdges[f][m]\n        lakeEdges[f][m] = []\n      }\n      lineGen.curve(d3.curveCatmullRomClosed.alpha(0.1))\n      const oceanCoastline = getContinuousLine(oceanEdges[f], 3, 0)\n      if (oceanCoastline) {\n        shape.append('path').attr('d', oceanCoastline).attr('fill', 'white') // draw the mask\n        coastline.append('path').attr('d', oceanCoastline) // draw the coastline\n      }\n      lineGen.curve(d3.curveBasisClosed)\n      lakeEdges[f].forEach(function(l) {\n        const lakeCoastline = getContinuousLine(l, 3, 0)\n        if (lakeCoastline) {\n          shape.append('path').attr('d', lakeCoastline).attr('fill', 'black') // draw the mask\n          lakes.append('path').attr('d', lakeCoastline) // draw the lakes\n        }\n      })\n    }\n    landmass.append('rect').attr('x', 0).attr('y', 0).attr('width', graphWidth)\n            .attr('height', graphHeight) // draw the landmass\n    drawDefaultRuler(minXedge, maxXedge)\n    console.timeEnd('drawCoastline')\n  }\n\n  // draw default scale bar\n  function drawScaleBar() {\n    if ($('#scaleBar').hasClass('hidden')) return // no need to re-draw hidden element\n    svg.select('#scaleBar').remove() // fully redraw every time\n    // get size\n    const size = +barSize.value\n    const dScale = distanceScale.value\n    const unit = distanceUnit.value\n    const scaleBar = svg.append('g').attr('id', 'scaleBar')\n                        .on('click', editScale)\n                        .on('mousemove', function() {\n                          tip('Click to open Scale Editor, drag to move')\n                        })\n                        .call(d3.drag().on('start', elementDrag))\n    const init = 100 // actual length in pixels if scale, dScale and size = 1;\n    let val = init * size * dScale / scale // bar length in distance unit\n    if (val > 900) {val = _.round(val, -3)} // round to 1000\n    else if (val > 90) {val = _.round(val, -2)} // round to 100\n    else if (val > 9) {val = _.round(val, -1)} // round to 10\n    else {val = Math.round(val)} // round to 1\n    const l = val * scale / dScale // actual length in pixels on this scale\n    const x = 0, y = 0 // initial position\n    scaleBar.append('line').attr('x1', x + 0.5).attr('y1', y).attr('x2', x + l + size - 0.5)\n            .attr('y2', y).attr('stroke-width', size).attr('stroke', 'white')\n    scaleBar.append('line').attr('x1', x).attr('y1', y + size).attr('x2', x + l + size)\n            .attr('y2', y + size).attr('stroke-width', size).attr('stroke', '#3d3d3d')\n    const dash = size + ' ' + _.round(l / 5 - size, 2)\n    scaleBar.append('line').attr('x1', x).attr('y1', y).attr('x2', x + l + size).attr('y2', y)\n            .attr('stroke-width', _.round(size * 3, 2)).attr('stroke-dasharray', dash)\n            .attr('stroke', '#3d3d3d')\n    // big scale\n    for (let b = 0; b < 6; b++) {\n      const value = _.round(b * l / 5, 2)\n      const label = _.round(value * dScale / scale)\n      if (b === 5) {\n        scaleBar.append('text').attr('x', x + value).attr('y', y - 2 * size)\n                .attr('font-size', _.round(5 * size, 1)).text(label + ' ' + unit)\n      } else {\n        scaleBar.append('text').attr('x', x + value).attr('y', y - 2 * size)\n                .attr('font-size', _.round(5 * size, 1)).text(label)\n      }\n    }\n    if (barLabel.value !== '') {\n      scaleBar.append('text').attr('x', x + (l + 1) / 2).attr('y', y + 2 * size)\n              .attr('dominant-baseline', 'text-before-edge')\n              .attr('font-size', _.round(5 * size, 1)).text(barLabel.value)\n    }\n    const bbox = scaleBar.node().getBBox()\n    // append backbround rectangle\n    scaleBar.insert('rect', ':first-child').attr('x', -10).attr('y', -20)\n            .attr('width', bbox.width + 10).attr('height', bbox.height + 15)\n            .attr('stroke-width', size).attr('stroke', 'none').attr('filter', 'url(#blur5)')\n            .attr('fill', barBackColor.value).attr('opacity', +barBackOpacity.value)\n    fitScaleBar()\n  }\n\n  // draw default ruler measiring land x-axis edges\n  function drawDefaultRuler(minXedge, maxXedge) {\n    const rulerNew = ruler.append('g').attr('class', 'linear')\n                          .call(d3.drag().on('start', elementDrag))\n    if (!minXedge) minXedge = [0, 0]\n    if (!maxXedge) maxXedge = [svgWidth, svgHeight]\n    const x1 = _.round(minXedge[0], 2), y1 = _.round(minXedge[1], 2), x2 = _.round(maxXedge[0], 2),\n      y2 = _.round(maxXedge[1], 2)\n    rulerNew.append('line').attr('x1', x1).attr('y1', y1).attr('x2', x2).attr('y2', y2)\n            .attr('class', 'white')\n    rulerNew.append('line').attr('x1', x1).attr('y1', y1).attr('x2', x2).attr('y2', y2)\n            .attr('class', 'gray').attr('stroke-dasharray', 10)\n    rulerNew.append('circle').attr('r', 2).attr('cx', x1).attr('cy', y1).attr('stroke-width', 0.5)\n            .attr('data-edge', 'left').call(d3.drag().on('drag', rulerEdgeDrag))\n    rulerNew.append('circle').attr('r', 2).attr('cx', x2).attr('cy', y2).attr('stroke-width', 0.5)\n            .attr('data-edge', 'rigth').call(d3.drag().on('drag', rulerEdgeDrag))\n    const x0 = _.round((x1 + x2) / 2, 2)\n    const y0 = _.round((y1 + y2) / 2, 2)\n    rulerNew.append('circle').attr('r', 1.2).attr('cx', x0).attr('cy', y0)\n            .attr('stroke-width', 0.3).attr('class', 'center')\n            .call(d3.drag().on('start', rulerCenterDrag))\n    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI\n    const tr = 'rotate(' + angle + ' ' + x0 + ' ' + y0 + ')'\n    const dist = Math.round(Math.hypot(x1 - x2, y1 - y2))\n    const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n    rulerNew.append('text').attr('x', x0).attr('y', y0).attr('dy', -1).attr('transform', tr)\n            .attr('data-dist', dist).text(label).on('click', removeParent).attr('font-size', 10)\n  }\n\n  // drag any element changing transform\n  function elementDrag() {\n    const el = d3.select(this)\n    const tr = parseTransform(el.attr('transform'))\n    const dx = +tr[0] - d3.event.x\n    const dy = +tr[1] - d3.event.y\n\n    d3.event.on('drag', function() {\n      const x = d3.event.x\n      const y = d3.event.y\n      const transform = `translate(${(dx + x)},${(dy + y)}) rotate(${tr[2]} ${tr[3]} ${tr[4]})`\n      el.attr('transform', transform)\n      const pp = this.parentNode.parentNode.id\n      if (pp === 'burgIcons' || pp === 'burgLabels') {\n        tip('Use dragging for fine-tuning only, to move burg to a different cell use \"Relocate\" button')\n      }\n      if (pp === 'labels') {\n        // also transform curve control circle\n        debug.select('circle').attr('transform', transform)\n      }\n    })\n\n    d3.event.on('end', function() {\n      // remember scaleBar bottom-right position\n      if (el.attr('id') === 'scaleBar') {\n        const xEnd = d3.event.x, yEnd = d3.event.y\n        const diff = Math.abs(dx - xEnd) + Math.abs(dy - yEnd)\n        if (diff > 5) {\n          const bbox = el.node().getBoundingClientRect()\n          sessionStorage.setItem('scaleBar', [bbox.right, bbox.bottom])\n        }\n      }\n    })\n  }\n\n  // draw ruler circles and update label\n  function rulerEdgeDrag() {\n    const group = d3.select(this.parentNode)\n    const edge = d3.select(this).attr('data-edge')\n    const x = d3.event.x, y = d3.event.y\n    let x0, y0\n    d3.select(this).attr('cx', x).attr('cy', y)\n    const line = group.selectAll('line')\n    if (edge === 'left') {\n      line.attr('x1', x).attr('y1', y)\n      x0 = +line.attr('x2')\n      y0 = +line.attr('y2')\n    } else {\n      line.attr('x2', x).attr('y2', y)\n      x0 = +line.attr('x1')\n      y0 = +line.attr('y1')\n    }\n    const xc = _.round((x + x0) / 2, 2)\n    const yc = _.round((y + y0) / 2, 2)\n    group.select('.center').attr('cx', xc).attr('cy', yc)\n    const dist = Math.round(Math.hypot(x0 - x, y0 - y))\n    const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n    const atan = x0 > x ? Math.atan2(y0 - y, x0 - x) : Math.atan2(y - y0, x - x0)\n    const angle = _.round(atan * 180 / Math.PI, 3)\n    const tr = 'rotate(' + angle + ' ' + xc + ' ' + yc + ')'\n    group.select('text').attr('x', xc).attr('y', yc).attr('transform', tr).attr('data-dist', dist)\n         .text(label)\n  }\n\n  // draw ruler center point to split ruler into 2 parts\n  function rulerCenterDrag() {\n    let xc1, yc1, xc2, yc2\n    const group = d3.select(this.parentNode) // current ruler group\n    let x = d3.event.x, y = d3.event.y // current coords\n    const line = group.selectAll('line') // current lines\n    const x1 = +line.attr('x1'), y1 = +line.attr('y1'), x2 = +line.attr('x2'),\n      y2 = +line.attr('y2') // initial line edge points\n    const rulerNew = ruler.insert('g', ':first-child')\n    rulerNew.attr('transform', group.attr('transform')).call(d3.drag().on('start', elementDrag))\n    const factor = _.round(1 / Math.pow(scale, 0.3), 1)\n    rulerNew.append('line').attr('class', 'white').attr('stroke-width', factor)\n    const dash = +group.select('.gray').attr('stroke-dasharray')\n    rulerNew.append('line').attr('class', 'gray').attr('stroke-dasharray', dash)\n            .attr('stroke-width', factor)\n    rulerNew.append('text').attr('dy', -1).on('click', removeParent)\n            .attr('font-size', 10 * factor).attr('stroke-width', factor)\n\n    d3.event.on('drag', function() {\n      x = d3.event.x, y = d3.event.y\n      d3.select(this).attr('cx', x).attr('cy', y)\n      // change first part\n      line.attr('x1', x1).attr('y1', y1).attr('x2', x).attr('y2', y)\n      let dist = Math.round(Math.hypot(x1 - x, y1 - y))\n      let label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      let atan = x1 > x ? Math.atan2(y1 - y, x1 - x) : Math.atan2(y - y1, x - x1)\n      xc1 = _.round((x + x1) / 2, 2)\n      yc1 = _.round((y + y1) / 2, 2)\n      let tr = 'rotate(' + _.round(atan * 180 / Math.PI, 3) + ' ' + xc1 + ' ' + yc1 + ')'\n      group.select('text').attr('x', xc1).attr('y', yc1).attr('transform', tr)\n           .attr('data-dist', dist).text(label)\n      // change second (new) part\n      dist = Math.round(Math.hypot(x2 - x, y2 - y))\n      label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      atan = x2 > x ? Math.atan2(y2 - y, x2 - x) : Math.atan2(y - y2, x - x2)\n      xc2 = _.round((x + x2) / 2, 2)\n      yc2 = _.round((y + y2) / 2, 2)\n      tr = 'rotate(' + _.round(atan * 180 / Math.PI, 3) + ' ' + xc2 + ' ' + yc2 + ')'\n      rulerNew.selectAll('line').attr('x1', x).attr('y1', y).attr('x2', x2).attr('y2', y2)\n      rulerNew.select('text').attr('x', xc2).attr('y', yc2).attr('transform', tr)\n              .attr('data-dist', dist).text(label)\n    })\n\n    d3.event.on('end', function() {\n      // circles for 1st part\n      group.selectAll('circle').remove()\n      group.append('circle').attr('cx', x1).attr('cy', y1).attr('r', 2 * factor)\n           .attr('stroke-width', 0.5 * factor).attr('data-edge', 'left')\n           .call(d3.drag().on('drag', rulerEdgeDrag))\n      group.append('circle').attr('cx', x).attr('cy', y).attr('r', 2 * factor)\n           .attr('stroke-width', 0.5 * factor).attr('data-edge', 'rigth')\n           .call(d3.drag().on('drag', rulerEdgeDrag))\n      group.append('circle').attr('cx', xc1).attr('cy', yc1).attr('r', 1.2 * factor)\n           .attr('stroke-width', 0.3 * factor).attr('class', 'center')\n           .call(d3.drag().on('start', rulerCenterDrag))\n      // circles for 2nd part\n      rulerNew.append('circle').attr('cx', x).attr('cy', y).attr('r', 2 * factor)\n              .attr('stroke-width', 0.5 * factor).attr('data-edge', 'left')\n              .call(d3.drag().on('drag', rulerEdgeDrag))\n      rulerNew.append('circle').attr('cx', x2).attr('cy', y2).attr('r', 2 * factor)\n              .attr('stroke-width', 0.5 * factor).attr('data-edge', 'rigth')\n              .call(d3.drag().on('drag', rulerEdgeDrag))\n      rulerNew.append('circle').attr('cx', xc2).attr('cy', yc2).attr('r', 1.2 * factor)\n              .attr('stroke-width', 0.3 * factor).attr('class', 'center')\n              .call(d3.drag().on('start', rulerCenterDrag))\n    })\n  }\n\n  function opisometerEdgeDrag() {\n    const el = d3.select(this)\n    const x0 = +el.attr('cx'), y0 = +el.attr('cy')\n    const group = d3.select(this.parentNode)\n    const curve = group.select('.white')\n    const curveGray = group.select('.gray')\n    const text = group.select('text')\n    const points = JSON.parse(text.attr('data-points'))\n    if (x0 === points[0].scX && y0 === points[0].scY) {points.reverse()}\n\n    d3.event.on('drag', function() {\n      const x = d3.event.x, y = d3.event.y\n      el.attr('cx', x).attr('cy', y)\n      const l = points[points.length - 1]\n      const diff = Math.hypot(l.scX - x, l.scY - y)\n      if (diff > 5) {points.push({scX: x, scY: y})} else {return}\n      lineGen.curve(d3.curveBasis)\n      const d = round(lineGen(points))\n      curve.attr('d', d)\n      curveGray.attr('d', d)\n      const dist = Math.round(curve.node().getTotalLength())\n      const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      text.attr('x', x).attr('y', y).text(label)\n    })\n\n    d3.event.on('end', function() {\n      const dist = Math.round(curve.node().getTotalLength())\n      const c = curve.node().getPointAtLength(dist / 2)\n      const p = curve.node().getPointAtLength((dist / 2) - 1)\n      const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      const atan = p.x > c.x ? Math.atan2(p.y - c.y, p.x - c.x) :\n                   Math.atan2(c.y - p.y, c.x - p.x)\n      const angle = Math.round(atan * 180 / Math.PI, 3)\n      const tr = 'rotate(' + angle + ' ' + c.x + ' ' + c.y + ')'\n      text.attr('data-points', JSON.stringify(points)).attr('data-dist', dist).attr('x', c.x)\n          .attr('y', c.y).attr('transform', tr).text(label)\n    })\n  }\n\n  function getContinuousLine(edges, indention, relax) {\n    let line = ''\n    if (edges.length < 3) return ''\n    while (edges.length > 2) {\n      let edgesOrdered = [] // to store points in a correct order\n      let start = edges[0].start\n      let end = edges[0].end\n      edges.shift()\n      let spl = start.split(' ')\n      edgesOrdered.push({scX: +spl[0], scY: +spl[1]})\n      spl = end.split(' ')\n      edgesOrdered.push({scX: +spl[0], scY: +spl[1]})\n      let x0 = +spl[0], y0 = +spl[1]\n      for (let i = 0; end !== start && i < 100000; i++) {\n        let next = null, index = null\n        for (let e = 0; e < edges.length; e++) {\n          const edge = edges[e]\n          if (edge.start == end || edge.end == end) {\n            next = edge\n            end = next.start == end ? next.end : next.start\n            index = e\n            break\n          }\n        }\n        if (!next) {\n          console.error('Next edge is not found')\n          return ''\n        }\n        spl = end.split(' ')\n        if (indention || relax) {\n          const dist = Math.hypot(+spl[0] - x0, +spl[1] - y0)\n          if (dist >= indention && Math.random() > relax) {\n            edgesOrdered.push({scX: +spl[0], scY: +spl[1]})\n            x0 = +spl[0], y0 = +spl[1]\n          }\n        } else {\n          edgesOrdered.push({scX: +spl[0], scY: +spl[1]})\n        }\n        edges.splice(index, 1)\n        if (i === 100000 - 1) {\n          console.error('Line not ended, limit reached')\n          break\n        }\n      }\n      line += lineGen(edgesOrdered)\n    }\n    return round(line, 1)\n  }\n\n  // temporary elevate lakes to min neighbors heights to correctly flux the water\n  function elevateLakes() {\n    console.time('elevateLakes')\n    const lakes = $.grep(cells,\n      function(e, d) {return heights[d] < 20 && !features[e.fn].border})\n    lakes.sort(function(a, b) {return heights[b.index] - heights[a.index]})\n    for (let i = 0; i < lakes.length; i++) {\n      const hs = [], id = lakes[i].index\n      cells[id].height = heights[id] // use height on object level\n      lakes[i].neighbors.forEach(function(n) {\n        const nHeight = cells[n].height || heights[n]\n        if (nHeight >= 20) hs.push(nHeight)\n      })\n      if (hs.length) cells[id].height = d3.min(hs) - 1\n      if (cells[id].height < 20) cells[id].height = 20\n      lakes[i].lake = 1\n    }\n    console.timeEnd('elevateLakes')\n  }\n\n  // Depression filling algorithm (for a correct water flux modeling; phase1)\n  function resolveDepressionsPrimary() {\n    console.time('resolveDepressionsPrimary')\n    land = $.grep(cells, function(e, d) {\n      if (!e.height) e.height = heights[d] // use height on object level\n      return e.height >= 20\n    })\n    land.sort(function(a, b) {return b.height - a.height})\n    const limit = 10\n    for (let l = 0, depression = 1; depression > 0 && l < limit; l++) {\n      depression = 0\n      for (let i = 0; i < land.length; i++) {\n        const id = land[i].index\n        if (land[i].type === 'border') continue\n        const hs = land[i].neighbors.map(function(n) {return cells[n].height})\n        const minHigh = d3.min(hs)\n        if (cells[id].height <= minHigh) {\n          depression++\n          land[i].pit = land[i].pit ? land[i].pit + 1 : 1\n          cells[id].height = minHigh + 2\n        }\n      }\n      if (l === 0) console.log(' depressions init: ' + depression)\n    }\n    console.timeEnd('resolveDepressionsPrimary')\n  }\n\n  // Depression filling algorithm (for a correct water flux modeling; phase2)\n  function resolveDepressionsSecondary() {\n    console.time('resolveDepressionsSecondary')\n    land = $.grep(cells, function(e) {return e.height >= 20})\n    land.sort(function(a, b) {return b.height - a.height})\n    const limit = 100\n    for (let l = 0, depression = 1; depression > 0 && l < limit; l++) {\n      depression = 0\n      for (let i = 0; i < land.length; i++) {\n        if (land[i].ctype === 99) continue\n        const nHeights = land[i].neighbors.map(function(n) {return cells[n].height})\n        const minHigh = d3.min(nHeights)\n        if (land[i].height <= minHigh) {\n          depression++\n          land[i].pit = land[i].pit ? land[i].pit + 1 : 1\n          land[i].height = Math.trunc(minHigh + 2)\n        }\n      }\n      if (l === 0) console.log(' depressions reGraphed: ' + depression)\n      if (l === limit - 1) console.error('Error: resolveDepressions iteration limit')\n    }\n    console.timeEnd('resolveDepressionsSecondary')\n  }\n\n  // restore initial heights if user don't want system to change heightmap\n  function restoreCustomHeights() {\n    land.forEach(function(l) {\n      if (!l.pit) return\n      l.height = Math.trunc(l.height - l.pit * 2)\n      if (l.height < 20) l.height = 20\n    })\n  }\n\n  function flux() {\n    console.time('flux')\n    riversData = []\n    let riverNext = 0\n    land.sort(function(a, b) {return b.height - a.height})\n    for (let i = 0; i < land.length; i++) {\n      const id = land[i].index\n      const sx = land[i].data[0]\n      const sy = land[i].data[1]\n      let fn = land[i].fn\n      if (land[i].ctype === 99) {\n        if (land[i].river !== undefined) {\n          let x, y\n          const min = Math.min(sy, graphHeight - sy, sx, graphWidth - sx)\n          if (min === sy) {\n            x = sx\n            y = 0\n          }\n          if (min === graphHeight - sy) {\n            x = sx\n            y = graphHeight\n          }\n          if (min === sx) {\n            x = 0\n            y = sy\n          }\n          if (min === graphWidth - sx) {\n            x = graphWidth\n            y = sy\n          }\n          riversData.push({river: land[i].river, cell: id, x, y})\n        }\n        continue\n      }\n      if (features[fn].river !== undefined) {\n        if (land[i].river !== features[fn].river) {\n          land[i].river = undefined\n          land[i].flux = 0\n        }\n      }\n      let minHeight = 1000, min\n      land[i].neighbors.forEach(function(e) {\n        if (cells[e].height < minHeight) {\n          minHeight = cells[e].height\n          min = e\n        }\n      })\n      // Define river number\n      if (min !== undefined && land[i].flux > 1) {\n        if (land[i].river === undefined) {\n          // State new River\n          land[i].river = riverNext\n          riversData.push({river: riverNext, cell: id, x: sx, y: sy})\n          riverNext += 1\n        }\n        // Assing existing River to the downhill cell\n        if (cells[min].river == undefined) {\n          cells[min].river = land[i].river\n        } else {\n          const riverTo = cells[min].river\n          const iRiver = $.grep(riversData, function(e) {\n            return (e.river == land[i].river)\n          })\n          const minRiver = $.grep(riversData, function(e) {\n            return (e.river == riverTo)\n          })\n          let iRiverL = iRiver.length\n          let minRiverL = minRiver.length\n          // re-assing river nunber if new part is greater\n          if (iRiverL >= minRiverL) {\n            cells[min].river = land[i].river\n            iRiverL += 1\n            minRiverL -= 1\n          }\n          // mark confluences\n          if (cells[min].height >= 20 && iRiverL > 1 && minRiverL > 1) {\n            if (!cells[min].confluence) {\n              cells[min].confluence = minRiverL - 1\n            } else {\n              cells[min].confluence += minRiverL - 1\n            }\n          }\n        }\n      }\n      if (cells[min].flux) cells[min].flux += land[i].flux\n      if (land[i].river !== undefined) {\n        const px = cells[min].data[0]\n        const py = cells[min].data[1]\n        if (cells[min].height < 20) {\n          // pour water to the sea\n          const x = (px + sx) / 2 + (px - sx) / 10\n          const y = (py + sy) / 2 + (py - sy) / 10\n          riversData.push({river: land[i].river, cell: id, x, y})\n        } else {\n          if (cells[min].lake === 1) {\n            fn = cells[min].fn\n            if (features[fn].river === undefined) features[fn].river = land[i].river\n          }\n          // add next River segment\n          riversData.push({river: land[i].river, cell: min, x: px, y: py})\n        }\n      }\n    }\n    console.timeEnd('flux')\n    drawRiverLines(riverNext)\n  }\n\n  function drawRiverLines(riverNext) {\n    console.time('drawRiverLines')\n    for (let i = 0; i < riverNext; i++) {\n      const dataRiver = $.grep(riversData, function(e) {\n        return e.river === i\n      })\n      if (dataRiver.length > 1) {\n        const riverAmended = amendRiver(dataRiver, 1)\n        const width = _.round(0.8 + Math.random() * 0.4, 1)\n        const increment = _.round(0.8 + Math.random() * 0.4, 1)\n        const d = drawRiver(riverAmended, width, increment)\n        rivers.append('path').attr('d', d).attr('id', 'river' + i).attr('data-width', width)\n              .attr('data-increment', increment)\n      }\n    }\n    rivers.selectAll('path').on('click', editRiver)\n    console.timeEnd('drawRiverLines')\n  }\n\n  // add more river points on 1/3 and 2/3 of length\n  function amendRiver(dataRiver, rndFactor) {\n    const riverAmended = []\n    let side = 1\n    for (let r = 0; r < dataRiver.length; r++) {\n      const dX = dataRiver[r].x\n      const dY = dataRiver[r].y\n      const cell = dataRiver[r].cell\n      const c = cells[cell].confluence || 0\n      riverAmended.push([dX, dY, c])\n      if (r + 1 < dataRiver.length) {\n        const eX = dataRiver[r + 1].x\n        const eY = dataRiver[r + 1].y\n        const angle = Math.atan2(eY - dY, eX - dX)\n        const serpentine = 1 / (r + 1)\n        const meandr = serpentine + 0.3 + Math.random() * 0.3 * rndFactor\n        if (Math.random() > 0.5) {\n          side *= -1\n        }\n        const dist = Math.hypot(eX - dX, eY - dY)\n        // if dist is big or river is small add 2 extra points\n        if (dist > 8 || (dist > 4 && dataRiver.length < 6)) {\n          let stX = (dX * 2 + eX) / 3\n          let stY = (dY * 2 + eY) / 3\n          let enX = (dX + eX * 2) / 3\n          let enY = (dY + eY * 2) / 3\n          stX += -Math.sin(angle) * meandr * side\n          stY += Math.cos(angle) * meandr * side\n          if (Math.random() > 0.8) {\n            side *= -1\n          }\n          enX += Math.sin(angle) * meandr * side\n          enY += -Math.cos(angle) * meandr * side\n          riverAmended.push([stX, stY], [enX, enY])\n          // if dist is medium or river is small add 1 extra point\n        } else if (dist > 4 || dataRiver.length < 6) {\n          let scX = (dX + eX) / 2\n          let scY = (dY + eY) / 2\n          scX += -Math.sin(angle) * meandr * side\n          scY += Math.cos(angle) * meandr * side\n          riverAmended.push([scX, scY])\n        }\n      }\n    }\n    return riverAmended\n  }\n\n  // draw river polygon using arrpoximation\n  function drawRiver(points, width, increment) {\n    lineGen.curve(d3.curveCatmullRom.alpha(0.1))\n    let extraOffset = 0.03 // start offset to make river source visible\n    width = width || 1 // river width modifier\n    increment = increment || 1 // river bed widening modifier\n    let riverLength = 0\n    points.map(function(p, i) {\n      if (i === 0) {return 0}\n      riverLength += Math.hypot(p[0] - points[i - 1][0], p[1] - points[i - 1][1])\n    })\n    const widening = Math.round((1000 + (riverLength * 30)) * increment)\n    const riverPointsLeft = [], riverPointsRight = []\n    const last = points.length - 1\n    const factor = riverLength / points.length\n\n    // first point\n    let x = points[0][0], y = points[0][1], c\n    let angle = Math.atan2(y - points[1][1], x - points[1][0])\n    let xLeft = x + -Math.sin(angle) * extraOffset, yLeft = y + Math.cos(angle) * extraOffset\n    riverPointsLeft.push({scX: xLeft, scY: yLeft})\n    let xRight = x + Math.sin(angle) * extraOffset, yRight = y + -Math.cos(angle) * extraOffset\n    riverPointsRight.unshift({scX: xRight, scY: yRight})\n\n    // middle points\n    for (let p = 1; p < last; p++) {\n      x = points[p][0], y = points[p][1], c = points[p][2]\n      if (c) {extraOffset += Math.atan(c * 10 / widening)} // confluence\n      const xPrev = points[p - 1][0], yPrev = points[p - 1][1]\n      const xNext = points[p + 1][0], yNext = points[p + 1][1]\n      angle = Math.atan2(yPrev - yNext, xPrev - xNext)\n      var offset = (Math.atan(Math.pow(p * factor, 2) / widening) / 2 * width) + extraOffset\n      xLeft = x + -Math.sin(angle) * offset, yLeft = y + Math.cos(angle) * offset\n      riverPointsLeft.push({scX: xLeft, scY: yLeft})\n      xRight = x + Math.sin(angle) * offset, yRight = y + -Math.cos(angle) * offset\n      riverPointsRight.unshift({scX: xRight, scY: yRight})\n    }\n\n    // end point\n    x = points[last][0], y = points[last][1], c = points[last][2]\n    if (c) {extraOffset += Math.atan(c * 10 / widening)} // confluence\n    angle = Math.atan2(points[last - 1][1] - y, points[last - 1][0] - x)\n    xLeft = x + -Math.sin(angle) * offset, yLeft = y + Math.cos(angle) * offset\n    riverPointsLeft.push({scX: xLeft, scY: yLeft})\n    xRight = x + Math.sin(angle) * offset, yRight = y + -Math.cos(angle) * offset\n    riverPointsRight.unshift({scX: xRight, scY: yRight})\n\n    // generate path and return\n    const right = lineGen(riverPointsRight)\n    let left = lineGen(riverPointsLeft)\n    left = left.substring(left.indexOf('C'))\n    return round(right + left, 2)\n  }\n\n  // draw river polygon with best quality\n  function drawRiverSlow(points, width, increment) {\n    lineGen.curve(d3.curveCatmullRom.alpha(0.1))\n    width = width || 1\n    const extraOffset = 0.02 * width\n    increment = increment || 1\n    const riverPoints = points.map(function(p) {\n      return {scX: p[0], scY: p[1]}\n    })\n    const river = defs.append('path').attr('d', lineGen(riverPoints))\n    const riverLength = river.node().getTotalLength()\n    const widening = Math.round((1000 + (riverLength * 30)) * increment)\n    const riverPointsLeft = [], riverPointsRight = []\n\n    for (let l = 0; l < riverLength; l++) {\n      var point = river.node().getPointAtLength(l)\n      var from = river.node().getPointAtLength(l - 0.1)\n      const to = river.node().getPointAtLength(l + 0.1)\n      var angle = Math.atan2(from.y - to.y, from.x - to.x)\n      var offset = (Math.atan(Math.pow(l, 2) / widening) / 2 * width) + extraOffset\n      var xLeft = point.x + -Math.sin(angle) * offset\n      var yLeft = point.y + Math.cos(angle) * offset\n      riverPointsLeft.push({scX: xLeft, scY: yLeft})\n      var xRight = point.x + Math.sin(angle) * offset\n      var yRight = point.y + -Math.cos(angle) * offset\n      riverPointsRight.unshift({scX: xRight, scY: yRight})\n    }\n\n    var point = river.node().getPointAtLength(riverLength)\n    var from = river.node().getPointAtLength(riverLength - 0.1)\n    var angle = Math.atan2(from.y - point.y, from.x - point.x)\n    var offset = (Math.atan(Math.pow(riverLength, 2) / widening) / 2 * width) + extraOffset\n    var xLeft = point.x + -Math.sin(angle) * offset\n    var yLeft = point.y + Math.cos(angle) * offset\n    riverPointsLeft.push({scX: xLeft, scY: yLeft})\n    var xRight = point.x + Math.sin(angle) * offset\n    var yRight = point.y + -Math.cos(angle) * offset\n    riverPointsRight.unshift({scX: xRight, scY: yRight})\n\n    river.remove()\n    // generate path and return\n    const right = lineGen(riverPointsRight)\n    let left = lineGen(riverPointsLeft)\n    left = left.substring(left.indexOf('C'))\n    return round(right + left, 2)\n  }\n\n  // add lakes on depressed points on river course\n  function addLakes() {\n    console.time('addLakes')\n    let smallLakes = 0\n    for (let i = 0; i < land.length; i++) {\n      // elavate all big lakes\n      if (land[i].lake === 1) {\n        land[i].height = 19\n        land[i].ctype = -1\n      }\n      // define eligible small lakes\n      if (land[i].lake === 2 && smallLakes < 100) {\n        if (land[i].river !== undefined) {\n          land[i].height = 19\n          land[i].ctype = -1\n          land[i].fn = -1\n          smallLakes++\n        } else {\n          land[i].lake = undefined\n          land[i].neighbors.forEach(function(n) {\n            if (cells[n].lake !== 1 && cells[n].river !== undefined) {\n              cells[n].lake = 2\n              cells[n].height = 19\n              cells[n].ctype = -1\n              cells[n].fn = -1\n              smallLakes++\n            } else if (cells[n].lake === 2) {\n              cells[n].lake = undefined\n            }\n          })\n        }\n      }\n    }\n    console.log('small lakes: ' + smallLakes)\n\n    // mark small lakes\n    let unmarked = $.grep(land, function(e) {return e.fn === -1})\n    while (unmarked.length) {\n      let fn = -1, queue = [unmarked[0].index], lakeCells = []\n      unmarked[0].session = 'addLakes'\n      while (queue.length) {\n        const q = queue.pop()\n        lakeCells.push(q)\n        if (cells[q].fn !== -1) fn = cells[q].fn\n        cells[q].neighbors.forEach(function(e) {\n          if (cells[e].lake && cells[e].session !== 'addLakes') {\n            cells[e].session = 'addLakes'\n            queue.push(e)\n          }\n        })\n      }\n      if (fn === -1) {\n        fn = features.length\n        features.push({i: fn, land: false, border: false})\n      }\n      lakeCells.forEach(function(c) {cells[c].fn = fn})\n      unmarked = $.grep(land, function(e) {return e.fn === -1})\n    }\n\n    land = $.grep(cells, function(e) {return e.height >= 20})\n    console.timeEnd('addLakes')\n  }\n\n  function editLabel() {\n    if (customization) return\n\n    unselect()\n    closeDialogs('#labelEditor, .stable')\n    elSelected =\n      d3.select(this).call(d3.drag().on('start', elementDrag)).classed('draggable', true)\n\n    // update group parameters\n    let group = d3.select(this.parentNode)\n    updateGroupOptions()\n    labelGroupSelect.value = group.attr('id')\n    labelFontSelect.value = FONTS.indexOf(group.attr('data-font'))\n    labelSize.value = group.attr('data-size')\n    labelColor.value = toHEX(group.attr('fill'))\n    labelOpacity.value = group.attr('opacity')\n    labelText.value = elSelected.text()\n    const tr = parseTransform(elSelected.attr('transform'))\n    labelAngle.value = tr[2]\n    labelAngleValue.innerHTML = Math.abs(+tr[2]) + '°'\n\n    $('#labelEditor').dialog({\n      title: 'Edit Label: ' + labelText.value,\n      minHeight: 30, width: 'auto', maxWidth: 275, resizable: false,\n      position: {my: 'center top+10', at: 'bottom', of: this},\n      close: unselect\n    })\n\n    if (modules.editLabel) return\n    modules.editLabel = true\n\n    loadDefaultFonts()\n\n    function updateGroupOptions() {\n      labelGroupSelect.innerHTML = ''\n      labels.selectAll('g:not(#burgLabels)').each(function(d) {\n        if (this.parentNode.id === 'burgLabels') return\n        let id = d3.select(this).attr('id')\n        let opt = document.createElement('option')\n        opt.value = opt.innerHTML = id\n        labelGroupSelect.add(opt)\n      })\n    }\n\n    $('#labelGroupButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelGroupButtons').toggle()\n    })\n\n    // on group change\n    document.getElementById('labelGroupSelect').addEventListener('change', function() {\n      document.getElementById(this.value).appendChild(elSelected.remove().node())\n    })\n\n    // toggle inputs to declare a new group\n    document.getElementById('labelGroupNew').addEventListener('click', function() {\n      if ($('#labelGroupInput').css('display') === 'none') {\n        $('#labelGroupInput').css('display', 'inline-block')\n        $('#labelGroupSelect').css('display', 'none')\n        labelGroupInput.focus()\n      } else {\n        $('#labelGroupSelect').css('display', 'inline-block')\n        $('#labelGroupInput').css('display', 'none')\n      }\n    })\n\n    // toggle inputs to select a group\n    document.getElementById('labelExternalFont').addEventListener('click', function() {\n      if ($('#labelFontInput').css('display') === 'none') {\n        $('#labelFontInput').css('display', 'inline-block')\n        $('#labelFontSelect').css('display', 'none')\n        labelFontInput.focus()\n      } else {\n        $('#labelFontSelect').css('display', 'inline-block')\n        $('#labelFontInput').css('display', 'none')\n      }\n    })\n\n    // on new group creation\n    document.getElementById('labelGroupInput').addEventListener('change', function() {\n      if (!this.value) {\n        tip('Please provide a valid group name')\n        return\n      }\n      let group = this.value.toLowerCase().replace(/ /g, '_').replace(/[^\\w\\s]/gi, '')\n      if (Number.isFinite(+group.charAt(0))) group = 'g' + group\n      // if el with this id exists, add size to id\n      while (labels.selectAll('#' + group).size()) {group += '_new'}\n      createNewLabelGroup(group)\n    })\n\n    function createNewLabelGroup(g) {\n      let group = elSelected.node().parentNode.cloneNode(false)\n      let groupNew = labels.append(f => group).attr('id', g)\n      groupNew.append(f => elSelected.remove().node())\n      updateGroupOptions()\n      $('#labelGroupSelect, #labelGroupInput').toggle()\n      labelGroupInput.value = ''\n      labelGroupSelect.value = g\n      updateLabelGroups()\n    }\n\n    // remove label group on click\n    document.getElementById('labelGroupRemove').addEventListener('click', function() {\n      let group = d3.select(elSelected.node().parentNode)\n      let id = group.attr('id')\n      let count = group.selectAll('text').size()\n      // remove group with < 2 label without ask\n      if (count < 2) {\n        removeAllLabelsInGroup(id)\n        $('#labelEditor').dialog('close')\n        return\n      }\n      alertMessage.innerHTML =\n        'Are you sure you want to remove all labels (' + count + ') of that group?'\n      $('#alert').dialog({\n        resizable: false, title: 'Remove label group',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            removeAllLabelsInGroup(id)\n            $('#labelEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    $('#labelTextButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelTextButtons').toggle()\n    })\n\n    // on label text change\n    document.getElementById('labelText').addEventListener('input', function() {\n      if (!this.value) {\n        tip(\n          'Name should not be blank, set opacity to 0 to hide label or click remove button to delete')\n        return\n      }\n      // change Label text\n      if (elSelected.select('textPath').size()) elSelected.select('textPath').text(this.value)\n      else elSelected.text(this.value)\n      $('div[aria-describedby=\\'labelEditor\\'] .ui-dialog-title').text('Edit Label: ' + this.value)\n      // check if label is a country name\n      let id = elSelected.attr('id') || ''\n      if (id.includes('regionLabel')) {\n        let state = +elSelected.attr('id').slice(11)\n        states[state].name = this.value\n      }\n    })\n\n    // generate a random country name\n    document.getElementById('labelTextRandom').addEventListener('click', function() {\n      let name = elSelected.text()\n      let id = elSelected.attr('id') || ''\n      if (id.includes('regionLabel')) {\n        // label is a country name\n        let state = +elSelected.attr('id').slice(11)\n        name = generateStateName(state.i)\n        states[state].name = name\n      } else {\n        // label is not a country name, use random culture\n        let c = elSelected.node().getBBox()\n        let closest = cultureTree.find((c.x + c.width / 2), (c.y + c.height / 2))\n        let culture = Math.floor(Math.random() * cultures.length)\n        name = generateName(culture)\n      }\n      labelText.value = name\n      $('div[aria-describedby=\\'labelEditor\\'] .ui-dialog-title').text('Edit Label: ' + name)\n      // change Label text\n      if (elSelected.select('textPath').size()) elSelected.select('textPath').text(name)\n      else elSelected.text(name)\n    })\n\n    $('#labelFontButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelFontButtons').toggle()\n    })\n\n    // on label font change\n    document.getElementById('labelFontSelect').addEventListener('change', function() {\n      let group = elSelected.node().parentNode\n      let font = FONTS[this.value].split(':')[0].replace(/\\+/g, ' ')\n      group.setAttribute('font-family', font)\n      group.setAttribute('data-font', FONTS[this.value])\n    })\n\n    // on adding custom font\n    document.getElementById('labelFontInput').addEventListener('change', function() {\n      fetchFonts(this.value).then(fetched => {\n        if (!fetched) return\n        labelExternalFont.click()\n        labelFontInput.value = ''\n        if (fetched === 1) $('#labelFontSelect').val(FONTS.length - 1).change()\n      })\n    })\n\n    // on label size input\n    document.getElementById('labelSize').addEventListener('input', function() {\n      let group = elSelected.node().parentNode\n      let size = +this.value\n      group.setAttribute('data-size', size)\n      group.setAttribute('font-size', _.round((size + (size / scale)) / 2, 2))\n    })\n\n    $('#labelStyleButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelStyleButtons').toggle()\n    })\n\n    // on label fill color input\n    document.getElementById('labelColor').addEventListener('input', function() {\n      let group = elSelected.node().parentNode\n      group.setAttribute('fill', this.value)\n    })\n\n    // on label opacity input\n    document.getElementById('labelOpacity').addEventListener('input', function() {\n      let group = elSelected.node().parentNode\n      group.setAttribute('opacity', this.value)\n    })\n\n    $('#labelAngleButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelAngleButtons').toggle()\n    })\n\n    // on label angle input\n    document.getElementById('labelAngle').addEventListener('input', function() {\n      const tr = parseTransform(elSelected.attr('transform'))\n      labelAngleValue.innerHTML = Math.abs(+this.value) + '°'\n      const c = elSelected.node().getBBox()\n      const angle = +this.value\n      const transform = `translate(${tr[0]},${tr[1]}) rotate(${angle} ${(c.x + c.width / 2)} ${(c.y + c.height / 2)})`\n      elSelected.attr('transform', transform)\n    })\n\n    // display control points to curve label (place on path)\n    document.getElementById('labelCurve').addEventListener('click', function() {\n      let c = elSelected.node().getBBox()\n      let cx = c.x + c.width / 2, cy = c.y + c.height / 2\n\n      if (!elSelected.select('textPath').size()) {\n        let id = elSelected.attr('id')\n        let pathId = '#textPath_' + id\n        let path = `M${cx - c.width},${cy} q${c.width},0 ${c.width * 2},0`\n        let text = elSelected.text(), x = elSelected.attr('x'), y = elSelected.attr('y')\n        elSelected.text(null).attr('data-x', x).attr('data-y', y).attr('x', null).attr('y', null)\n        defs.append('path').attr('id', 'textPath_' + id).attr('d', path)\n        elSelected.append('textPath').attr('href', pathId).attr('startOffset', '50%').text(text)\n      }\n\n      if (!debug.select('circle').size()) {\n        debug.append('circle').attr('id', 'textPathControl').attr('r', 1.6)\n             .attr('cx', cx).attr('cy', cy)\n             .attr('transform', elSelected.attr('transform') || null)\n             .call(d3.drag().on('start', textPathControlDrag))\n      }\n    })\n\n    // drag textPath controle point to curve the label\n    function textPathControlDrag() {\n      let textPath = defs.select('#textPath_' + elSelected.attr('id'))\n      let path = textPath.attr('d').split(' ')\n      let M = path[0].split(',')\n      let q = path[1].split(',') // +q[1] to get qy - the only changeble value\n      let y = d3.event.y\n\n      d3.event.on('drag', function() {\n        let dy = d3.event.y - y\n        let total = +q[1] + dy * 8\n        d3.select(this).attr('cy', d3.event.y)\n        textPath.attr('d', `${M[0]},${+M[1] - dy} ${q[0]},${total} ${path[2]}`)\n      })\n    }\n\n    // cancel label curvature\n    document.getElementById('labelCurveCancel').addEventListener('click', function() {\n      if (!elSelected.select('textPath').size()) return\n      let text = elSelected.text(), x = elSelected.attr('data-x'), y = elSelected.attr('data-y')\n      elSelected.text()\n      elSelected.attr('x', x).attr('y', y).attr('data-x', null).attr('data-y', null).text(text)\n      defs.select('#textPath_' + elSelected.attr('id')).remove()\n      debug.select('circle').remove()\n    })\n\n    // open legendsEditor\n    document.getElementById('labelLegend').addEventListener('click', function() {\n      let id = elSelected.attr('id')\n      let name = elSelected.text()\n      editLegends(id, name)\n    })\n\n    // copy label on click\n    document.getElementById('labelCopy').addEventListener('click', function() {\n      let group = d3.select(elSelected.node().parentNode)\n      copy = group.append(f => elSelected.node().cloneNode(true))\n      let id = 'label' + Date.now().toString().slice(7)\n      copy.attr('id', id).attr('class', null).on('click', editLabel)\n      let shift = +group.attr('font-size') + 1\n      if (copy.select('textPath').size()) {\n        let path = defs.select('#textPath_' + elSelected.attr('id')).attr('d')\n        let textPath = defs.append('path').attr('id', 'textPath_' + id)\n        copy.select('textPath').attr('href', '#textPath_' + id)\n        let pathArray = path.split(' ')\n        let x = +pathArray[0].split(',')[0].slice(1)\n        let y = +pathArray[0].split(',')[1]\n        textPath.attr('d', `M${x - shift},${y - shift} ${pathArray[1]} ${pathArray[2]}`)\n        shift\n      } else {\n        let x = +elSelected.attr('x') - shift\n        let y = +elSelected.attr('y') - shift\n        while (group.selectAll('text[x=\\'' + x + '\\']').size()) {\n          x -= shift\n          y -= shift\n        }\n        copy.attr('x', x).attr('y', y)\n      }\n    })\n\n    // remove label on click\n    document.getElementById('labelRemoveSingle').addEventListener('click', function() {\n      alertMessage.innerHTML = 'Are you sure you want to remove the label?'\n      $('#alert').dialog({\n        resizable: false, title: 'Remove label',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            defs.select('#textPath_' + elSelected.attr('id')).remove()\n            $('#labelEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editRiver() {\n    if (customization) return\n    if (elSelected) {\n      const self = d3.select(this).attr('id') === elSelected.attr('id')\n      const point = d3.mouse(this)\n      if (elSelected.attr('data-river') === 'new') {\n        addRiverPoint([point[0], point[1]])\n        completeNewRiver()\n        return\n      } else if (self) {\n        riverAddControlPoint(point)\n        return\n      }\n    }\n\n    unselect()\n    closeDialogs('#riverEditor, .stable')\n    elSelected = d3.select(this)\n    elSelected.call(d3.drag().on('start', riverDrag))\n\n    const tr = parseTransform(elSelected.attr('transform'))\n    riverAngle.value = tr[2]\n    riverAngleValue.innerHTML = Math.abs(+tr[2]) + '°'\n    riverScale.value = tr[5]\n    riverWidthInput.value = +elSelected.attr('data-width')\n    riverIncrement.value = +elSelected.attr('data-increment')\n\n    $('#riverEditor').dialog({\n      title: 'Edit River',\n      minHeight: 30, width: 'auto', resizable: false,\n      position: {my: 'center top+20', at: 'top', of: d3.event},\n      close: function() {\n        if ($('#riverNew').hasClass('pressed')) completeNewRiver()\n        unselect()\n      }\n    })\n\n    if (!debug.select('.controlPoints').size()) debug.append('g').attr('class', 'controlPoints')\n    riverDrawPoints()\n\n    if (modules.editRiver) {return}\n    modules.editRiver = true\n\n    function riverAddControlPoint(point) {\n      let dists = []\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const x = +d3.select(this).attr('cx')\n        const y = +d3.select(this).attr('cy')\n        dists.push(Math.hypot(point[0] - x, point[1] - y))\n      })\n      let index = dists.length\n      if (dists.length > 1) {\n        const sorted = dists.slice(0).sort(function(a, b) {return a - b})\n        const closest = dists.indexOf(sorted[0])\n        const next = dists.indexOf(sorted[1])\n        if (closest <= next) {index = closest + 1} else {index = next + 1}\n      }\n      const before = ':nth-child(' + (index + 1) + ')'\n      debug.select('.controlPoints').insert('circle', before)\n           .attr('cx', point[0]).attr('cy', point[1]).attr('r', 0.35)\n           .call(d3.drag().on('drag', riverPointDrag))\n           .on('click', function(d) {\n             $(this).remove()\n             redrawRiver()\n           })\n      redrawRiver()\n    }\n\n    function riverDrawPoints() {\n      const node = elSelected.node()\n      // river is a polygon, so divide length by 2 to get course length\n      const l = node.getTotalLength() / 2\n      const parts = (l / 5) >> 0 // number of points\n      let inc = l / parts // increment\n      if (inc === Infinity) {inc = l} // 2 control points for short rivers\n      // draw control points\n      for (let i = l, c = l; i > 0; i -= inc, c += inc) {\n        const p1 = node.getPointAtLength(i)\n        const p2 = node.getPointAtLength(c)\n        const p = [(p1.x + p2.x) / 2, (p1.y + p2.y) / 2]\n        addRiverPoint(p)\n      }\n      // last point should be accurate\n      const lp1 = node.getPointAtLength(0)\n      const lp2 = node.getPointAtLength(l * 2)\n      const p = [(lp1.x + lp2.x) / 2, (lp1.y + lp2.y) / 2]\n      addRiverPoint(p)\n    }\n\n    function addRiverPoint(point) {\n      debug.select('.controlPoints').append('circle')\n           .attr('cx', point[0]).attr('cy', point[1]).attr('r', 0.35)\n           .call(d3.drag().on('drag', riverPointDrag))\n           .on('click', function(d) {\n             $(this).remove()\n             redrawRiver()\n           })\n    }\n\n    function riverPointDrag() {\n      d3.select(this).attr('cx', d3.event.x).attr('cy', d3.event.y)\n      redrawRiver()\n    }\n\n    function riverDrag() {\n      const x = d3.event.x, y = d3.event.y\n      const tr = parseTransform(elSelected.attr('transform'))\n      d3.event.on('drag', function() {\n        let xc = d3.event.x, yc = d3.event.y\n        let transform = `translate(${(+tr[0] + xc - x)},${(+tr[1] + yc - y)}) rotate(${tr[2]} ${tr[3]} ${tr[4]}) scale(${tr[5]})`\n        elSelected.attr('transform', transform)\n        debug.select('.controlPoints').attr('transform', transform)\n      })\n    }\n\n    function redrawRiver() {\n      let points = []\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const el = d3.select(this)\n        points.push([+el.attr('cx'), +el.attr('cy')])\n      })\n      const width = +riverWidthInput.value\n      const increment = +riverIncrement.value\n      const d = drawRiverSlow(points, width, increment)\n      elSelected.attr('d', d)\n    }\n\n    $('#riverWidthInput, #riverIncrement').change(function() {\n      const width = +riverWidthInput.value\n      const increment = +riverIncrement.value\n      elSelected.attr('data-width', width).attr('data-increment', increment)\n      redrawRiver()\n    })\n\n    $('#riverRegenerate').click(function() {\n      let points = [], amended = [], x, y, p1, p2\n      const node = elSelected.node()\n      const l = node.getTotalLength() / 2\n      const parts = (l / 8) >> 0 // number of points\n      let inc = l / parts // increment\n      if (inc === Infinity) {inc = l} // 2 control points for short rivers\n      for (let i = l, e = l; i > 0; i -= inc, e += inc) {\n        p1 = node.getPointAtLength(i)\n        p2 = node.getPointAtLength(e)\n        x = (p1.x + p2.x) / 2, y = (p1.y + p2.y) / 2\n        points.push([x, y])\n      }\n      // last point should be accurate\n      p1 = node.getPointAtLength(0)\n      p2 = node.getPointAtLength(l * 2)\n      x = (p1.x + p2.x) / 2, y = (p1.y + p2.y) / 2\n      points.push([x, y])\n      // amend points\n      const rndFactor = 0.3 + Math.random() * 1.4 // random factor in range 0.2-1.8\n      for (let i = 0; i < points.length; i++) {\n        x = points[i][0], y = points[i][1]\n        amended.push([x, y])\n        // add additional semi-random point\n        if (i + 1 < points.length) {\n          const x2 = points[i + 1][0], y2 = points[i + 1][1]\n          let side = Math.random() > 0.5 ? 1 : -1\n          const angle = Math.atan2(y2 - y, x2 - x)\n          const serpentine = 2 / (i + 1)\n          const meandr = serpentine + 0.3 + Math.random() * rndFactor\n          x = (x + x2) / 2, y = (y + y2) / 2\n          x += -Math.sin(angle) * meandr * side\n          y += Math.cos(angle) * meandr * side\n          amended.push([x, y])\n        }\n      }\n      const width = +riverWidthInput.value * 0.6 + Math.random()\n      const increment = +riverIncrement.value * 0.9 + Math.random() * 0.2\n      riverWidthInput.value = width\n      riverIncrement.value = increment\n      elSelected.attr('data-width', width).attr('data-increment', increment)\n      const d = drawRiverSlow(amended, width, increment)\n      elSelected.attr('d', d).attr('data-width', width).attr('data-increment', increment)\n      debug.select('.controlPoints').selectAll('*').remove()\n      amended.map(function(p) {addRiverPoint(p)})\n    })\n\n    $('#riverAngle').on('input', function() {\n      const tr = parseTransform(elSelected.attr('transform'))\n      riverAngleValue.innerHTML = Math.abs(+this.value) + '°'\n      const c = elSelected.node().getBBox()\n      const angle = +this.value, scale = +tr[5]\n      const transform = `translate(${tr[0]},${tr[1]}) rotate(${angle} ${(c.x + c.width / 2) * scale} ${(c.y + c.height / 2) * scale}) scale(${scale})`\n      elSelected.attr('transform', transform)\n      debug.select('.controlPoints').attr('transform', transform)\n    })\n\n    $('#riverReset').click(function() {\n      elSelected.attr('transform', '')\n      debug.select('.controlPoints').attr('transform', '')\n      riverAngle.value = 0\n      riverAngleValue.innerHTML = '0°'\n      riverScale.value = 1\n    })\n\n    $('#riverScale').change(function() {\n      const tr = parseTransform(elSelected.attr('transform'))\n      const scaleOld = +tr[5], scale = +this.value\n      const c = elSelected.node().getBBox()\n      const cx = c.x + c.width / 2, cy = c.y + c.height / 2\n      const trX = +tr[0] + cx * (scaleOld - scale)\n      const trY = +tr[1] + cy * (scaleOld - scale)\n      const scX = +tr[3] * scale / scaleOld\n      const scY = +tr[4] * scale / scaleOld\n      const transform = `translate(${trX},${trY}) rotate(${tr[2]} ${scX} ${scY}) scale(${scale})`\n      elSelected.attr('transform', transform)\n      debug.select('.controlPoints').attr('transform', transform)\n    })\n\n    $('#riverNew').click(function() {\n      if ($(this).hasClass('pressed')) {\n        completeNewRiver()\n      } else {\n        // enter creation mode\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        if (elSelected) elSelected.call(d3.drag().on('drag', null))\n        debug.select('.controlPoints').selectAll('*').remove()\n        viewbox.style('cursor', 'crosshair').on('click', newRiverAddPoint)\n      }\n    })\n\n    function newRiverAddPoint() {\n      const point = d3.mouse(this)\n      addRiverPoint([point[0], point[1]])\n      if (!elSelected || elSelected.attr('data-river') !== 'new') {\n        const id = +$('#rivers > path').last().attr('id').slice(5) + 1\n        elSelected = rivers.append('path').attr('data-river', 'new').attr('id', 'river' + id)\n                           .attr('data-width', 2).attr('data-increment', 1)\n                           .on('click', completeNewRiver)\n      } else {\n        redrawRiver()\n        let cell = diagram.find(point[0], point[1]).index\n        let f = cells[cell].fn\n        let ocean = !features[f].land && features[f].border\n        if (ocean && debug.select('.controlPoints').selectAll('circle')\n                          .size() > 5) completeNewRiver()\n      }\n    }\n\n    function completeNewRiver() {\n      $('#riverNew').removeClass('pressed')\n      restoreDefaultEvents()\n      if (!elSelected || elSelected.attr('data-river') !== 'new') return\n      redrawRiver()\n      elSelected.attr('data-river', '')\n      elSelected.call(d3.drag().on('start', riverDrag)).on('click', editRiver)\n      const r = +elSelected.attr('id').slice(5)\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const x = +d3.select(this).attr('cx')\n        const y = +d3.select(this).attr('cy')\n        const cell = diagram.find(x, y, 3)\n        if (!cell) return\n        if (cells[cell.index].river === undefined) cells[cell.index].river = r\n      })\n      unselect()\n      debug.append('g').attr('class', 'controlPoints')\n    }\n\n    $('#riverCopy').click(function() {\n      const tr = parseTransform(elSelected.attr('transform'))\n      const d = elSelected.attr('d')\n      let x = 2, y = 2\n      let transform = `translate(${tr[0] - x},${tr[1] - y}) rotate(${tr[2]} ${tr[3]} ${tr[4]}) scale(${tr[5]})`\n      while (rivers.selectAll('[transform=\\'' + transform + '\\'][d=\\'' + d + '\\']').size() > 0) {\n        x += 2\n        y += 2\n        transform =\n          `translate(${tr[0] - x},${tr[1] - y}) rotate(${tr[2]} ${tr[3]} ${tr[4]}) scale(${tr[5]})`\n      }\n      const river = +$('#rivers > path').last().attr('id').slice(5) + 1\n      rivers.append('path').attr('d', d)\n            .attr('transform', transform)\n            .attr('id', 'river' + river).on('click', editRiver)\n            .attr('data-width', elSelected.attr('data-width'))\n            .attr('data-increment', elSelected.attr('data-increment'))\n      unselect()\n    })\n\n    // open legendsEditor\n    document.getElementById('riverLegend').addEventListener('click', function() {\n      let id = elSelected.attr('id')\n      editLegends(id, id)\n    })\n\n    $('#riverRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the river?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove river',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            const river = +elSelected.attr('id').slice(5)\n            const avPrec = _.round(precInput.value / Math.sqrt(cells.length), 2)\n            land.map(function(l) {\n              if (l.river === river) {\n                l.river = undefined\n                l.flux = avPrec\n              }\n            })\n            elSelected.remove()\n            unselect()\n            $('#riverEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n  }\n\n  function editRoute() {\n    if (customization) {return}\n    if (elSelected) {\n      const self = d3.select(this).attr('id') === elSelected.attr('id')\n      const point = d3.mouse(this)\n      if (elSelected.attr('data-route') === 'new') {\n        addRoutePoint({x: point[0], y: point[1]})\n        completeNewRoute()\n        return\n      } else if (self) {\n        routeAddControlPoint(point)\n        return\n      }\n    }\n\n    unselect()\n    closeDialogs('#routeEditor, .stable')\n\n    if (this && this !== window) {\n      elSelected = d3.select(this)\n      if (!debug.select('.controlPoints').size()) debug.append('g')\n                                                       .attr('class', 'controlPoints')\n      routeDrawPoints()\n      routeUpdateGroups()\n      let routeType = d3.select(this.parentNode).attr('id')\n      routeGroup.value = routeType\n\n      $('#routeEditor').dialog({\n        title: 'Edit Route',\n        minHeight: 30, width: 'auto', resizable: false,\n        position: {my: 'center top+20', at: 'top', of: d3.event},\n        close: function() {\n          if ($('#addRoute').hasClass('pressed')) completeNewRoute()\n          if ($('#routeSplit').hasClass('pressed')) $('#routeSplit').removeClass('pressed')\n          unselect()\n        }\n      })\n    } else {elSelected = null}\n\n    if (modules.editRoute) {return}\n    modules.editRoute = true\n\n    function routeAddControlPoint(point) {\n      let dists = []\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const x = +d3.select(this).attr('cx')\n        const y = +d3.select(this).attr('cy')\n        dists.push(Math.hypot(point[0] - x, point[1] - y))\n      })\n      let index = dists.length\n      if (dists.length > 1) {\n        const sorted = dists.slice(0).sort(function(a, b) {return a - b})\n        const closest = dists.indexOf(sorted[0])\n        const next = dists.indexOf(sorted[1])\n        if (closest <= next) {index = closest + 1} else {index = next + 1}\n      }\n      const before = ':nth-child(' + (index + 1) + ')'\n      debug.select('.controlPoints').insert('circle', before)\n           .attr('cx', point[0]).attr('cy', point[1]).attr('r', 0.35)\n           .call(d3.drag().on('drag', routePointDrag))\n           .on('click', function(d) {\n             $(this).remove()\n             routeRedraw()\n           })\n      routeRedraw()\n    }\n\n    function routeDrawPoints() {\n      if (!elSelected.size()) return\n      const node = elSelected.node()\n      const l = node.getTotalLength()\n      const parts = (l / 5) >> 0 // number of points\n      let inc = l / parts // increment\n      if (inc === Infinity) inc = l // 2 control points for short routes\n      // draw control points\n      for (let i = 0; i <= l; i += inc) {\n        const p = node.getPointAtLength(i)\n        addRoutePoint(p)\n      }\n      // convert length to distance\n      routeLength.innerHTML = Math.round(l * distanceScale.value) + ' ' + distanceUnit.value\n    }\n\n    function addRoutePoint(point) {\n      const controlPoints = debug.select('.controlPoints').size()\n                            ? debug.select('.controlPoints')\n                            : debug.append('g').attr('class', 'controlPoints')\n      controlPoints.append('circle')\n                   .attr('cx', point.x).attr('cy', point.y).attr('r', 0.35)\n                   .call(d3.drag().on('drag', routePointDrag))\n                   .on('click', function(d) {\n                     if ($('#routeSplit').hasClass('pressed')) {\n                       routeSplitInPoint(this)\n                     } else {\n                       $(this).remove()\n                       routeRedraw()\n                     }\n                   })\n    }\n\n    function routePointDrag() {\n      d3.select(this).attr('cx', d3.event.x).attr('cy', d3.event.y)\n      routeRedraw()\n    }\n\n    function routeRedraw() {\n      let points = []\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const el = d3.select(this)\n        points.push({scX: +el.attr('cx'), scY: +el.attr('cy')})\n      })\n      lineGen.curve(d3.curveCatmullRom.alpha(0.1))\n      elSelected.attr('d', lineGen(points))\n      // get route distance\n      const l = elSelected.node().getTotalLength()\n      routeLength.innerHTML = Math.round(l * distanceScale.value) + ' ' + distanceUnit.value\n    }\n\n    function addNewRoute() {\n      let routeType = elSelected && elSelected.node() ? elSelected.node().parentNode.id :\n                      'searoutes'\n      const group = routes.select('#' + routeType)\n      const id = routeType + '' + group.selectAll('*').size()\n      elSelected =\n        group.append('path').attr('data-route', 'new').attr('id', id).on('click', editRoute)\n      routeUpdateGroups()\n      $('#routeEditor').dialog({\n        title: 'Edit Route', minHeight: 30, width: 'auto', resizable: false,\n        close: function() {\n          if ($('#addRoute').hasClass('pressed')) completeNewRoute()\n          if ($('#routeSplit').hasClass('pressed')) $('#routeSplit').removeClass('pressed')\n          unselect()\n        }\n      })\n    }\n\n    function newRouteAddPoint() {\n      const point = d3.mouse(this)\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n      addRoutePoint({x, y})\n      routeRedraw()\n    }\n\n    function completeNewRoute() {\n      $('#routeNew, #addRoute').removeClass('pressed')\n      restoreDefaultEvents()\n      if (!elSelected.size()) return\n      if (elSelected.attr('data-route') === 'new') {\n        routeRedraw()\n        elSelected.attr('data-route', '')\n        const node = elSelected.node()\n        const l = node.getTotalLength()\n        let pathCells = []\n        for (let i = 0; i <= l; i++) {\n          const p = node.getPointAtLength(i)\n          const cell = diagram.find(p.x, p.y)\n          if (!cell) {return}\n          pathCells.push(cell.index)\n        }\n        const uniqueCells = [...new Set(pathCells)]\n        uniqueCells.map(function(c) {\n          if (cells[c].path !== undefined) {cells[c].path += 1} else {cells[c].path = 1}\n        })\n      }\n      tip('', true)\n    }\n\n    function routeUpdateGroups() {\n      routeGroup.innerHTML = ''\n      routes.selectAll('g').each(function() {\n        const opt = document.createElement('option')\n        opt.value = opt.innerHTML = this.id\n        routeGroup.add(opt)\n      })\n    }\n\n    function routeSplitInPoint(clicked) {\n      const group = d3.select(elSelected.node().parentNode)\n      $('#routeSplit').removeClass('pressed')\n      const points1 = [], points2 = []\n      let points = points1\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const el = d3.select(this)\n        points.push({scX: +el.attr('cx'), scY: +el.attr('cy')})\n        if (this === clicked) {\n          points = points2\n          points.push({scX: +el.attr('cx'), scY: +el.attr('cy')})\n        }\n        el.remove()\n      })\n      lineGen.curve(d3.curveCatmullRom.alpha(0.1))\n      elSelected.attr('d', lineGen(points1))\n      const id = routeGroup.value + '' + group.selectAll('*').size()\n      group.append('path').attr('id', id).attr('d', lineGen(points2)).on('click', editRoute)\n      routeDrawPoints()\n    }\n\n    $('#routeGroup').change(function() {\n      $(elSelected.node()).detach().appendTo($('#' + this.value))\n    })\n\n    // open legendsEditor\n    document.getElementById('routeLegend').addEventListener('click', function() {\n      let id = elSelected.attr('id')\n      editLegends(id, id)\n    })\n\n    $('#routeNew').click(function() {\n      if ($(this).hasClass('pressed')) {\n        completeNewRoute()\n      } else {\n        // enter creation mode\n        $('.pressed').removeClass('pressed')\n        $('#routeNew, #addRoute').addClass('pressed')\n        debug.select('.controlPoints').selectAll('*').remove()\n        addNewRoute()\n        viewbox.style('cursor', 'crosshair').on('click', newRouteAddPoint)\n        tip('Click on map to add route point', true)\n      }\n    })\n\n    $('#routeRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the route?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove route',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            $('#routeEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editIcon() {\n    if (customization) return\n    if (elSelected) if (this.isSameNode(elSelected.node())) return\n\n    unselect()\n    closeDialogs('#iconEditor, .stable')\n    elSelected =\n      d3.select(this).call(d3.drag().on('start', elementDrag)).classed('draggable', true)\n\n    // update group parameters\n    const group = d3.select(this.parentNode)\n    iconUpdateGroups()\n    iconGroup.value = group.attr('id')\n    iconFillColor.value = group.attr('fill')\n    iconStrokeColor.value = group.attr('stroke')\n    iconSize.value = group.attr('size')\n    iconStrokeWidth.value = group.attr('stroke-width')\n\n    $('#iconEditor').dialog({\n      title: 'Edit icon: ' + group.attr('id'),\n      minHeight: 30, width: 'auto', resizable: false,\n      position: {my: 'center top+20', at: 'top', of: d3.event},\n      close: unselect\n    })\n\n    if (modules.editIcon) {return}\n    modules.editIcon = true\n\n    $('#iconGroups').click(function() {\n      $('#iconEditor > button').not(this).toggle()\n      $('#iconGroupsSelection').toggle()\n    })\n\n    function iconUpdateGroups() {\n      iconGroup.innerHTML = ''\n      const anchor = group.attr('id').includes('anchor')\n      icons.selectAll('g').each(function(d) {\n        const id = d3.select(this).attr('id')\n        if (id === 'burgs') return\n        if (!anchor && id.includes('anchor')) return\n        if (anchor && !id.includes('anchor')) return\n        const opt = document.createElement('option')\n        opt.value = opt.innerHTML = id\n        iconGroup.add(opt)\n      })\n    }\n\n    $('#iconGroup').change(function() {\n      const newGroup = this.value\n      const to = $('#icons > #' + newGroup)\n      $(elSelected.node()).detach().appendTo(to)\n    })\n\n    $('#iconCopy').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const copy = elSelected.node().cloneNode()\n      copy.removeAttribute('data-id') // remove assignment to burg if any\n      const tr = parseTransform(copy.getAttribute('transform'))\n      const shift = 10 / Math.sqrt(scale)\n      let transform = 'translate(' + _.round(tr[0] - shift, 1) + ',' + _.round(tr[1] - shift, 1) + ')'\n      for (let i = 2; group.selectAll(\"[transform='\" + transform + \"']\").size() > 0; i++) {\n        transform =\n          'translate(' + _.round(tr[0] - shift * i, 1) + ',' + _.round(tr[1] - shift * i, 1) + ')'\n      }\n      copy.setAttribute('transform', transform)\n      group.node().insertBefore(copy, null)\n      copy.addEventListener('click', editIcon)\n    })\n\n    $('#iconRemoveGroup').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const count = group.selectAll('*').size()\n      if (count < 2) {\n        group.remove()\n        $('#labelEditor').dialog('close')\n        return\n      }\n      const message = 'Are you sure you want to remove all \\'' + iconGroup.value + '\\' icons (' + count + ')?'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Remove icon group',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            group.remove()\n            $('#iconEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    $('#iconColors').click(function() {\n      $('#iconEditor > button').not(this).toggle()\n      $('#iconColorsSection').toggle()\n    })\n\n    $('#iconFillColor').change(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      group.attr('fill', this.value)\n    })\n\n    $('#iconStrokeColor').change(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      group.attr('stroke', this.value)\n    })\n\n    $('#iconSetSize').click(function() {\n      $('#iconEditor > button').not(this).toggle()\n      $('#iconSizeSection').toggle()\n    })\n\n    $('#iconSize').change(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const size = +this.value\n      group.attr('size', size)\n      group.selectAll('*')\n           .each(function() {d3.select(this).attr('width', size).attr('height', size)})\n    })\n\n    $('#iconStrokeWidth').change(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      group.attr('stroke-width', this.value)\n    })\n\n    $('#iconRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the icon?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove icon',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            $('#iconEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editReliefIcon() {\n    if (customization) return\n    if (elSelected) if (this.isSameNode(elSelected.node())) return\n\n    unselect()\n    closeDialogs('#reliefEditor, .stable')\n    elSelected =\n      d3.select(this).raise().call(d3.drag().on('start', elementDrag)).classed('draggable', true)\n    const group = elSelected.node().parentNode.id\n    reliefGroup.value = group\n\n    let bulkRemoveSection = document.getElementById('reliefBulkRemoveSection')\n    if (bulkRemoveSection.style.display != 'none') reliefBulkRemove.click()\n\n    $('#reliefEditor').dialog({\n      title: 'Edit relief icon',\n      minHeight: 30, width: 'auto', resizable: false,\n      position: {my: 'center top+40', at: 'top', of: d3.event},\n      close: unselect\n    })\n\n    if (modules.editReliefIcon) {return}\n    modules.editReliefIcon = true\n\n    $('#reliefGroups').click(function() {\n      $('#reliefEditor > button').not(this).toggle()\n      $('#reliefGroupsSelection').toggle()\n    })\n\n    $('#reliefGroup').change(function() {\n      const type = this.value\n      const bbox = elSelected.node().getBBox()\n      const cx = bbox.x\n      const cy = bbox.y + bbox.height / 2\n      const cell = diagram.find(cx, cy).index\n      const height = cell !== undefined ? cells[cell].height : 50\n      elSelected.remove()\n      elSelected = addReliefIcon(height / 100, type, cx, cy, cell)\n      elSelected.call(d3.drag().on('start', elementDrag))\n    })\n\n    $('#reliefCopy').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const copy = elSelected.node().cloneNode(true)\n      const tr = parseTransform(copy.getAttribute('transform'))\n      const shift = 10 / Math.sqrt(scale)\n      let transform = 'translate(' + _.round(tr[0] - shift, 1) + ',' + _.round(tr[1] - shift, 1) + ')'\n      for (let i = 2; group.selectAll(\"[transform='\" + transform + \"']\").size() > 0; i++) {\n        transform =\n          'translate(' + _.round(tr[0] - shift * i, 1) + ',' + _.round(tr[1] - shift * i, 1) + ')'\n      }\n      copy.setAttribute('transform', transform)\n      group.node().insertBefore(copy, null)\n      copy.addEventListener('click', editReliefIcon)\n    })\n\n    $('#reliefAddfromEditor').click(function() {\n      clickToAdd() // to load on click event function\n      $('#addRelief').click()\n    })\n\n    $('#reliefRemoveGroup').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const count = group.selectAll('*').size()\n      if (count < 2) {\n        group.selectAll('*').remove()\n        $('#labelEditor').dialog('close')\n        return\n      }\n      const message = 'Are you sure you want to remove all \\'' + reliefGroup.value + '\\' icons (' + count + ')?'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Remove all icons within group',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            group.selectAll('*').remove()\n            $('#reliefEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    $('#reliefBulkRemove').click(function() {\n      $('#reliefEditor > button').not(this).toggle()\n      let section = document.getElementById('reliefBulkRemoveSection')\n      if (section.style.display === 'none') {\n        section.style.display = 'inline-block'\n        tip('Drag to remove relief icons in radius', true)\n        viewbox.style('cursor', 'crosshair').call(d3.drag().on('drag', dragToRemoveReliefIcons))\n        customization = 5\n      } else {\n        section.style.display = 'none'\n        restoreDefaultEvents()\n        customization = 0\n      }\n    })\n\n    function dragToRemoveReliefIcons() {\n      let point = d3.mouse(this)\n      let cell = diagram.find(point[0], point[1]).index\n      let radius = +reliefBulkRemoveRadius.value\n      let r = Math.round(6 / graphSize * radius, 1)\n      moveCircle(point[0], point[1], r)\n      let selection = defineBrushSelection(cell, radius)\n      if (selection) removeReliefIcons(selection)\n    }\n\n    function removeReliefIcons(selection) {\n      if (selection.length === 0) return\n      selection.map(function(index) {\n        const selected = terrain.selectAll('g').selectAll('g[data-cell=\\'' + index + '\\']')\n        selected.remove()\n      })\n    }\n\n    $('#reliefRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the icon?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove relief icon',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            $('#reliefEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editBurg() {\n    if (customization) return\n    unselect()\n    closeDialogs('#burgEditor, .stable')\n    elSelected = d3.select(this)\n    const id = +elSelected.attr('data-id')\n    if (id === undefined) return\n    d3.selectAll('[data-id=\\'' + id + '\\']').call(d3.drag().on('start', elementDrag))\n      .classed('draggable', true)\n\n    // update Burg details\n    const type = elSelected.node().parentNode.id\n    const labelGroup = burgLabels.select('#' + type)\n    const iconGroup = burgIcons.select('#' + type)\n    burgNameInput.value = manors[id].name\n    updateBurgsGroupOptions()\n    burgSelectGroup.value = labelGroup.attr('id')\n    burgSelectDefaultFont.value = FONTS.indexOf(labelGroup.attr('data-font'))\n    burgSetLabelSize.value = labelGroup.attr('data-size')\n    burgLabelColorInput.value = toHEX(labelGroup.attr('fill'))\n    burgLabelOpacity.value =\n      labelGroup.attr('opacity') === undefined ? 1 : +labelGroup.attr('opacity')\n    const tr = parseTransform(elSelected.attr('transform'))\n    burgLabelAngle.value = tr[2]\n    burgLabelAngleOutput.innerHTML = Math.abs(+tr[2]) + '°'\n    burgIconSize.value = iconGroup.attr('size')\n    burgIconFillOpacity.value =\n      iconGroup.attr('fill-opacity') === undefined ? 1 : +iconGroup.attr('fill-opacity')\n    burgIconFillColor.value = iconGroup.attr('fill')\n    burgIconStrokeWidth.value = iconGroup.attr('stroke-width')\n    burgIconStrokeOpacity.value =\n      iconGroup.attr('stroke-opacity') === undefined ? 1 : +iconGroup.attr('stroke-opacity')\n    burgIconStrokeColor.value = iconGroup.attr('stroke')\n    const cell = cells[manors[id].cell]\n    if (cell.region !== 'neutral' && cell.region !== undefined) {\n      burgToggleCapital.disabled = false\n      const capital = states[manors[id].region] ?\n                      id === states[manors[id].region].capital ? 1 : 0 : 0\n      d3.select('#burgToggleCapital').classed('pressed', capital)\n    } else {\n      burgToggleCapital.disabled = true\n      d3.select('#burgToggleCapital').classed('pressed', false)\n    }\n    d3.select('#burgTogglePort').classed('pressed', cell.port !== undefined)\n    burgPopulation.value = manors[id].population\n    burgPopulationFriendly.value =\n      Math.round(manors[id].population * urbanization.value * populationRate.value * 1000)\n\n    $('#burgEditor').dialog({\n      title: 'Edit Burg: ' + manors[id].name,\n      minHeight: 30, width: 'auto', resizable: false,\n      position: {my: 'center top+40', at: 'top', of: d3.event},\n      close: function() {\n        d3.selectAll('[data-id=\\'' + id + '\\']').call(d3.drag().on('drag', null))\n          .classed('draggable', false)\n        elSelected = null\n      }\n    })\n\n    if (modules.editBurg) return\n    modules.editBurg = true\n\n    loadDefaultFonts()\n\n    function updateBurgsGroupOptions() {\n      burgSelectGroup.innerHTML = ''\n      burgIcons.selectAll('g').each(function(d) {\n        const opt = document.createElement('option')\n        opt.value = opt.innerHTML = d3.select(this).attr('id')\n        burgSelectGroup.add(opt)\n      })\n    }\n\n    $('#burgEditor > button').not('#burgAddfromEditor').not('#burgRelocate').not('#burgRemove')\n                             .click(function() {\n                               if ($(this).next().is(':visible')) {\n                                 $('#burgEditor > button').show()\n                                 $(this).next('div').hide()\n                               } else {\n                                 $('#burgEditor > *').not(this).hide()\n                                 $(this).next('div').show()\n                               }\n                             })\n\n    $('#burgEditor > div > button').click(function() {\n      if ($(this).next().is(':visible')) {\n        $('#burgEditor > div > button').show()\n        $(this).parent().prev().show()\n        $(this).next('div').hide()\n      } else {\n        $('#burgEditor > div > button').not(this).hide()\n        $(this).parent().prev().hide()\n        $(this).next('div').show()\n      }\n    })\n\n    $('#burgSelectGroup').change(function() {\n      const id = +elSelected.attr('data-id')\n      const g = this.value\n      moveBurgToGroup(id, g)\n    })\n\n    $('#burgInputGroup').change(function() {\n      let newGroup = this.value.toLowerCase().replace(/ /g, '_').replace(/[^\\w\\s]/gi, '')\n      if (Number.isFinite(+newGroup.charAt(0))) newGroup = 'g' + newGroup\n      if (burgLabels.select('#' + newGroup).size()) {\n        tip('The group \"' + newGroup + '\" is already exists')\n        return\n      }\n      burgInputGroup.value = ''\n      // clone old group assigning new id\n      const id = elSelected.node().parentNode.id\n      const l = burgLabels.select('#' + id).node().cloneNode(false)\n      l.id = newGroup\n      const i = burgIcons.select('#' + id).node().cloneNode(false)\n      i.id = newGroup\n      burgLabels.node().insertBefore(l, null)\n      burgIcons.node().insertBefore(i, null)\n      // select new group\n      const opt = document.createElement('option')\n      opt.value = opt.innerHTML = newGroup\n      burgSelectGroup.add(opt)\n      $('#burgSelectGroup').val(newGroup).change()\n      $('#burgSelectGroup, #burgInputGroup').toggle()\n      updateLabelGroups()\n    })\n\n    $('#burgAddGroup').click(function() {\n      if ($('#burgInputGroup').css('display') === 'none') {\n        $('#burgInputGroup').css('display', 'inline-block')\n        $('#burgSelectGroup').css('display', 'none')\n        burgInputGroup.focus()\n      } else {\n        $('#burgSelectGroup').css('display', 'inline-block')\n        $('#burgInputGroup').css('display', 'none')\n      }\n    })\n\n    $('#burgRemoveGroup').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const type = group.attr('id')\n      const id = +elSelected.attr('data-id')\n      const count = group.selectAll('*').size()\n      const message = 'Are you sure you want to remove all Burgs (' + count + ') of that group?'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Remove Burgs',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            group.selectAll('*').each(function(d) {\n              const id = +d3.select(this).attr('data-id')\n              if (id === undefined) return\n              const cell = manors[id].cell\n              const state = manors[id].region\n              if (states[state]) {\n                if (states[state].capital === id) states[state].capital = 'select'\n                states[state].burgs--\n              }\n              manors[id].region = 'removed'\n              cells[cell].manor = undefined\n            })\n            burgLabels.select('#' + type).selectAll('*').remove()\n            burgIcons.select('#' + type).selectAll('*').remove()\n            $('#icons g[id*=\\'anchors\\'] [data-id=' + id + ']').parent().children().remove()\n            closeDialogs('.stable')\n            updateCountryEditors()\n            $('#burgEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n\n    })\n\n    $('#burgNameInput').on('input', function() {\n      if (this.value === '') {\n        tip(\n          'Name should not be blank, set opacity to 0 to hide label or remove button to delete')\n        return\n      }\n      const id = +elSelected.attr('data-id')\n      burgLabels.selectAll('[data-id=\\'' + id + '\\']').text(this.value)\n      manors[id].name = this.value\n      $('div[aria-describedby=\\'burgEditor\\'] .ui-dialog-title').text('Edit Burg: ' + this.value)\n    })\n\n    $('#burgNameReCulture, #burgNameReRandom').click(function() {\n      const id = +elSelected.attr('data-id')\n      const culture = this.id === 'burgNameReCulture' ? manors[id].culture :\n                      Math.floor(Math.random() * cultures.length)\n      const name = generateName(culture)\n      burgLabels.selectAll('[data-id=\\'' + id + '\\']').text(name)\n      manors[id].name = name\n      burgNameInput.value = name\n      $('div[aria-describedby=\\'burgEditor\\'] .ui-dialog-title').text('Edit Burg: ' + name)\n    })\n\n    $('#burgToggleExternalFont').click(function() {\n      if ($('#burgInputExternalFont').css('display') === 'none') {\n        $('#burgInputExternalFont').css('display', 'inline-block')\n        $('#burgSelectDefaultFont').css('display', 'none')\n        burgInputExternalFont.focus()\n      } else {\n        $('#burgSelectDefaultFont').css('display', 'inline-block')\n        $('#burgInputExternalFont').css('display', 'none')\n      }\n    })\n\n    $('#burgSelectDefaultFont').change(function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgLabels.select('#' + type)\n      if (burgSelectDefaultFont.value === '') return\n      const font = FONTS[burgSelectDefaultFont.value].split(':')[0].replace(/\\+/g, ' ')\n      group.attr('font-family', font).attr('data-font', FONTS[burgSelectDefaultFont.value])\n    })\n\n    $('#burgInputExternalFont').change(function() {\n      fetchFonts(this.value).then(fetched => {\n        if (!fetched) return\n        burgToggleExternalFont.click()\n        burgInputExternalFont.value = ''\n        if (fetched === 1) $('#burgSelectDefaultFont').val(FONTS.length - 1).change()\n      })\n    })\n\n    $('#burgSetLabelSize').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgLabels.select('#' + type)\n      group.attr('data-size', +this.value)\n      invokeActiveZooming()\n    })\n\n    $('#burgLabelColorInput').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgLabels.select('#' + type)\n      group.attr('fill', this.value)\n    })\n\n    $('#burgLabelOpacity').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgLabels.select('#' + type)\n      group.attr('opacity', +this.value)\n    })\n\n    $('#burgLabelAngle').on('input', function() {\n      const id = +elSelected.attr('data-id')\n      const el = burgLabels.select('[data-id=\\'' + id + '\\']')\n      const tr = parseTransform(el.attr('transform'))\n      const c = el.node().getBBox()\n      burgLabelAngleOutput.innerHTML = Math.abs(+this.value) + '°'\n      const angle = +this.value\n      const transform = `translate(${tr[0]},${tr[1]}) rotate(${angle} ${(c.x + c.width / 2)} ${(c.y + c.height / 2)})`\n      el.attr('transform', transform)\n    })\n\n    $('#burgIconSize').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      const size = +this.value\n      group.attr('size', size)\n      group.selectAll('*').each(function() {d3.select(this).attr('r', size)})\n    })\n\n    $('#burgIconFillOpacity').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('fill-opacity', +this.value)\n    })\n\n    $('#burgIconFillColor').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('fill', this.value)\n    })\n\n    $('#burgIconStrokeWidth').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('stroke-width', +this.value)\n    })\n\n    $('#burgIconStrokeOpacity').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('stroke-opacity', +this.value)\n    })\n\n    $('#burgIconStrokeColor').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('stroke', this.value)\n    })\n\n    $('#burgToggleCapital').click(function() {\n      const id = +elSelected.attr('data-id')\n      const state = manors[id].region\n      if (states[state] === undefined) return\n      const capital = states[manors[id].region] ?\n                      id === states[manors[id].region].capital ? 0 : 1 : 1\n      if (capital && states[state].capital !== 'select') {\n        // move oldCapital to a town group\n        const oldCapital = states[state].capital\n        moveBurgToGroup(oldCapital, 'towns')\n      }\n      states[state].capital = capital ? id : 'select'\n      d3.select('#burgToggleCapital').classed('pressed', capital)\n      const g = capital ? 'capitals' : 'towns'\n      moveBurgToGroup(id, g)\n    })\n\n    $('#burgTogglePort').click(function() {\n      const id = +elSelected.attr('data-id')\n      const cell = cells[manors[id].cell]\n      const markAsPort = cell.port === undefined ? true : undefined\n      cell.port = markAsPort\n      d3.select('#burgTogglePort').classed('pressed', markAsPort)\n      if (markAsPort) {\n        const type = elSelected.node().parentNode.id\n        const ag = type === 'capitals' ? '#capital-anchors' : '#town-anchors'\n        const group = icons.select(ag)\n        const size = +group.attr('size')\n        const x = _.round(manors[id].x - size * 0.47, 2)\n        const y = _.round(manors[id].y - size * 0.47, 2)\n        group.append('use').attr('xlink:href', '#icon-anchor').attr('data-id', id)\n             .attr('x', x).attr('y', y).attr('width', size).attr('height', size)\n             .on('click', editIcon)\n      } else {\n        $('#icons g[id*=\\'anchors\\'] [data-id=' + id + ']').remove()\n      }\n    })\n\n    $('#burgPopulation').on('input', function() {\n      const id = +elSelected.attr('data-id')\n      burgPopulationFriendly.value =\n        Math.round(this.value * urbanization.value * populationRate.value * 1000)\n      manors[id].population = +this.value\n    })\n\n    $('#burgRelocate').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n        tip('', true)\n      } else {\n        $('.pressed').removeClass('pressed')\n        const id = elSelected.attr('data-id')\n        $(this).addClass('pressed').attr('data-id', id)\n        viewbox.style('cursor', 'crosshair').on('click', relocateBurgOnClick)\n        tip('Click on map to relocate burg. Hold Shift for continuous move', true)\n      }\n    })\n\n    // open legendsEditor\n    document.getElementById('burglLegend').addEventListener('click', function() {\n      let burg = +elSelected.attr('data-id')\n      let id = 'burg' + burg\n      let name = manors[burg].name\n      editLegends(id, name)\n    })\n\n    // move burg to a different cell\n    function relocateBurgOnClick() {\n      const point = d3.mouse(this)\n      const index = getIndex(point)\n      const i = +$('#burgRelocate').attr('data-id')\n      if (isNaN(i) || !manors[i]) return\n\n      if (cells[index].height < 20) {\n        tip('Cannot place burg in the water! Select a land cell', null, 'error')\n        return\n      }\n\n      if (cells[index].manor !== undefined && cells[index].manor !== i) {\n        tip('There is already a burg in this cell. Please select a free cell', null, 'error')\n        $('#grid').fadeIn()\n        d3.select('#toggleGrid').classed('buttonoff', false)\n        return\n      }\n\n      let region = cells[index].region\n      const oldRegion = manors[i].region\n      // relocating capital to other country you \"conquer\" target cell\n      if (states[oldRegion] && states[oldRegion].capital === i) {\n        if (region !== oldRegion) {\n          tip('Capital cannot be moved to another country!', null, 'error')\n          return\n        }\n      }\n\n      if (d3.event.shiftKey === false) {\n        $('#burgRelocate').removeClass('pressed')\n        restoreDefaultEvents()\n        tip('', true)\n        if (region !== oldRegion) {\n          recalculateStateData(oldRegion)\n          recalculateStateData(region)\n          updateCountryEditors()\n        }\n      }\n\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n      burgIcons.select('circle[data-id=\\'' + i + '\\']').attr('transform', null).attr('cx', x)\n               .attr('cy', y)\n      burgLabels.select('text[data-id=\\'' + i + '\\']').attr('transform', null).attr('x', x)\n                .attr('y', y)\n      const anchor = icons.select('use[data-id=\\'' + i + '\\']')\n      if (anchor.size()) {\n        const size = anchor.attr('width')\n        const xa = _.round(x - size * 0.47, 2)\n        const ya = _.round(y - size * 0.47, 2)\n        anchor.attr('transform', null).attr('x', xa).attr('y', ya)\n      }\n      cells[index].manor = i\n      cells[manors[i].cell].manor = undefined\n      manors[i].x = x, manors[i].y = y, manors[i].region = region, manors[i].cell = index\n    }\n\n    // open in MFCG\n    $('#burgSeeInMFCG').click(function() {\n      const id = +elSelected.attr('data-id')\n      const name = manors[id].name\n      const cell = manors[id].cell\n      const pop = Math.round(manors[id].population)\n      const size = pop > 65 ? 65 : pop < 6 ? 6 : pop\n      const s = seed + '' + id\n      const hub = cells[cell].crossroad > 2 ? 1 : 0\n      const river = cells[cell].river ? 1 : 0\n      const coast = cells[cell].port !== undefined ? 1 : 0\n      const sec = pop > 40 ? 1 : Math.random() < pop / 100 ? 1 : 0\n      const thr = sec && Math.random() < 0.8 ? 1 : 0\n      const url = 'http://fantasycities.watabou.ru/'\n      let params = `?name=${name}&size=${size}&seed=${s}&hub=${hub}&random=0&continuous=0`\n      params +=\n        `&river=${river}&coast=${coast}&citadel=${id & 1}&plaza=${sec}&temple=${thr}&walls=${sec}&shantytown=${sec}`\n      const win = window.open(url + params, '_blank')\n      win.focus()\n    })\n\n    $('#burgAddfromEditor').click(function() {\n      clickToAdd() // to load on click event function\n      $('#addBurg').click()\n    })\n\n    $('#burgRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the Burg?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove Burg',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            const id = +elSelected.attr('data-id')\n            d3.selectAll('[data-id=\\'' + id + '\\']').remove()\n            const cell = manors[id].cell\n            const state = manors[id].region\n            if (states[state]) {\n              if (states[state].capital === id) states[state].capital = 'select'\n              states[state].burgs--\n            }\n            manors[id].region = 'removed'\n            cells[cell].manor = undefined\n            closeDialogs('.stable')\n            updateCountryEditors()\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editMarker() {\n    if (customization) return\n\n    unselect()\n    closeDialogs('#markerEditor, .stable')\n    elSelected =\n      d3.select(this).call(d3.drag().on('start', elementDrag)).classed('draggable', true)\n\n    $('#markerEditor').dialog({\n      title: 'Edit Marker',\n      minHeight: 30, width: 'auto', maxWidth: 275, resizable: false,\n      position: {my: 'center top+30', at: 'bottom', of: d3.event},\n      close: unselect\n    })\n\n    // update inputs\n    let id = elSelected.attr('href')\n    let symbol = d3.select('#defs-markers').select(id)\n    let icon = symbol.select('text')\n    markerSelectGroup.value = id.slice(1)\n    markerIconSize.value = parseFloat(icon.attr('font-size'))\n    markerIconShiftX.value = parseFloat(icon.attr('x'))\n    markerIconShiftY.value = parseFloat(icon.attr('y'))\n    markerIconFill.value = icon.attr('fill')\n    markerIconStrokeWidth.value = icon.attr('stroke-width')\n    markerIconStroke.value = icon.attr('stroke')\n    markerSize.value = elSelected.attr('data-size')\n    markerBase.value = symbol.select('path').attr('fill')\n    markerFill.value = symbol.select('circle').attr('fill')\n    let opacity = symbol.select('circle').attr('opacity')\n    markerToggleBubble.className = opacity === '0' ? 'icon-info' : 'icon-info-circled'\n\n    let table = document.getElementById('markerIconTable')\n    let selected = table.getElementsByClassName('selected')\n    if (selected.length) selected[0].removeAttribute('class')\n    selected = document.querySelectorAll('#markerIcon' + icon.text().codePointAt())\n    if (selected.length) selected[0].className = 'selected'\n    markerIconCustom.value = selected.length ? '' : icon.text()\n\n    if (modules.editMarker) return\n    modules.editMarker = true\n\n    $('#markerGroup').click(function() {\n      $('#markerEditor > button').not(this).toggle()\n      $('#markerGroupSection').toggle()\n      updateMarkerGroupOptions()\n    })\n\n    function updateMarkerGroupOptions() {\n      markerSelectGroup.innerHTML = ''\n      d3.select('#defs-markers').selectAll('symbol').each(function() {\n        let opt = document.createElement('option')\n        opt.value = opt.innerHTML = this.id\n        markerSelectGroup.add(opt)\n      })\n      let id = elSelected.attr('href').slice(1)\n      markerSelectGroup.value = id\n    }\n\n    // on add marker type click\n    document.getElementById('markerAddGroup').addEventListener('click', function() {\n      if ($('#markerInputGroup').css('display') === 'none') {\n        $('#markerInputGroup').css('display', 'inline-block')\n        $('#markerSelectGroup').css('display', 'none')\n        markerInputGroup.focus()\n      } else {\n        $('#markerSelectGroup').css('display', 'inline-block')\n        $('#markerInputGroup').css('display', 'none')\n      }\n    })\n\n    // on marker type change\n    document.getElementById('markerSelectGroup').addEventListener('change', function() {\n      elSelected.attr('href', '#' + this.value)\n      elSelected.attr('data-id', '#' + this.value)\n    })\n\n    // on new type input\n    document.getElementById('markerInputGroup').addEventListener('change', function() {\n      let newGroup = this.value.toLowerCase().replace(/ /g, '_').replace(/[^\\w\\s]/gi, '')\n      if (Number.isFinite(+newGroup.charAt(0))) newGroup = 'm' + newGroup\n      if (d3.select('#defs-markers').select('#' + newGroup).size()) {\n        tip('The type \"' + newGroup + '\" is already exists')\n        return\n      }\n      markerInputGroup.value = ''\n      // clone old group assigning new id\n      let id = elSelected.attr('href')\n      let l = d3.select('#defs-markers').select(id).node().cloneNode(true)\n      l.id = newGroup\n      elSelected.attr('href', '#' + newGroup)\n      elSelected.attr('data-id', '#' + newGroup)\n      document.getElementById('defs-markers').insertBefore(l, null)\n\n      // select new group\n      let opt = document.createElement('option')\n      opt.value = opt.innerHTML = newGroup\n      markerSelectGroup.add(opt)\n      $('#markerSelectGroup').val(newGroup).change()\n      $('#markerSelectGroup, #markerInputGroup').toggle()\n      updateMarkerGroupOptions()\n    })\n\n    $('#markerIconButton').click(function() {\n      $('#markerEditor > button').not(this).toggle()\n      $('#markerIconButtons').toggle()\n      if (!$('#markerIconTable').text()) drawIconsList(icons)\n    })\n\n    $('#markerRemoveGroup').click(function() {\n      let id = elSelected.attr('href')\n      let used = document.querySelectorAll('use[data-id=\\'' + id + '\\']')\n      let count = used.length === 1 ? '1 element' : used.length + ' elements'\n      const message = 'Are you sure you want to remove the marker (' + count + ')?'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Remove marker',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            if (id !== '#marker0') d3.select('#defs-markers').select(id).remove()\n            used.forEach(function(e) {e.remove()})\n            updateMarkerGroupOptions()\n            $('#markerEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    function drawIconsList() {\n      let table = document.getElementById('markerIconTable'), row = ''\n      table.addEventListener('click', clickMarkerIconTable, false)\n      table.addEventListener('mouseover', hoverMarkerIconTable, false)\n\n      for (let i = 0; i < ICONS.length; i++) {\n        if (i % 20 === 0) row = table.insertRow(0)\n        let cell = row.insertCell(0)\n        let icon = String.fromCodePoint(parseInt(ICONS[i][0], 16))\n        cell.innerHTML = icon\n        cell.id = 'markerIcon' + icon.codePointAt()\n        cell.setAttribute('data-desc', ICONS[i][2])\n      }\n    }\n\n    function clickMarkerIconTable(e) {\n      if (e.target !== e.currentTarget) {\n        let table = document.getElementById('markerIconTable')\n        let selected = table.getElementsByClassName('selected')\n        if (selected.length) selected[0].removeAttribute('class')\n        e.target.className = 'selected'\n        let id = elSelected.attr('href')\n        let icon = e.target.innerHTML\n        d3.select('#defs-markers').select(id).select('text').text(icon)\n      }\n      e.stopPropagation()\n    }\n\n    function hoverMarkerIconTable(e) {\n      if (e.target !== e.currentTarget) {\n        let desc = e.target.getAttribute('data-desc')\n        tip(e.target.innerHTML + ' ' + desc)\n      }\n      e.stopPropagation()\n    }\n\n    // change marker icon size\n    document.getElementById('markerIconSize').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('font-size', this.value + 'px')\n    })\n\n    // change marker icon x shift\n    document.getElementById('markerIconShiftX').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('x', this.value + '%')\n    })\n\n    // change marker icon y shift\n    document.getElementById('markerIconShiftY').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('y', this.value + '%')\n    })\n\n    // apply custom unicode icon on input\n    document.getElementById('markerIconCustom').addEventListener('input', function() {\n      if (!this.value) return\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').text(this.value)\n    })\n\n    $('#markerStyleButton').click(function() {\n      $('#markerEditor > button').not(this).toggle()\n      $('#markerStyleButtons').toggle()\n    })\n\n    // change marker size\n    document.getElementById('markerSize').addEventListener('input', function() {\n      let id = elSelected.attr('data-id')\n      let used = document.querySelectorAll('use[data-id=\\'' + id + '\\']')\n      let size = this.value\n      used.forEach(function(e) {e.setAttribute('data-size', size)})\n      invokeActiveZooming()\n    })\n\n    // change marker base color\n    document.getElementById('markerBase').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select(id).select('path').attr('fill', this.value)\n      d3.select(id).select('circle').attr('stroke', this.value)\n    })\n\n    // change marker fill color\n    document.getElementById('markerFill').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select(id).select('circle').attr('fill', this.value)\n    })\n\n    // change marker icon y shift\n    document.getElementById('markerIconFill').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('fill', this.value)\n    })\n\n    // change marker icon y shift\n    document.getElementById('markerIconStrokeWidth').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('stroke-width', this.value)\n    })\n\n    // change marker icon y shift\n    document.getElementById('markerIconStroke').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('stroke', this.value)\n    })\n\n    // toggle marker bubble display\n    document.getElementById('markerToggleBubble').addEventListener('click', function() {\n      let id = elSelected.attr('href')\n      let show = 1\n      if (this.className === 'icon-info-circled') {\n        this.className = 'icon-info'\n        show = 0\n      } else {\n        this.className = 'icon-info-circled'\n\n      }\n      d3.select(id).select('circle').attr('opacity', show)\n      d3.select(id).select('path').attr('opacity', show)\n    })\n\n    // open legendsEditor\n    document.getElementById('markerLegendButton').addEventListener('click', function() {\n      let id = elSelected.attr('id')\n      let symbol = elSelected.attr('href')\n      let icon = d3.select('#defs-markers').select(symbol).select('text').text()\n      let name = 'Marker ' + icon\n      editLegends(id, name)\n    })\n\n    // click on master button to add new markers on click\n    document.getElementById('markerAdd').addEventListener('click', function() {\n      document.getElementById('addMarker').click()\n    })\n\n    // remove marker on click\n    document.getElementById('markerRemove').addEventListener('click', function() {\n      alertMessage.innerHTML = 'Are you sure you want to remove the marker?'\n      $('#alert').dialog({\n        resizable: false, title: 'Remove marker',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            $('#markerEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  // clear elSelected variable\n  function unselect() {\n    tip('', true)\n    restoreDefaultEvents()\n    if (customization === 5) customization = 0\n    if (!elSelected) return\n    elSelected.call(d3.drag().on('drag', null)).attr('class', null)\n    debug.selectAll('*').remove()\n    viewbox.style('cursor', 'default')\n    elSelected = null\n  }\n\n  // transform string to array [translateX,translateY,rotateDeg,rotateX,rotateY,scale]\n  function parseTransform(string) {\n    if (!string) {return [0, 0, 0, 0, 0, 1]}\n    const a = string.replace(/[a-z()]/g, '').replace(/[ ]/g, ',').split(',')\n    return [a[0] || 0, a[1] || 0, a[2] || 0, a[3] || 0, a[4] || 0, a[5] || 1]\n  }\n\n  // generic function to move any burg to any group\n  function moveBurgToGroup(id, g) {\n    $('#burgLabels [data-id=' + id + ']').detach().appendTo($('#burgLabels > #' + g))\n    $('#burgIcons [data-id=' + id + ']').detach().appendTo($('#burgIcons > #' + g))\n    const rSize = $('#burgIcons > #' + g).attr('size')\n    $('#burgIcons [data-id=' + id + ']').attr('r', rSize)\n    const el = $('#icons g[id*=\\'anchors\\'] [data-id=' + id + ']')\n    if (el.length) {\n      const to = g === 'towns' ? $('#town-anchors') : $('#capital-anchors')\n      el.detach().appendTo(to)\n      const useSize = to.attr('size')\n      const x = _.round(manors[id].x - useSize * 0.47, 2)\n      const y = _.round(manors[id].y - useSize * 0.47, 2)\n      el.attr('x', x).attr('y', y).attr('width', useSize).attr('height', useSize)\n    }\n    updateCountryEditors()\n  }\n\n  // generate cultures for a new map based on options and namesbase\n  function generateCultures() {\n    const count = +culturesInput.value\n    cultures = d3.shuffle(defaultCultures).slice(0, count)\n    const centers = d3.range(cultures.length).map(function(d, i) {\n      const x = Math.floor(Math.random() * graphWidth * 0.8 + graphWidth * 0.1)\n      const y = Math.floor(Math.random() * graphHeight * 0.8 + graphHeight * 0.1)\n      const center = [x, y]\n      cultures[i].center = center\n      return center\n    })\n    cultureTree = d3.quadtree(centers)\n  }\n\n  function manorsAndRegions() {\n    console.group('manorsAndRegions')\n    calculateChains()\n    rankPlacesGeography()\n    locateCapitals()\n    generateMainRoads()\n    rankPlacesEconomy()\n    locateTowns()\n    getNames()\n    shiftSettlements()\n    checkAccessibility()\n    defineRegions('withCultures')\n    generatePortRoads()\n    generateSmallRoads()\n    generateOceanRoutes()\n    calculatePopulation()\n    drawManors()\n    drawRegions()\n    console.groupEnd('manorsAndRegions')\n  }\n\n  // Assess cells geographycal suitability for settlement\n  function rankPlacesGeography() {\n    console.time('rankPlacesGeography')\n    land.map(function(c) {\n      let score = 0\n      c.flux = _.round(c.flux, 2)\n      // get base score from height (will be biom)\n      if (c.height <= 40) score = 2\n      else if (c.height <= 50) score = 1.8\n      else if (c.height <= 60) score = 1.6\n      else if (c.height <= 80) score = 1.4\n      score += (1 - c.height / 100) / 3\n      if (c.ctype && Math.random() < 0.8 && !c.river) {\n        c.score = 0 // ignore 80% of extended cells\n      } else {\n        if (c.harbor) {\n          if (c.harbor === 1) {score += 1} else {score -= 0.3} // good sea harbor is valued\n        }\n        if (c.river) score += 1 // coastline is valued\n        if (c.river && c.ctype === 1) score += 1 // estuary is valued\n        if (c.flux > 1) score += Math.pow(c.flux, 0.3) // riverbank is valued\n        if (c.confluence) score += Math.pow(c.confluence, 0.7) // confluence is valued;\n        const neighbEv = c.neighbors.map(\n          function(n) {if (cells[n].height >= 20) return cells[n].height})\n        const difEv = c.height - d3.mean(neighbEv)\n        // if (!isNaN(difEv)) score += difEv * 10 * (1 - c.height / 100); // local height maximums are valued\n      }\n      c.score = _.round(Math.random() * score + score, 3) // add random factor\n    })\n    land.sort(function(a, b) {return b.score - a.score})\n    console.timeEnd('rankPlacesGeography')\n  }\n\n  // Assess the cells economical suitability for settlement\n  function rankPlacesEconomy() {\n    console.time('rankPlacesEconomy')\n    land.map(function(c) {\n      let score = c.score\n      let path = c.path || 0 // roads are valued\n      if (path) {\n        path = Math.pow(path, 0.2)\n        const crossroad = c.crossroad || 0 // crossroads are valued\n        score = score + path + crossroad\n      }\n      c.score = _.round(Math.random() * score + score, 2) // add random factor\n    })\n    land.sort(function(a, b) {return b.score - a.score})\n    console.timeEnd('rankPlacesEconomy')\n  }\n\n  // calculate population for manors, cells and states\n  function calculatePopulation() {\n    // neutral population factors < 1 as neutral lands are usually pretty wild\n    const ruralFactor = 0.5, urbanFactor = 0.9\n\n    // calculate population for each burg (based on trade/people attractors)\n    manors.map(function(m) {\n      const cell = cells[m.cell]\n      let score = cell.score\n      if (score <= 0) {score = _.round(Math.random(), 2)}\n      if (cell.crossroad) {score += cell.crossroad} // crossroads\n      if (cell.confluence) {score += Math.pow(cell.confluence, 0.3)} // confluences\n      if (m.i !== m.region && cell.port) {score *= 1.5} // ports (not capital)\n      if (m.i === m.region && !cell.port) {score *= 2} // land-capitals\n      if (m.i === m.region && cell.port) {score *= 3} // port-capitals\n      if (m.region === 'neutral') score *= urbanFactor\n      const rnd = 0.6 + Math.random() * 0.8 // random factor\n      m.population = _.round(score * rnd, 1)\n    })\n\n    // calculate rural population for each cell based on area + elevation (elevation to be changed to biome)\n    const graphSizeAdj = 90 / Math.sqrt(cells.length, 2) // adjust to different graphSize\n    land.map(function(l) {\n      let population = 0\n      const elevationFactor = Math.pow(1 - l.height / 100, 3)\n      population = elevationFactor * l.area * graphSizeAdj\n      if (l.region === 'neutral') population *= ruralFactor\n      l.pop = _.round(population, 1)\n    })\n\n    // calculate population for each region\n    states.map(function(s, i) {\n      // define region burgs count\n      const burgs = $.grep(manors, function(e) {\n        return e.region === i\n      })\n      s.burgs = burgs.length\n      // define region total and burgs population\n      let burgsPop = 0 // get summ of all burgs population\n      burgs.map(function(b) {burgsPop += b.population})\n      s.urbanPopulation = _.round(burgsPop, 2)\n      const regionCells = $.grep(cells, function(e) {\n        return e.region === i\n      })\n      let cellsPop = 0\n      regionCells.map(function(c) {cellsPop += c.pop})\n      s.cells = regionCells.length\n      s.ruralPopulation = _.round(cellsPop, 1)\n    })\n\n    // collect data for neutrals\n    const neutralCells = $.grep(cells, function(e) {return e.region === 'neutral'})\n    if (neutralCells.length) {\n      let burgs = 0, urbanPopulation = 0, ruralPopulation = 0, area = 0\n      manors.forEach(function(m) {\n        if (m.region !== 'neutral') return\n        urbanPopulation += m.population\n        burgs++\n      })\n      neutralCells.forEach(function(c) {\n        ruralPopulation += c.pop\n        area += cells[c.index].area\n      })\n      states.push({\n        i: states.length, color: 'neutral', name: 'Neutrals', capital: 'neutral',\n        cells: neutralCells.length, burgs, urbanPopulation: _.round(urbanPopulation, 2),\n        ruralPopulation: _.round(ruralPopulation, 2), area: Math.round(area)\n      })\n    }\n  }\n\n  function locateCapitals() {\n    console.time('locateCapitals')\n    // min distance detween capitals\n    const count = +regionsInput.value\n    let spacing = (graphWidth + graphHeight) / 2 / count\n    console.log(' states: ' + count)\n\n    for (let l = 0; manors.length < count; l++) {\n      const region = manors.length\n      const x = land[l].data[0], y = land[l].data[1]\n      let minDist = 10000 // dummy value\n      for (let c = 0; c < manors.length; c++) {\n        const dist = Math.hypot(x - manors[c].x, y - manors[c].y)\n        if (dist < minDist) minDist = dist\n        if (minDist < spacing) break\n      }\n      if (minDist >= spacing) {\n        const cell = land[l].index\n        const closest = cultureTree.find(x, y)\n        const culture = getCultureId(closest)\n        manors.push({i: region, cell, x, y, region, culture})\n      }\n      if (l === land.length - 1) {\n        console.error(\n          'Cannot place capitals with current spacing. Trying again with reduced spacing')\n        l = -1, manors = [], spacing /= 1.2\n      }\n    }\n\n    // For each capital create a country\n    const scheme = count <= 8 ? colors8 : colors20\n    const mod = +powerInput.value\n    manors.forEach(function(m, i) {\n      const power = _.round(Math.random() * mod / 2 + 1, 1)\n      const color = scheme(i / count)\n      states.push({i, color, power, capital: i})\n      const p = cells[m.cell]\n      p.manor = i\n      p.region = i\n      p.culture = m.culture\n    })\n    console.timeEnd('locateCapitals')\n  }\n\n  function locateTowns() {\n    console.time('locateTowns')\n    const count = +manorsInput.value\n    const neutral = +neutralInput.value\n    const manorTree = d3.quadtree()\n    manors.forEach(function(m) {manorTree.add([m.x, m.y])})\n\n    for (let l = 0; manors.length < count && l < land.length; l++) {\n      const x = land[l].data[0], y = land[l].data[1]\n      const c = manorTree.find(x, y)\n      const d = Math.hypot(x - c[0], y - c[1])\n      if (d < 6) continue\n      const cell = land[l].index\n      let region = 'neutral', culture = -1, closest = neutral\n      for (let c = 0; c < states.length; c++) {\n        let dist = Math.hypot(manors[c].x - x, manors[c].y - y) / states[c].power\n        const cap = manors[c].cell\n        if (cells[cell].fn !== cells[cap].fn) dist *= 3\n        if (dist < closest) {\n          region = c\n          closest = dist\n        }\n      }\n      if (closest > neutral / 5 || region === 'neutral') {\n        const closestCulture = cultureTree.find(x, y)\n        culture = getCultureId(closestCulture)\n      } else {\n        culture = manors[region].culture\n      }\n      land[l].manor = manors.length\n      land[l].culture = culture\n      land[l].region = region\n      manors.push({i: manors.length, cell, x, y, region, culture})\n      manorTree.add([x, y])\n    }\n    if (manors.length < count) {\n      const error = 'Cannot place all burgs. Requested ' + count + ', placed ' + manors.length\n      console.error(error)\n    }\n    console.timeEnd('locateTowns')\n  }\n\n  // shift settlements from cell point\n  function shiftSettlements() {\n    for (let i = 0; i < manors.length; i++) {\n      const capital = i < regionsInput.value\n      const cell = cells[manors[i].cell]\n      let x = manors[i].x, y = manors[i].y\n      if ((capital && cell.harbor) || cell.harbor === 1) {\n        // port: capital with any harbor and towns with good harbors\n        if (cell.haven === undefined) {\n          cell.harbor = undefined\n        } else {\n          cell.port = cells[cell.haven].fn\n          x = cell.coastX\n          y = cell.coastY\n        }\n      }\n      if (cell.river && cell.type !== 1) {\n        let shift = 0.2 * cell.flux\n        if (shift < 0.2) shift = 0.2\n        if (shift > 1) shift = 1\n        shift = Math.random() > .5 ? shift : shift * -1\n        x = _.round(x + shift, 2)\n        shift = Math.random() > .5 ? shift : shift * -1\n        y = _.round(y + shift, 2)\n      }\n      cell.data[0] = manors[i].x = x\n      cell.data[1] = manors[i].y = y\n    }\n  }\n\n  // Validate each island with manors has port\n  function checkAccessibility() {\n    console.time('checkAccessibility')\n    for (let f = 0; f < features.length; f++) {\n      if (!features[f].land) continue\n      const manorsOnIsland = $.grep(land, function(e) {\n        return e.manor !== undefined && e.fn === f\n      })\n      if (!manorsOnIsland.length) continue\n\n      // if lake port is the only port on lake, remove port\n      const lakePorts = $.grep(manorsOnIsland, function(p) {\n        return p.port && !features[p.port].border\n      })\n      if (lakePorts.length) {\n        const lakes = []\n        lakePorts.forEach(function(p) {lakes[p.port] = lakes[p.port] ? lakes[p.port] + 1 : 1})\n        lakePorts.forEach(function(p) {if (lakes[p.port] === 1) p.port = undefined})\n      }\n\n      // check how many ocean ports are there on island\n      const oceanPorts = $.grep(manorsOnIsland, function(p) {\n        return p.port && features[p.port].border\n      })\n      if (oceanPorts.length) continue\n      const portCandidates = $.grep(manorsOnIsland, function(c) {\n        return c.harbor && features[cells[c.harbor].fn].border && c.ctype === 1\n      })\n      if (portCandidates.length) {\n        // No ports on island. Upgrading first burg to port\n        const candidate = portCandidates[0]\n        candidate.harbor = 1\n        candidate.port = cells[candidate.haven].fn\n        const manor = manors[portCandidates[0].manor]\n        candidate.data[0] = manor.x = candidate.coastX\n        candidate.data[1] = manor.y = candidate.coastY\n        // add score for each burg on island (as it's the only port)\n        candidate.score += Math.floor((portCandidates.length - 1) / 2)\n      } else {\n        // No ports on island. Reducing score for burgs\n        manorsOnIsland.forEach(function(e) {e.score -= 2})\n      }\n    }\n    console.timeEnd('checkAccessibility')\n  }\n\n  function generateMainRoads() {\n    console.time('generateMainRoads')\n    lineGen.curve(d3.curveBasis)\n    if (states.length < 2 || manors.length < 2) return\n    for (let f = 0; f < features.length; f++) {\n      if (!features[f].land) continue\n      const manorsOnIsland = $.grep(land,\n        function(e) {return e.manor !== undefined && e.fn === f})\n      if (manorsOnIsland.length > 1) {\n        for (let d = 1; d < manorsOnIsland.length; d++) {\n          for (let m = 0; m < d; m++) {\n            const path = findLandPath(manorsOnIsland[d].index, manorsOnIsland[m].index, 'main')\n            restorePath(manorsOnIsland[m].index, manorsOnIsland[d].index, 'main', path)\n          }\n        }\n      }\n    }\n    console.timeEnd('generateMainRoads')\n  }\n\n  // add roads from port to capital if capital is not a port\n  function generatePortRoads() {\n    console.time('generatePortRoads')\n    if (!states.length || manors.length < 2) return\n    const portless = []\n    for (let s = 0; s < states.length; s++) {\n      const cell = manors[s].cell\n      if (cells[cell].port === undefined) portless.push(s)\n    }\n    for (let l = 0; l < portless.length; l++) {\n      const ports = $.grep(land,\n        function(l) {return l.port !== undefined && l.region === portless[l]})\n      if (!ports.length) continue\n      let minDist = 1000, end = -1\n      ports.map(function(p) {\n        const dist = Math.hypot(e.data[0] - p.data[0], e.data[1] - p.data[1])\n        if (dist < minDist && dist > 1) {\n          minDist = dist\n          end = p.index\n        }\n      })\n      if (end !== -1) {\n        const start = manors[portless[l]].cell\n        const path = findLandPath(start, end, 'direct')\n        restorePath(end, start, 'main', path)\n      }\n    }\n    console.timeEnd('generatePortRoads')\n  }\n\n  function generateSmallRoads() {\n    console.time('generateSmallRoads')\n    if (manors.length < 2) return\n    for (let f = 0; f < features.length; f++) {\n      const manorsOnIsland = $.grep(land, function(e) {\n        return e.manor !== undefined && e.fn === f\n      })\n      const l = manorsOnIsland.length\n      if (l > 1) {\n        const secondary = Math.round((l + 8) / 10)\n        for (let s = 0; s < secondary; s++) {\n          var start = manorsOnIsland[Math.floor(Math.random() * l)].index\n          var end = manorsOnIsland[Math.floor(Math.random() * l)].index\n          var dist = Math.hypot(cells[start].data[0] - cells[end].data[0],\n            cells[start].data[1] - cells[end].data[1])\n          if (dist > 10) {\n            var path = findLandPath(start, end, 'direct')\n            restorePath(end, start, 'small', path)\n          }\n        }\n        manorsOnIsland.map(function(e, d) {\n          if (!e.path && d > 0) {\n            const start = e.index\n            let end = -1\n            const road = $.grep(land, function(e) {\n              return e.path && e.fn === f\n            })\n            if (road.length > 0) {\n              let minDist = 10000\n              road.map(function(i) {\n                const dist = Math.hypot(e.data[0] - i.data[0], e.data[1] - i.data[1])\n                if (dist < minDist) {\n                  minDist = dist\n                  end = i.index\n                }\n              })\n            } else {\n              end = manorsOnIsland[0].index\n            }\n            const path = findLandPath(start, end, 'main')\n            restorePath(end, start, 'small', path)\n          }\n        })\n      }\n    }\n    console.timeEnd('generateSmallRoads')\n  }\n\n  function generateOceanRoutes() {\n    console.time('generateOceanRoutes')\n    lineGen.curve(d3.curveBasis)\n    const cAnchors = icons.selectAll('#capital-anchors')\n    const tAnchors = icons.selectAll('#town-anchors')\n    const cSize = cAnchors.attr('size') || 2\n    const tSize = tAnchors.attr('size') || 1\n\n    const ports = []\n    // groups all ports on water feature\n    for (let m = 0; m < manors.length; m++) {\n      const cell = manors[m].cell\n      const port = cells[cell].port\n      if (port === undefined) continue\n      if (ports[port] === undefined) ports[port] = []\n      ports[port].push(cell)\n\n      // draw anchor icon\n      const group = m < states.length ? cAnchors : tAnchors\n      const size = m < states.length ? cSize : tSize\n      const x = _.round(cells[cell].data[0] - size * 0.47, 2)\n      const y = _.round(cells[cell].data[1] - size * 0.47, 2)\n      group.append('use').attr('xlink:href', '#icon-anchor').attr('data-id', m)\n           .attr('x', x).attr('y', y).attr('width', size).attr('height', size)\n      icons.selectAll('use').on('click', editIcon)\n    }\n\n    for (let w = 0; w < ports.length; w++) {\n      if (!ports[w]) continue\n      if (ports[w].length < 2) continue\n      const onIsland = []\n      for (let i = 0; i < ports[w].length; i++) {\n        const cell = ports[w][i]\n        const fn = cells[cell].fn\n        if (onIsland[fn] === undefined) onIsland[fn] = []\n        onIsland[fn].push(cell)\n      }\n\n      for (let fn = 0; fn < onIsland.length; fn++) {\n        if (!onIsland[fn]) continue\n        if (onIsland[fn].length < 2) continue\n        const start = onIsland[fn][0]\n        const paths = findOceanPaths(start, -1)\n\n        for (let h = 1; h < onIsland[fn].length; h++) {\n          // routes from all ports on island to 1st port on island\n          restorePath(onIsland[fn][h], start, 'ocean', paths)\n        }\n\n        // inter-island routes\n        for (let c = fn + 1; c < onIsland.length; c++) {\n          if (!onIsland[c]) continue\n          if (!onIsland[c].length) continue\n          if (onIsland[fn].length > 3) {\n            const end = onIsland[c][0]\n            restorePath(end, start, 'ocean', paths)\n          }\n        }\n\n        if (features[w].border && !features[fn].border && onIsland[fn].length > 5) {\n          // encircle the island\n          onIsland[fn].sort(function(a, b) {return cells[b].cost - cells[a].cost})\n          for (let a = 2; a < onIsland[fn].length && a < 10; a++) {\n            const from = onIsland[fn][1], to = onIsland[fn][a]\n            const dist = Math.hypot(cells[from].data[0] - cells[to].data[0],\n              cells[from].data[1] - cells[to].data[1])\n            const distPath = getPathDist(from, to)\n            if (distPath > dist * 4 + 10) {\n              const totalCost = cells[from].cost + cells[to].cost\n              const pathsAdd = findOceanPaths(from, to)\n              if (cells[to].cost < totalCost) {\n                restorePath(to, from, 'ocean', pathsAdd)\n                break\n              }\n            }\n          }\n        }\n\n      }\n\n    }\n    console.timeEnd('generateOceanRoutes')\n  }\n\n  function findLandPath(start, end, type) {\n    // A* algorithm\n    const queue = new PriorityQueue({\n      comparator: function(a, b) {\n        return a.p - b.p\n      }\n    })\n    const cameFrom = []\n    const costTotal = []\n    costTotal[start] = 0\n    queue.queue({e: start, p: 0})\n    while (queue.length > 0) {\n      const next = queue.dequeue().e\n      if (next === end) {break}\n      const pol = cells[next]\n      pol.neighbors.forEach(function(e) {\n        if (cells[e].height >= 20) {\n          let cost = cells[e].height / 100 * 2\n          if (cells[e].path && type === 'main') {\n            cost = 0.15\n          } else {\n            if (typeof e.manor === 'undefined') {cost += 0.1}\n            if (typeof e.river !== 'undefined') {cost -= 0.1}\n            if (cells[e].harbor) {cost *= 0.3}\n            if (cells[e].path) {cost *= 0.5}\n            cost +=\n              Math.hypot(cells[e].data[0] - pol.data[0], cells[e].data[1] - pol.data[1]) / 30\n          }\n          const costNew = costTotal[next] + cost\n          if (!cameFrom[e] || costNew < costTotal[e]) { //\n            costTotal[e] = costNew\n            cameFrom[e] = next\n            const dist = Math.hypot(cells[e].data[0] - cells[end].data[0],\n              cells[e].data[1] - cells[end].data[1]) / 15\n            const priority = costNew + dist\n            queue.queue({e, p: priority})\n          }\n        }\n      })\n    }\n    return cameFrom\n  }\n\n  function findOceanPaths(start, end) {\n    const queue = new PriorityQueue({comparator: function(a, b) {return a.p - b.p}})\n    let next\n    const cameFrom = [], costTotal = []\n    cameFrom[start] = 'no', costTotal[start] = 0\n    queue.queue({e: start, p: 0})\n    while (queue.length > 0 && next !== end) {\n      next = queue.dequeue().e\n      const pol = cells[next]\n      pol.neighbors.forEach(function(e) {\n        if (cells[e].ctype < 0 || cells[e].haven === next) {\n          let cost = 1\n          if (cells[e].ctype > 0) cost += 100\n          if (cells[e].ctype < -1) {\n            const dist = Math.hypot(cells[e].data[0] - pol.data[0],\n              cells[e].data[1] - pol.data[1])\n            cost += 50 + dist * 2\n          }\n          if (cells[e].path && cells[e].ctype < 0) cost *= 0.8\n          const costNew = costTotal[next] + cost\n          if (!cameFrom[e]) {\n            costTotal[e] = costNew\n            cells[e].cost = costNew\n            cameFrom[e] = next\n            queue.queue({e, p: costNew})\n          }\n        }\n      })\n    }\n    return cameFrom\n  }\n\n  function getPathDist(start, end) {\n    const queue = new PriorityQueue({\n      comparator: function(a, b) {\n        return a.p - b.p\n      }\n    })\n    let next, costNew\n    const cameFrom = []\n    const costTotal = []\n    cameFrom[start] = 'no'\n    costTotal[start] = 0\n    queue.queue({e: start, p: 0})\n    while (queue.length > 0 && next !== end) {\n      next = queue.dequeue().e\n      const pol = cells[next]\n      pol.neighbors.forEach(function(e) {\n        if (cells[e].path && (cells[e].ctype === -1 || cells[e].haven === next)) {\n          const dist = Math.hypot(cells[e].data[0] - pol.data[0], cells[e].data[1] - pol.data[1])\n          costNew = costTotal[next] + dist\n          if (!cameFrom[e]) {\n            costTotal[e] = costNew\n            cameFrom[e] = next\n            queue.queue({e, p: costNew})\n          }\n        }\n      })\n    }\n    return costNew\n  }\n\n  function restorePath(end, start, type, from) {\n    let path = [], current = end\n    const limit = 1000\n    let prev = cells[end]\n    if (type === 'ocean' || !prev.path) {\n      path.push({scX: prev.data[0], scY: prev.data[1], i: end})\n    }\n    if (!prev.path) {prev.path = 1}\n    for (let i = 0; i < limit; i++) {\n      current = from[current]\n      let cur = cells[current]\n      if (!cur) {break}\n      if (cur.path) {\n        cur.path += 1\n        path.push({scX: cur.data[0], scY: cur.data[1], i: current})\n        prev = cur\n        drawPath()\n      } else {\n        cur.path = 1\n        if (prev) {path.push({scX: prev.data[0], scY: prev.data[1], i: prev.index})}\n        prev = undefined\n        path.push({scX: cur.data[0], scY: cur.data[1], i: current})\n      }\n      if (current === start || !from[current]) {break}\n    }\n    drawPath()\n\n    function drawPath() {\n      if (path.length > 1) {\n        // mark crossroades\n        if (type === 'main' || type === 'small') {\n          const plus = type === 'main' ? 4 : 2\n          const f = cells[path[0].i]\n          if (f.path > 1) {\n            if (!f.crossroad) {f.crossroad = 0}\n            f.crossroad += plus\n          }\n          const t = cells[(path[path.length - 1].i)]\n          if (t.path > 1) {\n            if (!t.crossroad) {t.crossroad = 0}\n            t.crossroad += plus\n          }\n        }\n        // draw path segments\n        let line = lineGen(path)\n        line = round(line, 1)\n        let id = 0 // to create unique route id\n        if (type === 'main') {\n          id = roads.selectAll('path').size()\n          roads.append('path').attr('d', line).attr('id', 'road' + id).on('click', editRoute)\n        } else if (type === 'small') {\n          id = trails.selectAll('path').size()\n          trails.append('path').attr('d', line).attr('id', 'trail' + id).on('click', editRoute)\n        } else if (type === 'ocean') {\n          id = searoutes.selectAll('path').size()\n          searoutes.append('path').attr('d', line).attr('id', 'searoute' + id)\n                   .on('click', editRoute)\n        }\n      }\n      path = []\n    }\n  }\n\n  // Append burg elements\n  function drawManors() {\n    console.time('drawManors')\n    const capitalIcons = burgIcons.select('#capitals')\n    const capitalLabels = burgLabels.select('#capitals')\n    const townIcons = burgIcons.select('#towns')\n    const townLabels = burgLabels.select('#towns')\n    const capitalSize = capitalIcons.attr('size') || 1\n    const townSize = townIcons.attr('size') || 0.5\n    capitalIcons.selectAll('*').remove()\n    capitalLabels.selectAll('*').remove()\n    townIcons.selectAll('*').remove()\n    townLabels.selectAll('*').remove()\n\n    for (let i = 0; i < manors.length; i++) {\n      const x = manors[i].x, y = manors[i].y\n      const cell = manors[i].cell\n      const name = manors[i].name\n      const ic = i < states.length ? capitalIcons : townIcons\n      const lb = i < states.length ? capitalLabels : townLabels\n      const size = i < states.length ? capitalSize : townSize\n      ic.append('circle').attr('id', 'burg' + i).attr('data-id', i).attr('cx', x).attr('cy', y)\n        .attr('r', size).on('click', editBurg)\n      lb.append('text').attr('data-id', i).attr('x', x).attr('y', y).attr('dy', '-0.35em')\n        .text(name).on('click', editBurg)\n    }\n    console.timeEnd('drawManors')\n  }\n\n  // get settlement and country names based on option selected\n  function getNames() {\n    console.time('getNames')\n    // if names source is an external resource\n    if (namesInput.value === '1') {\n      const request = new XMLHttpRequest()\n      const url = 'https://archivist.xalops.com/archivist-core/api/name/settlement?count='\n      request.open('GET', url + manors.length, true)\n      request.onload = function() {\n        const names = JSON.parse(request.responseText)\n        for (let i = 0; i < manors.length; i++) {\n          manors[i].name = names[i]\n          burgLabels.select('[data-id=\\'' + i + '\\']').text(names[i])\n          if (i < states.length) {\n            states[i].name = generateStateName(i)\n            labels.select('#countries').select('#regionLabel' + i).text(states[i].name)\n          }\n        }\n        console.log(names)\n      }\n      request.send(null)\n    }\n\n    if (namesInput.value !== '0') return\n    for (let i = 0; i < manors.length; i++) {\n      const culture = manors[i].culture\n      manors[i].name = generateName(culture)\n      if (i < states.length) states[i].name = generateStateName(i)\n    }\n    console.timeEnd('getNames')\n  }\n\n  function calculateChains() {\n    for (let c = 0; c < nameBase.length; c++) {\n      chain[c] = calculateChain(c)\n    }\n  }\n\n  // calculate Markov's chain from namesbase data\n  function calculateChain(c) {\n    const chain = []\n    const d = nameBase[c].join(' ').toLowerCase()\n    const method = nameBases[c].method\n\n    for (let i = -1, prev = ' ', str = ''; i < d.length - 2; prev = str, i += str.length, str =\n      '') {\n      let vowel = 0, f = ' '\n      if (method === 'let-to-let') {str = d[i + 1]} else {\n        for (let c = i + 1; str.length < 5; c++) {\n          if (d[c] === undefined) break\n          str += d[c]\n          if (str === ' ') break\n          if (d[c] !== 'o' && d[c] !== 'e' && VOWELS.includes(d[c]) && d[c + 1] === d[c]) break\n          if (d[c + 2] === ' ') {\n            str += d[c + 1]\n            break\n          }\n          if (VOWELS.includes(d[c])) vowel++\n          if (vowel && VOWELS.includes(d[c + 2])) break\n        }\n      }\n      if (i >= 0) {\n        f = d[i]\n        if (method === 'syl-to-syl') f = prev\n      }\n      if (chain[f] === undefined) chain[f] = []\n      chain[f].push(str)\n    }\n    return chain\n  }\n\n  // generate random name using Markov's chain\n  function generateName(culture, base) {\n    if (base === undefined) {\n      if (!cultures[culture]) {\n        console.error('culture ' + culture + ' is not defined. Will load default cultures and set first culture')\n        generateCultures()\n        culture = 0\n      }\n      base = cultures[culture].base\n    }\n    if (!nameBases[base]) {\n      console.error('nameBase ' + base + ' is not defined. Will load default names data and first base')\n      if (!nameBases[0]) applyDefaultNamesData()\n      base = 0\n    }\n    const method = nameBases[base].method\n    const error = function(base) {\n      tip('Names data for base ' + nameBases[base].name + ' is incorrect. Please fix in Namesbase Editor')\n      editNamesbase()\n    }\n\n    if (method === 'selection') {\n      if (nameBase[base].length < 1) {\n        error(base)\n        return\n      }\n      const rnd = _.random(nameBase[base].length - 1)\n      return nameBase[base][rnd]\n    }\n\n    const data = chain[base]\n    if (data === undefined || data[' '] === undefined) {\n      error(base)\n      return\n    }\n    const max = nameBases[base].max\n    const min = nameBases[base].min\n    const d = nameBases[base].d\n    let word = '', variants = data[' ']\n    if (variants === undefined) {\n      error(base)\n      return\n    }\n    let cur = variants[_.random(variants.length - 1)]\n    for (let i = 0; i < 21; i++) {\n      if (cur === ' ' && Math.random() < 0.8) {\n        // space means word end, but we don't want to end if word is too short\n        if (word.length < min) {\n          word = ''\n          variants = data[' ']\n        } else {break}\n      } else {\n        const l = method === 'let-to-syl' && cur.length > 1 ? cur[cur.length - 1] : cur\n        variants = data[l]\n        // word is getting too long, restart\n        word += cur // add current el to word\n        if (word.length > max) word = ''\n      }\n      if (variants === undefined) {\n        error(base)\n        return\n      }\n      cur = variants[_.random(variants.length - 1)]\n    }\n    // very rare case, let's just select a random name\n    if (word.length < 2) word = nameBase[base][_.random(nameBase[base].length - 1)]\n\n    // do not allow multi-word name if word is foo short or not allowed for culture\n    if (word.includes(' ')) {\n      let words = word.split(' ')\n      if (Math.random() > nameBases[base].m) {word = words.join('')} else {\n        for (let i = 0; i < words.length; i++) {\n          if (words[i].length < 2) {\n            if (!i) words[1] = words[0] + words[1]\n            if (i) words[i - 1] += words[i]\n            words.splice(i, 1)\n            i--\n          }\n        }\n        word = words.join(' ')\n      }\n    }\n\n    // parse word to get a final name\n    return [...word].reduce(function(r, c, i, data) {\n      if (c === ' ') {\n        if (!r.length) return ''\n        if (i + 1 === data.length) return r\n      }\n      if (!r.length) return c.toUpperCase()\n      if (r.slice(-1) === ' ') return r + c.toUpperCase()\n      if (c === data[i - 1]) {\n        if (!d.includes(c)) return r\n        if (c === data[i - 2]) return r\n      }\n      return r + c\n    }, '')\n  }\n\n  // Define areas based on the closest manor to a polygon\n  function defineRegions(withCultures) {\n    console.time('defineRegions')\n    const manorTree = d3.quadtree()\n    manors.forEach(function(m) {if (m.region !== 'removed') manorTree.add([m.x, m.y])})\n\n    const neutral = +neutralInput.value\n    land.forEach(function(i) {\n      if (i.manor !== undefined && manors[i.manor].region !== 'removed') {\n        i.region = manors[i.manor].region\n        if (withCultures && manors[i.manor].culture !== undefined) i.culture =\n          manors[i.manor].culture\n        return\n      }\n      const x = i.data[0], y = i.data[1]\n\n      let dist = 100000, manor = null\n      if (manors.length) {\n        const c = manorTree.find(x, y)\n        dist = Math.hypot(c[0] - x, c[1] - y)\n        manor = getManorId(c)\n      }\n      if (dist > neutral / 2 || manor === null) {\n        i.region = 'neutral'\n        if (withCultures) {\n          const closestCulture = cultureTree.find(x, y)\n          i.culture = getCultureId(closestCulture)\n        }\n      } else {\n        const cell = manors[manor].cell\n        if (cells[cell].fn !== i.fn) {\n          let minDist = dist * 3\n          land.forEach(function(l) {\n            if (l.fn === i.fn && l.manor !== undefined) {\n              if (manors[l.manor].region === 'removed') return\n              const distN = Math.hypot(l.data[0] - x, l.data[1] - y)\n              if (distN < minDist) {\n                minDist = distN\n                manor = l.manor\n              }\n            }\n          })\n        }\n        i.region = manors[manor].region\n        if (withCultures) i.culture = manors[manor].culture\n      }\n    })\n    console.timeEnd('defineRegions')\n  }\n\n  // Define areas cells\n  function drawRegions() {\n    console.time('drawRegions')\n    labels.select('#countries').selectAll('*').remove()\n\n    // arrays to store edge data\n    const edges = [], coastalEdges = [], borderEdges = [], neutralEdges = []\n    for (let a = 0; a < states.length; a++) {\n      edges[a] = []\n      coastalEdges[a] = []\n    }\n    const e = diagram.edges\n    for (let i = 0; i < e.length; i++) {\n      if (e[i] === undefined) continue\n      const start = e[i][0].join(' ')\n      const end = e[i][1].join(' ')\n      const p = {start, end}\n      if (e[i].left === undefined) {\n        const r = e[i].right.index\n        const rr = cells[r].region\n        if (Number.isInteger(rr)) edges[rr].push(p)\n        continue\n      }\n      if (e[i].right === undefined) {\n        const l = e[i].left.index\n        const lr = cells[l].region\n        if (Number.isInteger(lr)) edges[lr].push(p)\n        continue\n      }\n      const l = e[i].left.index\n      const r = e[i].right.index\n      const lr = cells[l].region\n      const rr = cells[r].region\n      if (lr === rr) continue\n      if (Number.isInteger(lr)) {\n        edges[lr].push(p)\n        if (rr === undefined) {\n          coastalEdges[lr].push(p)\n        } else if (rr === 'neutral') {neutralEdges.push(p)}\n      }\n      if (Number.isInteger(rr)) {\n        edges[rr].push(p)\n        if (lr === undefined) {\n          coastalEdges[rr].push(p)\n        } else if (lr === 'neutral') {neutralEdges.push(p)} else if (Number.isInteger(\n          lr)) {borderEdges.push(p)}\n      }\n    }\n    edges.map(function(e, i) {\n      if (e.length) {\n        drawRegion(e, i)\n        drawRegionCoast(coastalEdges[i], i)\n      }\n    })\n    drawBorders(borderEdges, 'state')\n    drawBorders(neutralEdges, 'neutral')\n    console.timeEnd('drawRegions')\n  }\n\n  function drawRegion(edges, region) {\n    let path = ''\n    const array = []\n    lineGen.curve(d3.curveLinear)\n    while (edges.length > 2) {\n      const edgesOrdered = [] // to store points in a correct order\n      const start = edges[0].start\n      let end = edges[0].end\n      edges.shift()\n      let spl = start.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      spl = end.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      for (let i = 0; end !== start && i < 2000; i++) {\n        const next = $.grep(edges, function(e) {\n          return (e.start == end || e.end == end)\n        })\n        if (next.length > 0) {\n          if (next[0].start == end) {\n            end = next[0].end\n          } else if (next[0].end == end) {\n            end = next[0].start\n          }\n          spl = end.split(' ')\n          edgesOrdered.push({scX: spl[0], scY: spl[1]})\n        }\n        const rem = edges.indexOf(next[0])\n        edges.splice(rem, 1)\n      }\n      path += lineGen(edgesOrdered) + 'Z '\n      array[array.length] = edgesOrdered.map(function(e) {return [+e.scX, +e.scY]})\n    }\n    const color = states[region].color\n    regions.append('path').attr('d', round(path, 1)).attr('fill', color)\n           .attr('class', 'region' + region)\n    array.sort(function(a, b) {return b.length - a.length})\n    let capital = states[region].capital\n    // add capital cell as a hole\n    if (!isNaN(capital)) {\n      const capitalCell = manors[capital].cell\n      array.push(polygons[capitalCell])\n    }\n    const name = states[region].name\n    const c = polylabel(array, 1.0) // pole of inaccessibility\n    labels.select('#countries').append('text').attr('id', 'regionLabel' + region)\n          .attr('x', Math.round(c[0])).attr('y', Math.round(c[1])).text(name).on('click', editLabel)\n    states[region].area = Math.round(Math.abs(d3.polygonArea(array[0]))) // define region area\n  }\n\n  function drawRegionCoast(edges, region) {\n    let path = ''\n    while (edges.length > 0) {\n      const edgesOrdered = [] // to store points in a correct order\n      const start = edges[0].start\n      let end = edges[0].end\n      edges.shift()\n      let spl = start.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      spl = end.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      let next = $.grep(edges, function(e) {\n        return (e.start == end || e.end == end)\n      })\n      while (next.length > 0) {\n        if (next[0].start == end) {\n          end = next[0].end\n        } else if (next[0].end == end) {\n          end = next[0].start\n        }\n        spl = end.split(' ')\n        edgesOrdered.push({scX: spl[0], scY: spl[1]})\n        const rem = edges.indexOf(next[0])\n        edges.splice(rem, 1)\n        next = $.grep(edges, function(e) {return (e.start == end || e.end == end)})\n      }\n      path += lineGen(edgesOrdered)\n    }\n    const color = states[region].color\n    regions.append('path').attr('d', round(path, 1)).attr('fill', 'none').attr('stroke', color)\n           .attr('stroke-width', 5).attr('class', 'region' + region)\n  }\n\n  function drawBorders(edges, type) {\n    let path = ''\n    if (edges.length < 1) {return}\n    while (edges.length > 0) {\n      const edgesOrdered = [] // to store points in a correct order\n      const start = edges[0].start\n      let end = edges[0].end\n      edges.shift()\n      let spl = start.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      spl = end.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      let next = $.grep(edges, function(e) {\n        return (e.start == end || e.end == end)\n      })\n      while (next.length > 0) {\n        if (next[0].start == end) {\n          end = next[0].end\n        } else if (next[0].end == end) {\n          end = next[0].start\n        }\n        spl = end.split(' ')\n        edgesOrdered.push({scX: spl[0], scY: spl[1]})\n        const rem = edges.indexOf(next[0])\n        edges.splice(rem, 1)\n        next = $.grep(edges, function(e) {return (e.start == end || e.end == end)})\n      }\n      path += lineGen(edgesOrdered)\n    }\n    if (type === 'state') {stateBorders.append('path').attr('d', round(path, 1))}\n    if (type === 'neutral') {neutralBorders.append('path').attr('d', round(path, 1))}\n  }\n\n  // generate region name\n  function generateStateName(state) {\n    let culture = null\n    if (states[state]) if (manors[states[state].capital]) culture =\n      manors[states[state].capital].culture\n    let name = 'NameIdontWant'\n    if (Math.random() < 0.85 || culture === null) {\n      // culture is random if capital is not yet defined\n      if (culture === null) culture = _.random(cultures.length - 1)\n      // try to avoid too long words as a basename\n      for (let i = 0; i < 20 && name.length > 7; i++) {\n        name = generateName(culture)\n      }\n    } else {\n      name = manors[state].name\n    }\n    const base = cultures[culture].base\n\n    let addSuffix = false\n    // handle special cases\n    const e = name.slice(-2)\n    if (base === 5 && (e === 'sk' || e === 'ev' || e === 'ov')) {\n      // remove -sk and -ev/-ov for Ruthenian\n      name = name.slice(0, -2)\n      addSuffix = true\n    } else if (name.length > 5 && base === 1 && name.slice(-3) === 'ton') {\n      // remove -ton ending for English\n      name = name.slice(0, -3)\n      addSuffix = true\n    } else if (name.length > 6 && name.slice(-4) === 'berg') {\n      // remove -berg ending for any\n      name = name.slice(0, -4)\n      addSuffix = true\n    } else if (base === 12) {\n      // Japanese ends on vowels\n      if (VOWELS.includes(name.slice(-1))) return name\n      return name + 'u'\n    } else if (base === 10) {\n      // Korean has \"guk\" suffix\n      if (name.slice(-3) === 'guk') return name\n      if (name.slice(-1) === 'g') name = name.slice(0, -1)\n      if (Math.random() < 0.2 && name.length < 7) name = name + 'guk' // 20% for \"guk\"\n      return name\n    } else if (base === 11) {\n      // Chinese has \"guo\" suffix\n      if (name.slice(-3) === 'guo') return name\n      if (name.slice(-1) === 'g') name = name.slice(0, -1)\n      if (Math.random() < 0.3 && name.length < 7) name = name + ' Guo' // 30% for \"guo\"\n      return name\n    }\n\n    // define if suffix should be used\n    let vowel = VOWELS.includes(name.slice(-1)) // last char is vowel\n    if (vowel && name.length > 3) {\n      if (Math.random() < 0.85) {\n        if (VOWELS.includes(name.slice(-2, -1))) {\n          name = name.slice(0, -2)\n          addSuffix = true // 85% for vv\n        } else if (Math.random() < 0.7) {\n          name = name.slice(0, -1)\n          addSuffix = true // ~60% for cv\n        }\n      }\n    } else if (Math.random() < 0.6) {\n      addSuffix = true // 60% for cc and vc\n    }\n\n    if (addSuffix === false) return name\n    let suffix = 'ia' // common latin suffix\n    const rnd = Math.random()\n    if (rnd < 0.05 && base === 3) suffix = 'terra' // 5% \"terra\" for Italian\n    else if (rnd < 0.05 && base === 4) suffix = 'terra' // 5% \"terra\" for Spanish\n    else if (rnd < 0.05 && base == 2) suffix = 'terre' // 5% \"terre\" for French\n    else if (rnd < 0.5 && base == 0) suffix = 'land' // 50% \"land\" for German\n    else if (rnd < 0.4 && base == 1) suffix = 'land' // 40% \"land\" for English\n    else if (rnd < 0.3 && base == 6) suffix = 'land' // 30% \"land\" for Nordic\n    else if (rnd < 0.1 && base == 7) suffix = 'eia' // 10% \"eia\" for Greek (\"ia\" is also Greek)\n    else if (rnd < 0.4 && base == 9) suffix = 'maa' // 40% \"maa\" for Finnic\n    if (name.slice(-1 * suffix.length) === suffix) return name // no suffix if name already ends with it\n    if (name.slice(-1) === suffix.charAt(0)) name = name.slice(0, -1) // remove name last letter if it's a suffix first letter\n    return name + suffix\n  }\n\n  // re-calculate cultures\n  function recalculateCultures(fullRedraw) {\n    console.time('recalculateCultures')\n    // For each capital find closest culture and assign it to capital\n    states.forEach(function(s) {\n      if (s.capital === 'neutral' || s.capital === 'select') return\n      const capital = manors[s.capital]\n      const c = cultureTree.find(capital.x, capital.y)\n      capital.culture = getCultureId(c)\n    })\n\n    // For each town if distance to its capital > neutral / 2,\n    // assign closest culture to the town; else assign capital's culture\n    const manorTree = d3.quadtree()\n    const neutral = +neutralInput.value\n    manors.forEach(function(m) {\n      if (m.region === 'removed') return\n      manorTree.add([m.x, m.y])\n      if (m.region === 'neutral') {\n        const culture = cultureTree.find(m.x, m.y)\n        m.culture = getCultureId(culture)\n        return\n      }\n      const c = states[m.region].capital\n      if (c !== 'neutral' && c !== 'select') {\n        const dist = Math.hypot(m.x - manors[c].x, m.y - manors[c].y)\n        if (dist <= neutral / 5) {\n          m.culture = manors[c].culture\n          return\n        }\n      }\n      const culture = cultureTree.find(m.x, m.y)\n      m.culture = getCultureId(culture)\n    })\n\n    // For each land cell if distance to closest manor > neutral / 2,\n    // assign closest culture to the cell; else assign manors's culture\n    const changed = []\n    land.forEach(function(i) {\n      const x = i.data[0], y = i.data[1]\n      const c = manorTree.find(x, y)\n      const culture = i.culture\n      const dist = Math.hypot(c[0] - x, c[1] - y)\n      let manor = getManorId(c)\n      if (dist > neutral / 2 || manor === undefined) {\n        const closestCulture = cultureTree.find(i.data[0], i.data[1])\n        i.culture = getCultureId(closestCulture)\n      } else {\n        const cell = manors[manor].cell\n        if (cells[cell].fn !== i.fn) {\n          let minDist = dist * 3\n          land.forEach(function(l) {\n            if (l.fn === i.fn && l.manor !== undefined) {\n              if (manors[l.manor].region === 'removed') return\n              const distN = Math.hypot(l.data[0] - x, l.data[1] - y)\n              if (distN < minDist) {\n                minDist = distN\n                manor = l.manor\n              }\n            }\n          })\n        }\n        i.culture = manors[manor].culture\n      }\n      // re-color cells\n      if (i.culture !== culture || fullRedraw) {\n        const clr = cultures[i.culture].color\n        cults.select('#cult' + i.index).attr('fill', clr).attr('stroke', clr)\n      }\n    })\n    console.timeEnd('recalculateCultures')\n  }\n\n  // get culture Id from center coordinates\n  function getCultureId(c) {\n    for (let i = 0; i < cultures.length; i++) {\n      if (cultures[i].center[0] === c[0]) if (cultures[i].center[1] === c[1]) return i\n    }\n  }\n\n  // get manor Id from center coordinates\n  function getManorId(c) {\n    for (let i = 0; i < manors.length; i++) {\n      if (manors[i].x === c[0]) if (manors[i].y === c[1]) return i\n    }\n  }\n\n  // focus on coorditanes, cell or burg provided in searchParams\n  function focusOn() {\n    if (params.get('from') === 'MFCG') {\n      // focus on burg from MFCG\n      findBurgForMFCG()\n      return\n    }\n    let s = params.get('scale') || 8\n    let x = params.get('x')\n    let y = params.get('y')\n    let c = params.get('cell')\n    if (c !== null) {\n      x = cells[+c].data[0]\n      y = cells[+c].data[1]\n    }\n    let b = params.get('burg')\n    if (b !== null) {\n      x = manors[+b].x\n      y = manors[+b].y\n    }\n    if (x !== null && y !== null) zoomTo(x, y, s, 1600)\n  }\n\n  // find burg from MFCG and focus on it\n  function findBurgForMFCG() {\n    if (!manors.length) {\n      console.error('No burgs generated. Cannot select a burg for MFCG')\n      return\n    }\n    const size = +params.get('size')\n    let coast = +params.get('coast')\n    let port = +params.get('port')\n    let river = +params.get('river')\n    let selection = defineSelection(coast, port, river)\n    if (!selection.length) selection = defineSelection(coast, !port, !river)\n    if (!selection.length) selection = defineSelection(!coast, 0, !river)\n    if (!selection.length) selection = manors[0] // select first if nothing is found\n    if (!selection.length) {\n      console.error('Cannot find a burg for MFCG')\n      return\n    }\n\n    function defineSelection(coast, port, river) {\n      let selection = []\n      if (port && river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].port !== undefined && cells[e.cell].river !== undefined})\n      else if (!port && coast && river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].port === undefined && cells[e.cell].ctype === 1 && cells[e.cell].river !== undefined})\n      else if (!coast && !river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].ctype !== 1 && cells[e.cell].river === undefined})\n      else if (!coast && river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].ctype !== 1 && cells[e.cell].river !== undefined})\n      else if (coast && !river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].ctype === 1 && cells[e.cell].river === undefined})\n      return selection\n    }\n\n    // select a burg with closes population from selection\n    const selected = d3.scan(selection,\n      function(a, b) {return Math.abs(a.population - size) - Math.abs(b.population - size)})\n    const burg = selection[selected].i\n    if (size && burg !== undefined) {manors[burg].population = size} else {return}\n\n    // focus on found burg\n    const label = burgLabels.select('[data-id=\\'' + burg + '\\']')\n    if (!label.size()) {\n      console.error('Cannot find a label for MFCG burg ' + burg)\n      return\n    }\n    tip('Here stands the glorious city of ' + manors[burg].name, true)\n    label.classed('drag', true).on('mouseover', function() {\n      d3.select(this).classed('drag', false)\n      tip('', true)\n    })\n    const x = +label.attr('x'), y = +label.attr('y')\n    zoomTo(x, y, 8, 1600)\n  }\n\n  // draw Cultures\n  function toggleCultures() {\n    if (cults.selectAll('path').size() == 0) {\n      land.map(function(i) {\n        const color = cultures[i.culture].color\n        cults.append('path')\n             .attr('d', 'M' + polygons[i.index].join('L') + 'Z')\n             .attr('id', 'cult' + i.index)\n             .attr('fill', color)\n             .attr('stroke', color)\n      })\n    } else {\n      cults.selectAll('path').remove()\n    }\n  }\n\n  // clean data to get rid of redundand info\n  function cleanData() {\n    console.time('cleanData')\n    cells.map(function(c) {\n      delete c.cost\n      delete c.used\n      delete c.coastX\n      delete c.coastY\n      if (c.ctype === undefined) delete c.ctype\n      if (c.lake === undefined) delete c.lake\n      c.height = Math.trunc(c.height)\n      if (c.height >= 20) c.flux = _.round(c.flux, 2)\n    })\n    // restore layers if they was turned on\n    if (!$('#toggleHeight').hasClass('buttonoff') && !terrs.selectAll('path')\n                                                           .size()) toggleHeight()\n    if (!$('#toggleCultures').hasClass('buttonoff') && !cults.selectAll('path')\n                                                             .size()) toggleCultures()\n    closeDialogs()\n    invokeActiveZooming()\n    console.timeEnd('cleanData')\n  }\n\n  // close all dialogs except stated\n  function closeDialogs(except) {\n    except = except || '#except'\n    $('.dialog:visible').not(except).each(function(e) {\n      $(this).dialog('close')\n    })\n  }\n\n  // change transparency for modal windowa\n  function changeDialogsTransparency(v) {\n    localStorage.setItem('transparency', v)\n    const alpha = (100 - +v) / 100\n    const optionsColor = 'rgba(164, 139, 149, ' + alpha + ')' // purple-red\n    const dialogsColor = 'rgba(255, 255, 255, ' + alpha + ')' // white\n    document.getElementById('options').style.backgroundColor = optionsColor\n    document.getElementById('dialogs').style.backgroundColor = dialogsColor\n  }\n\n  // Draw the water flux system (for dubugging)\n  function toggleFlux() {\n    const colorFlux = d3.scaleSequential(d3chromatic.interpolateBlues)\n    if (terrs.selectAll('path').size() == 0) {\n      land.map(function(i) {\n        terrs.append('path')\n             .attr('d', 'M' + polygons[i.index].join('L') + 'Z')\n             .attr('fill', colorFlux(0.1 + i.flux))\n             .attr('stroke', colorFlux(0.1 + i.flux))\n      })\n    } else {\n      terrs.selectAll('path').remove()\n    }\n  }\n\n  // Draw the Relief (need to create more beautiness)\n  function drawRelief() {\n    console.time('drawRelief')\n    let h, count, rnd, cx, cy, swampCount = 0\n    const hills = terrain.select('#hills')\n    const mounts = terrain.select('#mounts')\n    const swamps = terrain.select('#swamps')\n    const forests = terrain.select('#forests')\n    terrain.selectAll('g').selectAll('g').remove()\n    // sort the land to Draw the top element first (reduce the elements overlapping)\n    land.sort(compareY)\n    for (let i = 0; i < land.length; i++) {\n      if (land[i].river) continue // no icons on rivers\n      const cell = land[i].index\n      const p = d3.polygonCentroid(polygons[cell]) // polygon centroid point\n      if (p === undefined) continue // something is wrong with data\n      const height = land[i].height\n      const area = land[i].area\n      if (height >= 70) {\n        // mount icon\n        h = (height - 55) * 0.12\n        for (let c = 0, a = area; Math.random() < a / 50; c++, a -= 50) {\n          if (polygons[cell][c] === undefined) break\n          const g = mounts.append('g').attr('data-cell', cell)\n          if (c < 2) {\n            cx = p[0] - h / 100 * (1 - c / 10) - c * 2\n            cy = p[1] + h / 400 + c\n          } else {\n            const p2 = polygons[cell][c]\n            cx = (p[0] * 1.2 + p2[0] * 0.8) / 2\n            cy = (p[1] * 1.2 + p2[1] * 0.8) / 2\n          }\n          rnd = Math.random() * 0.8 + 0.2\n          let mount = 'M' + cx + ',' + cy + ' L' + (cx + h / 3 + rnd) + ',' + (cy - h / 4 - rnd * 1.2) + ' L' + (cx + h / 1.1) + ',' + (cy - h) + ' L' + (cx + h + rnd) + ',' + (cy - h / 1.2 + rnd) + ' L' + (cx + h * 2) + ',' + cy\n          let shade = 'M' + cx + ',' + cy + ' L' + (cx + h / 3 + rnd) + ',' + (cy - h / 4 - rnd * 1.2) + ' L' + (cx + h / 1.1) + ',' + (cy - h) + ' L' + (cx + h / 1.5) + ',' + cy\n          let dash = 'M' + (cx - 0.1) + ',' + (cy + 0.3) + ' L' + (cx + 2 * h + 0.1) + ',' + (cy + 0.3)\n          dash +=\n            'M' + (cx + 0.4) + ',' + (cy + 0.6) + ' L' + (cx + 2 * h - 0.3) + ',' + (cy + 0.6)\n          g.append('path').attr('d', round(mount, 1)).attr('stroke', '#5c5c70')\n          g.append('path').attr('d', round(shade, 1)).attr('fill', '#999999')\n          g.append('path').attr('d', round(dash, 1)).attr('class', 'strokes')\n        }\n      } else if (height > 50) {\n        // hill icon\n        h = (height - 40) / 10\n        if (h > 1.7) h = 1.7\n        for (let c = 0, a = area; Math.random() < a / 30; c++, a -= 30) {\n          if (land[i].ctype === 1 && c > 0) break\n          if (polygons[cell][c] === undefined) break\n          const g = hills.append('g').attr('data-cell', cell)\n          if (c < 2) {\n            cx = p[0] - h - c * 1.2\n            cy = p[1] + h / 4 + c / 1.6\n          } else {\n            const p2 = polygons[cell][c]\n            cx = (p[0] * 1.2 + p2[0] * 0.8) / 2\n            cy = (p[1] * 1.2 + p2[1] * 0.8) / 2\n          }\n          let hill = 'M' + cx + ',' + cy + ' Q' + (cx + h) + ',' + (cy - h) + ' ' + (cx + 2 * h) + ',' + cy\n          let shade = 'M' + (cx + 0.6 * h) + ',' + (cy + 0.1) + ' Q' + (cx + h * 0.95) + ',' + (cy - h * 0.91) + ' ' + (cx + 2 * h * 0.97) + ',' + cy\n          let dash = 'M' + (cx - 0.1) + ',' + (cy + 0.2) + ' L' + (cx + 2 * h + 0.1) + ',' + (cy + 0.2)\n          dash +=\n            'M' + (cx + 0.4) + ',' + (cy + 0.4) + ' L' + (cx + 2 * h - 0.3) + ',' + (cy + 0.4)\n          g.append('path').attr('d', round(hill, 1)).attr('stroke', '#5c5c70')\n          g.append('path').attr('d', round(shade, 1)).attr('fill', 'white')\n          g.append('path').attr('d', round(dash, 1)).attr('class', 'strokes')\n        }\n      }\n\n      // swamp icons\n      if (height >= 21 && height < 22 && swampCount < +swampinessInput.value && land[i].used != 1) {\n        const g = swamps.append('g').attr('data-cell', cell)\n        swampCount++\n        land[i].used = 1\n        let swamp = drawSwamp(p[0], p[1])\n        land[i].neighbors.forEach(function(e) {\n          if (cells[e].height >= 20 && cells[e].height < 30 && !cells[e].river && cells[e].used != 1) {\n            cells[e].used = 1\n            swamp += drawSwamp(cells[e].data[0], cells[e].data[1])\n          }\n        })\n        g.append('path').attr('d', round(swamp, 1))\n      }\n\n      // forest icons\n      if (Math.random() < height / 100 && height >= 22 && height < 48) {\n        for (let c = 0, a = area; Math.random() < a / 15; c++, a -= 15) {\n          if (land[i].ctype === 1 && c > 0) break\n          if (polygons[cell][c] === undefined) break\n          const g = forests.append('g').attr('data-cell', cell)\n          if (c === 0) {\n            cx = _.round(p[0] - 1 - Math.random(), 1)\n            cy = p[1] - 2\n          } else {\n            const p2 = polygons[cell][c]\n            if (c > 1) {\n              const dist = Math.hypot(p2[0] - polygons[cell][c - 1][0],\n                p2[1] - polygons[cell][c - 1][1])\n              if (dist < 2) continue\n            }\n            cx = (p[0] * 0.5 + p2[0] * 1.5) / 2\n            cy = (p[1] * 0.5 + p2[1] * 1.5) / 2 - 1\n          }\n          const forest = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 v0.75 h0.1 v-0.75 q0.95,-0.47 -0.05,-1.25 z '\n          const light = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 h0.1 q0.95,-0.47 -0.05,-1.25 z '\n          const shade = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 q-0.2,-0.55 0,-1.1 z '\n          g.append('path').attr('d', forest)\n          g.append('path').attr('d', light).attr('fill', 'white').attr('stroke', 'none')\n          g.append('path').attr('d', shade).attr('fill', '#999999').attr('stroke', 'none')\n        }\n      }\n    }\n    terrain.selectAll('g').selectAll('g').on('click', editReliefIcon)\n    console.timeEnd('drawRelief')\n  }\n\n  function addReliefIcon(height, type, cx, cy, cell) {\n    const g = terrain.select('#' + type).append('g').attr('data-cell', cell)\n    if (type === 'mounts') {\n      const h = height >= 0.7 ? (height - 0.55) * 12 : 1.8\n      const rnd = Math.random() * 0.8 + 0.2\n      let mount = 'M' + cx + ',' + cy + ' L' + (cx + h / 3 + rnd) + ',' + (cy - h / 4 - rnd * 1.2) + ' L' + (cx + h / 1.1) + ',' + (cy - h) + ' L' + (cx + h + rnd) + ',' + (cy - h / 1.2 + rnd) + ' L' + (cx + h * 2) + ',' + cy\n      let shade = 'M' + cx + ',' + cy + ' L' + (cx + h / 3 + rnd) + ',' + (cy - h / 4 - rnd * 1.2) + ' L' + (cx + h / 1.1) + ',' + (cy - h) + ' L' + (cx + h / 1.5) + ',' + cy\n      let dash = 'M' + (cx - 0.1) + ',' + (cy + 0.3) + ' L' + (cx + 2 * h + 0.1) + ',' + (cy + 0.3)\n      dash += 'M' + (cx + 0.4) + ',' + (cy + 0.6) + ' L' + (cx + 2 * h - 0.3) + ',' + (cy + 0.6)\n      g.append('path').attr('d', round(mount, 1)).attr('stroke', '#5c5c70')\n      g.append('path').attr('d', round(shade, 1)).attr('fill', '#999999')\n      g.append('path').attr('d', round(dash, 1)).attr('class', 'strokes')\n    }\n    if (type === 'hills') {\n      let h = height > 0.5 ? (height - 0.4) * 10 : 1.2\n      if (h > 1.8) h = 1.8\n      let hill = 'M' + cx + ',' + cy + ' Q' + (cx + h) + ',' + (cy - h) + ' ' + (cx + 2 * h) + ',' + cy\n      let shade = 'M' + (cx + 0.6 * h) + ',' + (cy + 0.1) + ' Q' + (cx + h * 0.95) + ',' + (cy - h * 0.91) + ' ' + (cx + 2 * h * 0.97) + ',' + cy\n      let dash = 'M' + (cx - 0.1) + ',' + (cy + 0.2) + ' L' + (cx + 2 * h + 0.1) + ',' + (cy + 0.2)\n      dash += 'M' + (cx + 0.4) + ',' + (cy + 0.4) + ' L' + (cx + 2 * h - 0.3) + ',' + (cy + 0.4)\n      g.append('path').attr('d', round(hill, 1)).attr('stroke', '#5c5c70')\n      g.append('path').attr('d', round(shade, 1)).attr('fill', 'white')\n      g.append('path').attr('d', round(dash, 1)).attr('class', 'strokes')\n    }\n    if (type === 'swamps') {\n      const swamp = drawSwamp(cx, cy)\n      g.append('path').attr('d', round(swamp, 1))\n    }\n    if (type === 'forests') {\n      const rnd = Math.random()\n      const h = rnd * 0.4 + 0.6\n      const forest = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 v0.75 h0.1 v-0.75 q0.95,-0.47 -0.05,-1.25 z '\n      const light = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 h0.1 q0.95,-0.47 -0.05,-1.25 z '\n      const shade = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 q-0.2,-0.55 0,-1.1 z '\n      g.append('path').attr('d', forest)\n      g.append('path').attr('d', light).attr('fill', 'white').attr('stroke', 'none')\n      g.append('path').attr('d', shade).attr('fill', '#999999').attr('stroke', 'none')\n    }\n    g.on('click', editReliefIcon)\n    return g\n  }\n\n  function compareY(a, b) {\n    if (a.data[1] > b.data[1]) return 1\n    if (a.data[1] < b.data[1]) return -1\n    return 0\n  }\n\n  function drawSwamp(x, y) {\n    const h = 0.6\n    let line = ''\n    for (let c = 0; c < 3; c++) {\n      let cx\n      let cy\n      if (c == 0) {\n        cx = x\n        cy = y - 0.5 - Math.random()\n      }\n      if (c == 1) {\n        cx = x + h + Math.random()\n        cy = y + h + Math.random()\n      }\n      if (c == 2) {\n        cx = x - h - Math.random()\n        cy = y + 2 * h + Math.random()\n      }\n      line +=\n        'M' + cx + ',' + cy + ' H' + (cx - h / 6) + ' M' + cx + ',' + cy + ' H' + (cx + h / 6) + ' M' + cx + ',' + cy + ' L' + (cx - h / 3) + ',' + (cy - h / 2) + ' M' + cx + ',' + cy + ' V' + (cy - h / 1.5) + ' M' + cx + ',' + cy + ' L' + (cx + h / 3) + ',' + (cy - h / 2)\n      line +=\n        'M' + (cx - h) + ',' + cy + ' H' + (cx - h / 2) + ' M' + (cx + h / 2) + ',' + cy + ' H' + (cx + h)\n    }\n    return line\n  }\n\n  // Complete the map for the \"customize\" mode\n  function getMap() {\n    if (customization !== 1) {\n      tip(\n        'Nothing to complete! Click on \"Edit\" or \"Clear all\" to enter a heightmap customization mode',\n        null, 'error')\n      return\n    }\n    if (+landmassCounter.innerHTML < 150) {\n      tip('Insufficient land area! Please add more land cells to complete the map', null,\n        'error')\n      return\n    }\n    exitCustomization()\n    console.time('TOTAL')\n    markFeatures()\n    drawOcean()\n    elevateLakes()\n    resolveDepressionsPrimary()\n    reGraph()\n    resolveDepressionsSecondary()\n    flux()\n    addLakes()\n    if (!changeHeights.checked) restoreCustomHeights()\n    drawCoastline()\n    drawRelief()\n    const keepData = states.length && manors.length\n    if (keepData) {\n      restoreRegions()\n    } else {\n      generateCultures()\n      manorsAndRegions()\n    }\n    cleanData()\n    console.timeEnd('TOTAL')\n  }\n\n  // Add support \"click to add\" button events\n  $('#customizeTab').click(clickToAdd)\n\n  function clickToAdd() {\n    if (modules.clickToAdd) return\n    modules.clickToAdd = true\n\n    // add label on click\n    $('#addLabel').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        closeDialogs('.stable')\n        viewbox.style('cursor', 'crosshair').on('click', addLabelOnClick)\n      }\n    })\n\n    function addLabelOnClick() {\n      const point = d3.mouse(this)\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n\n      // get culture in clicked point to generate a name\n      const closest = cultureTree.find(x, y)\n      const culture = cultureTree.data().indexOf(closest) || 0\n      const name = generateName(culture)\n\n      let group = labels.select('#addedLabels')\n      if (!group.size()) {\n        group = labels.append('g').attr('id', 'addedLabels')\n                      .attr('fill', '#3e3e4b').attr('opacity', 1)\n                      .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n                      .attr('font-size', 18).attr('data-size', 18)\n      }\n      let id = 'label' + Date.now().toString().slice(7)\n      group.append('text').attr('id', id).attr('x', x).attr('y', y).text(name)\n           .on('click', editLabel)\n\n      if (d3.event.shiftKey === false) {\n        $('#addLabel').removeClass('pressed')\n        restoreDefaultEvents()\n      }\n    }\n\n    // add burg on click\n    $('#addBurg').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n        tip('', true)\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).attr('data-state', -1).addClass('pressed')\n        $('#burgAdd, #burgAddfromEditor').addClass('pressed')\n        viewbox.style('cursor', 'crosshair').on('click', addBurgOnClick)\n        tip('Click on map to place burg icon with a label. Hold Shift to place several', true)\n      }\n    })\n\n    function addBurgOnClick() {\n      const point = d3.mouse(this)\n      const index = getIndex(point)\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n\n      // get culture in clicked point to generate a name\n      let culture = cells[index].culture\n      if (culture === undefined) culture = 0\n      const name = generateName(culture)\n\n      if (cells[index].height < 20) {\n        tip('Cannot place burg in the water! Select a land cell', null, 'error')\n        return\n      }\n      if (cells[index].manor !== undefined) {\n        tip('There is already a burg in this cell. Please select a free cell', null, 'error')\n        $('#grid').fadeIn()\n        d3.select('#toggleGrid').classed('buttonoff', false)\n        return\n      }\n      const i = manors.length\n      const size = burgIcons.select('#towns').attr('size')\n      burgIcons.select('#towns').append('circle').attr('id', 'burg' + i).attr('data-id', i)\n               .attr('cx', x).attr('cy', y).attr('r', size).on('click', editBurg)\n      burgLabels.select('#towns').append('text').attr('data-id', i).attr('x', x).attr('y', y)\n                .attr('dy', '-0.35em').text(name).on('click', editBurg)\n      invokeActiveZooming()\n\n      if (d3.event.shiftKey === false) {\n        $('#addBurg, #burgAdd, #burgAddfromEditor').removeClass('pressed')\n        restoreDefaultEvents()\n      }\n\n      let region, state = +$('#addBurg').attr('data-state')\n      if (state !== -1) {\n        region = states[state].capital === 'neutral' ? 'neutral' : state\n        const oldRegion = cells[index].region\n        if (region !== oldRegion) {\n          cells[index].region = region\n          redrawRegions()\n        }\n      } else {\n        region = cells[index].region\n        state = region === 'neutral' ? states.length - 1 : region\n      }\n      cells[index].manor = i\n      let score = cells[index].score\n      if (score <= 0) {score = _.round(Math.random(), 2)}\n      if (cells[index].crossroad) {score += cells[index].crossroad} // crossroads\n      if (cells[index].confluence) {score += Math.pow(cells[index].confluence, 0.3)} // confluences\n      if (cells[index].port !== undefined) {score *= 3} // port-capital\n      const population = _.round(score, 1)\n      manors.push({i, cell: index, x, y, region, culture, name, population})\n      recalculateStateData(state)\n      updateCountryEditors()\n      tip('', true)\n    }\n\n    // add river on click\n    $('#addRiver').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        unselect()\n      } else {\n        $('.pressed').removeClass('pressed')\n        unselect()\n        $(this).addClass('pressed')\n        closeDialogs('.stable')\n        viewbox.style('cursor', 'crosshair').on('click', addRiverOnClick)\n        tip('Click on map to place new river or extend an existing one', true)\n      }\n    })\n\n    function addRiverOnClick() {\n      const point = d3.mouse(this)\n      const index = diagram.find(point[0], point[1]).index\n      let cell = cells[index]\n      if (cell.river || cell.height < 20) return\n      const dataRiver = [] // to store river points\n      const last = $('#rivers > path').last()\n      const river = last.length ? +last.attr('id').slice(5) + 1 : 0\n      cell.flux = 0.85\n      while (cell) {\n        cell.river = river\n        const x = cell.data[0], y = cell.data[1]\n        dataRiver.push({x, y, cell: index})\n        const nHeights = []\n        cell.neighbors.forEach(function(e) {nHeights.push(cells[e].height)})\n        const minId = nHeights.indexOf(d3.min(nHeights))\n        const min = cell.neighbors[minId]\n        const tx = cells[min].data[0], ty = cells[min].data[1]\n        if (cells[min].height < 20) {\n          const px = (x + tx) / 2\n          const py = (y + ty) / 2\n          dataRiver.push({x: px, y: py, cell: index})\n          cell = undefined\n        } else {\n          if (cells[min].river === undefined) {\n            cells[min].flux += cell.flux\n            cell = cells[min]\n          } else {\n            const r = cells[min].river\n            const riverEl = $('#river' + r)\n            const riverCells = $.grep(land, function(e) {return e.river === r})\n            riverCells.sort(function(a, b) {return b.height - a.height})\n            const riverCellsUpper = $.grep(riverCells,\n              function(e) {return e.height > cells[min].height})\n            if (dataRiver.length > riverCellsUpper.length) {\n              // new river is more perspective\n              const avPrec = _.round(precInput.value / Math.sqrt(cells.length), 2)\n              let dataRiverMin = []\n              riverCells.map(function(c) {\n                if (c.height < cells[min].height) {\n                  cells[c.index].river = undefined\n                  cells[c.index].flux = avPrec\n                } else {\n                  dataRiverMin.push({x: c.data[0], y: c.data[1], cell: c.index})\n                }\n              })\n              cells[min].flux += cell.flux\n              if (cells[min].confluence) {\n                cells[min].confluence += riverCellsUpper.length\n              } else {cells[min].confluence = riverCellsUpper.length}\n              cell = cells[min]\n              // redraw old river's upper part or remove if small\n              if (dataRiverMin.length > 1) {\n                var riverAmended = amendRiver(dataRiverMin, 1)\n                var d = drawRiver(riverAmended, 1.3, 1)\n                riverEl.attr('d', d).attr('data-width', 1.3).attr('data-increment', 1)\n              } else {\n                riverEl.remove()\n                dataRiverMin.map(function(c) {cells[c.cell].river = undefined})\n              }\n            } else {\n              if (cells[min].confluence) {\n                cells[min].confluence += dataRiver.length\n              } else {cells[min].confluence = dataRiver.length}\n              cells[min].flux += cell.flux\n              dataRiver.push({x: tx, y: ty, cell: min})\n              cell = undefined\n            }\n          }\n        }\n      }\n      const rndFactor = 0.2 + Math.random() * 1.6 // random factor in range 0.2-1.8\n      var riverAmended = amendRiver(dataRiver, rndFactor)\n      var d = drawRiver(riverAmended, 1.3, 1)\n      rivers.append('path').attr('d', d).attr('id', 'river' + river)\n            .attr('data-width', 1.3).attr('data-increment', 1).on('click', editRiver)\n    }\n\n    // add relief icon on click\n    $('#addRelief').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        closeDialogs('.stable')\n        viewbox.style('cursor', 'crosshair').on('click', addReliefOnClick)\n        tip('Click on map to place relief icon. Hold Shift to place several', true)\n      }\n    })\n\n    function addReliefOnClick() {\n      const point = d3.mouse(this)\n      const index = getIndex(point)\n      const height = cells[index].height\n      if (height < 20) {\n        tip('Cannot place icon in the water! Select a land cell')\n        return\n      }\n\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n      const type = reliefGroup.value\n      addReliefIcon(height / 100, type, x, y, index)\n\n      if (d3.event.shiftKey === false) {\n        $('#addRelief').removeClass('pressed')\n        restoreDefaultEvents()\n      }\n      tip('', true)\n    }\n\n    // add route on click\n    $('#addRoute').click(function() {\n      if (!modules.editRoute) editRoute()\n      $('#routeNew').click()\n    })\n\n    // add marker on click\n    $('#addMarker').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        $('#markerAdd').addClass('pressed')\n        viewbox.style('cursor', 'crosshair').on('click', addMarkerOnClick)\n      }\n    })\n\n    function addMarkerOnClick() {\n      const point = d3.mouse(this)\n      let x = _.round(point[0], 2), y = _.round(point[1], 2)\n      let selected = markerSelectGroup.value\n      let valid = selected && d3.select('#defs-markers').select('#' + selected).size() === 1\n      let symbol = valid ? '#' + selected : '#marker0'\n      let desired = valid ? markers.select('[data-id=\\'' + symbol + '\\']').attr('data-size') : 1\n      if (isNaN(desired)) desired = 1\n      let id = 'marker' + Date.now().toString().slice(7) // unique id\n      let size = desired * 5 + 25 / scale\n\n      markers.append('use').attr('id', id).attr('xlink:href', symbol).attr('data-id', symbol)\n             .attr('data-x', x).attr('data-y', y).attr('x', x - size / 2).attr('y', y - size)\n             .attr('data-size', desired).attr('width', size).attr('height', size)\n             .on('click', editMarker)\n\n      if (d3.event.shiftKey === false) {\n        $('#addMarker, #markerAdd').removeClass('pressed')\n        restoreDefaultEvents()\n      }\n    }\n\n  }\n\n  // return cell / polly Index or error\n  function getIndex(point) {\n    let c = diagram.find(point[0], point[1])\n    if (!c) {\n      console.error('Cannot find closest cell for points' + point[0] + ', ' + point[1])\n      return\n    }\n    return c.index\n  }\n\n  // re-calculate data for a particular state\n  function recalculateStateData(state) {\n    const s = states[state] || states[states.length - 1]\n    if (s.capital === 'neutral') state = 'neutral'\n    const burgs = $.grep(manors, function(e) {return e.region === state})\n    s.burgs = burgs.length\n    let burgsPop = 0 // get summ of all burgs population\n    burgs.map(function(b) {burgsPop += b.population})\n    s.urbanPopulation = _.round(burgsPop, 1)\n    const regionCells = $.grep(cells, function(e) {return (e.region === state)})\n    let cellsPop = 0, area = 0\n    regionCells.map(function(c) {\n      cellsPop += c.pop\n      area += c.area\n    })\n    s.cells = regionCells.length\n    s.area = Math.round(area)\n    s.ruralPopulation = _.round(cellsPop, 1)\n  }\n\n  function changeSelectedOnClick() {\n    const point = d3.mouse(this)\n    const index = diagram.find(point[0], point[1]).index\n    if (cells[index].height < 20) return\n    $('.selected').removeClass('selected')\n    let color\n\n    // select state\n    if (customization === 2) {\n      const assigned = regions.select('#temp').select('path[data-cell=\\'' + index + '\\']')\n      let s = assigned.size() ? assigned.attr('data-state') : cells[index].region\n      if (s === 'neutral') s = states.length - 1\n      color = states[s].color\n      if (color === 'neutral') color = 'white'\n      $('#state' + s).addClass('selected')\n    }\n\n    // select culture\n    if (customization === 4) {\n      const assigned = cults.select('#cult' + index)\n      const c = assigned.attr('data-culture') !== null\n                ? +assigned.attr('data-culture')\n                : cells[index].culture\n      color = cultures[c].color\n      $('#culture' + c).addClass('selected')\n    }\n\n    debug.selectAll('.circle').attr('stroke', color)\n  }\n\n  // fetch default fonts if not done before\n  function loadDefaultFonts() {\n    if (!$('link[href=\"fonts.css\"]').length) {\n      $('head').append('<link rel=\"stylesheet\" type=\"text/css\" href=\"fonts.css\">')\n      const fontsToAdd = ['Amatic+SC:700', 'IM+Fell+English', 'Great+Vibes', 'MedievalSharp', 'Metamorphous',\n                          'Nova+Script', 'Uncial+Antiqua', 'Underdog', 'Caesar+Dressing', 'Bitter', 'Yellowtail', 'Montez',\n                          'Shadows+Into+Light', 'Fredericka+the+Great', 'Orbitron', 'Dancing+Script:700',\n                          'Architects+Daughter', 'Kaushan+Script', 'Gloria+Hallelujah', 'Satisfy', 'Comfortaa:700', 'Cinzel']\n      fontsToAdd.forEach(function(f) {if (FONTS.indexOf(f) === -1) FONTS.push(f)})\n      updateFontOptions()\n    }\n  }\n\n  function fetchFonts(url) {\n    return new Promise((resolve, reject) => {\n      if (url === '') {\n        tip(\n          'Use a direct link to any @font-face declaration or just font name to fetch from Google Fonts')\n        return\n      }\n      if (url.indexOf('http') === -1) {\n        url = url.replace(url.charAt(0), url.charAt(0).toUpperCase()).split(' ').join('+')\n        url = 'https://fonts.googleapis.com/css?family=' + url\n      }\n      const fetched = addFonts(url).then(fetched => {\n        if (fetched === undefined) {\n          tip('Cannot fetch font for this value!')\n          return\n        }\n        if (fetched === 0) {\n          tip('Already in the fonts list!')\n          return\n        }\n        updateFontOptions()\n        if (fetched === 1) {\n          tip('Font ' + FONTS[FONTS.length - 1] + ' is fetched')\n        } else if (fetched > 1) {\n          tip(fetched + ' fonts are added to the list')\n        }\n        resolve(fetched)\n      })\n    })\n  }\n\n  function addFonts(url) {\n    $('head').append('<link rel=\"stylesheet\" type=\"text/css\" href=\"' + url + '\">')\n    return fetch(url)\n      .then(resp => resp.text())\n      .then(text => {\n        let s = document.createElement('style')\n        s.innerHTML = text\n        document.head.appendChild(s)\n        let styleSheet = Array.prototype.filter.call(\n          document.styleSheets,\n          sS => sS.ownerNode === s)[0]\n        let FontRule = rule => {\n          let family = rule.style.getPropertyValue('font-family')\n          let font = family.replace(/['\"]+/g, '').replace(/ /g, '+')\n          let weight = rule.style.getPropertyValue('font-weight')\n          if (weight !== '400') font += ':' + weight\n          if (FONTS.indexOf(font) == -1) {\n            FONTS.push(font)\n            fetched++\n          }\n        }\n        let fetched = 0\n        for (let r of styleSheet.cssRules) {FontRule(r)}\n        document.head.removeChild(s)\n        return fetched\n      })\n      .catch(function() {})\n  }\n\n  // Update font list for Label and Burg Editors\n  function updateFontOptions() {\n    labelFontSelect.innerHTML = ''\n    for (let i = 0; i < FONTS.length; i++) {\n      const opt = document.createElement('option')\n      opt.value = i\n      const font = FONTS[i].split(':')[0].replace(/\\+/g, ' ')\n      opt.style.fontFamily = opt.innerHTML = font\n      labelFontSelect.add(opt)\n    }\n    burgSelectDefaultFont.innerHTML = labelFontSelect.innerHTML\n  }\n\n  // Save in .map format, based on FileSystem API\n  function saveMap() {\n    console.time('saveMap')\n    // data convention: 0 - params; 1 - all points; 2 - cells; 3 - manors; 4 - states;\n    // 5 - svg; 6 - options (see below); 7 - cultures;\n    // 8 - empty (former nameBase); 9 - empty (former nameBases); 10 - heights; 11 - notes;\n    // size stats: points = 6%, cells = 36%, manors and states = 2%, svg = 56%;\n    const date = new Date()\n    const dateString = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate()\n    const license = 'File can be loaded in azgaar.github.io/Fantasy-Map-Generator'\n    const params = version + '|' + license + '|' + dateString + '|' + seed\n    const options = customization + '|' +\n                    distanceUnit.value + '|' + distanceScale.value + '|' + areaUnit.value + '|' +\n                    barSize.value + '|' + barLabel.value + '|' + barBackOpacity.value + '|' + barBackColor.value + '|' +\n                    populationRate.value + '|' + urbanization.value\n\n    // set zoom / transform values to default\n    svg.attr('width', graphWidth).attr('height', graphHeight)\n    const transform = d3.zoomTransform(svg.node())\n    viewbox.attr('transform', null)\n    const oceanBack = ocean.select('rect')\n    const oceanShift = [oceanBack.attr('x'), oceanBack.attr('y'), oceanBack.attr(\n      'width'), oceanBack.attr('height')]\n    oceanBack.attr('x', 0).attr('y', 0).attr('width', graphWidth).attr('height', graphHeight)\n\n    const svg_xml = (new XMLSerializer()).serializeToString(svg.node())\n    const line = '\\r\\n'\n    let data = params + line + JSON.stringify(points) + line + JSON.stringify(cells) + line\n    data += JSON.stringify(manors) + line + JSON.stringify(\n      states) + line + svg_xml + line + options + line\n    data +=\n      JSON.stringify(cultures) + line + '' + line + '' + line + heights + line + JSON.stringify(\n      notes) + line\n    const dataBlob = new Blob([data], {type: 'text/plain'})\n    const dataURL = window.URL.createObjectURL(dataBlob)\n    const link = document.createElement('a')\n    link.download = 'fantasy_map_' + Date.now() + '.map'\n    link.href = dataURL\n    document.body.appendChild(link)\n    link.click()\n\n    // restore initial values\n    svg.attr('width', svgWidth).attr('height', svgHeight)\n    zoom.transform(svg, transform)\n    oceanBack.attr('x', oceanShift[0]).attr('y', oceanShift[1]).attr('width', oceanShift[2])\n             .attr('height', oceanShift[3])\n\n    console.timeEnd('saveMap')\n    window.setTimeout(function() {window.URL.revokeObjectURL(dataURL)}, 4000)\n  }\n\n  // Map Loader based on FileSystem API\n  $('#mapToLoad').change(function() {\n    console.time('loadMap')\n    closeDialogs()\n    const fileToLoad = this.files[0]\n    this.value = ''\n    uploadFile(fileToLoad)\n  })\n\n  function uploadFile(file, callback) {\n    console.time('loadMap')\n    const fileReader = new FileReader()\n    fileReader.onload = function(fileLoadedEvent) {\n      const dataLoaded = fileLoadedEvent.target.result\n      const data = dataLoaded.split('\\r\\n')\n      // data convention: 0 - params; 1 - all points; 2 - cells; 3 - manors; 4 - states;\n      // 5 - svg; 6 - options; 7 - cultures; 8 - none; 9 - none; 10 - heights; 11 - notes;\n      const params = data[0].split('|')\n      const mapVersion = params[0] || data[0]\n      if (mapVersion !== version) {\n        let message = `The Map version `\n        // mapVersion reference was not added to downloaded map before v. 0.52b, so I cannot support really old files\n        if (mapVersion.length <= 10) {\n          message += `(${mapVersion}) does not match the Generator version (${version}). The map will be auto-updated.\n                    In case of critical issues you may send the .map file\n                    <a href=\"mailto:maxganiev@yandex.ru?Subject=Map%20update%20request\" target=\"_blank\">to me</a>\n                    or just keep using\n                    <a href=\"https://github.com/Azgaar/Fantasy-Map-Generator/wiki/Changelog\" target=\"_blank\">an appropriate version</a>\n                    of the Generator`\n        } else if (!mapVersion || parseFloat(mapVersion) < 0.54) {\n          message += `you are trying to load is too old and cannot be updated. Please re-create the map or just keep using\n                    <a href=\"https://github.com/Azgaar/Fantasy-Map-Generator/wiki/Changelog\" target=\"_blank\">an archived version</a>\n                    of the Generator. Please note the Generator is still on demo and a lot of changes are being made every month`\n        }\n        alertMessage.innerHTML = message\n        $('#alert').dialog({\n          title: 'Warning', buttons: {\n            OK: function() {\n              loadDataFromMap(data)\n            }\n          }\n        })\n      } else {loadDataFromMap(data)}\n      if (mapVersion.length > 10) {console.error('Cannot load map') }\n    }\n    fileReader.readAsText(file, 'UTF-8')\n    if (callback) {callback()}\n  }\n\n  function loadDataFromMap(data) {\n    closeDialogs()\n    // update seed\n    const params = data[0].split('|')\n    if (params[3]) {\n      seed = params[3]\n      $('#optionsSeed').value = seed\n    }\n\n    // get options\n    if (data[0] === '0.52b' || data[0] === '0.53b') {\n      customization = 0\n    } else if (data[6]) {\n      const options = data[6].split('|')\n      customization = +options[0] || 0\n      if (options[1]) distanceUnit.value = options[1]\n      if (options[2]) distanceScale.value = options[2]\n      if (options[3]) areaUnit.value = options[3]\n      if (options[4]) barSize.value = options[4]\n      if (options[5]) barLabel.value = options[5]\n      if (options[6]) barBackOpacity.value = options[6]\n      if (options[7]) barBackColor.value = options[7]\n      if (options[8]) populationRate.value = options[8]\n      if (options[9]) urbanization.value = options[9]\n    }\n\n    // replace old svg\n    svg.remove()\n    if (data[0] === '0.52b' || data[0] === '0.53b') {\n      states = [] // no states data in old maps\n      document.body.insertAdjacentHTML('afterbegin', data[4])\n    } else {\n      states = JSON.parse(data[4])\n      document.body.insertAdjacentHTML('afterbegin', data[5])\n    }\n\n    svg = d3.select('svg')\n\n    // always change graph size to the size of loaded map\n    const nWidth = +svg.attr('width'), nHeight = +svg.attr('height')\n    graphWidth = nWidth\n    graphHeight = nHeight\n    voronoi = d3.voronoi().extent([[-1, -1], [graphWidth + 1, graphHeight + 1]])\n    zoom.translateExtent([[0, 0], [graphWidth, graphHeight]]).scaleExtent([1, 20])\n        .scaleTo(svg, 1)\n    viewbox.attr('transform', null)\n\n    // temporary fit loaded svg element to current canvas size\n    svg.attr('width', svgWidth).attr('height', svgHeight)\n    if (nWidth !== svgWidth || nHeight !== svgHeight) {\n      alertMessage.innerHTML =\n        `The loaded map has size ${nWidth} x ${nHeight} pixels, while the current canvas size is ${svgWidth} x ${svgHeight} pixels.\n                              Click \"Rescale\" to fit the map to the current canvas size. Click \"OK\" to browse the map without rescaling`\n      $('#alert').dialog({\n        title: 'Map size conflict',\n        buttons: {\n          Rescale: function() {\n            applyLoadedData(data)\n            // rescale loaded map\n            const xRatio = svgWidth / nWidth\n            const yRatio = svgHeight / nHeight\n            const scaleTo = _.round(Math.min(xRatio, yRatio), 4)\n            // calculate frames to scretch ocean background\n            const extent = (100 / scaleTo) + '%'\n            const xShift = (nWidth * scaleTo - svgWidth) / 2 / scaleTo\n            const yShift = (nHeight * scaleTo - svgHeight) / 2 / scaleTo\n            svg.select('#ocean').selectAll('rect').attr('x', xShift).attr('y', yShift)\n               .attr('width', extent).attr('height', extent)\n            zoom.translateExtent([[0, 0], [nWidth, nHeight]]).scaleExtent([scaleTo, 20])\n                .scaleTo(svg, scaleTo)\n            $(this).dialog('close')\n          },\n          OK: function() {\n            changeMapSize()\n            applyLoadedData(data)\n            $(this).dialog('close')\n          }\n        }\n      })\n    } else {\n      applyLoadedData(data)\n    }\n  }\n\n  function applyLoadedData(data) {\n    // redefine variables\n    defs = svg.select('#deftemp')\n    viewbox = svg.select('#viewbox')\n    ocean = viewbox.select('#ocean')\n    oceanLayers = ocean.select('#oceanLayers')\n    oceanPattern = ocean.select('#oceanPattern')\n    landmass = viewbox.select('#landmass')\n    grid = viewbox.select('#grid')\n    overlay = viewbox.select('#overlay')\n    terrs = viewbox.select('#terrs')\n    cults = viewbox.select('#cults')\n    routes = viewbox.select('#routes')\n    roads = routes.select('#roads')\n    trails = routes.select('#trails')\n    rivers = viewbox.select('#rivers')\n    terrain = viewbox.select('#terrain')\n    regions = viewbox.select('#regions')\n    borders = viewbox.select('#borders')\n    stateBorders = borders.select('#stateBorders')\n    neutralBorders = borders.select('#neutralBorders')\n    coastline = viewbox.select('#coastline')\n    lakes = viewbox.select('#lakes')\n    searoutes = routes.select('#searoutes')\n    labels = viewbox.select('#labels')\n    icons = viewbox.select('#icons')\n    markers = viewbox.select('#markers')\n    ruler = viewbox.select('#ruler')\n    debug = viewbox.select('#debug')\n\n    if (!d3.select('#defs-markers').size()) {\n      let symbol = '<g id=\"defs-markers\"><symbol id=\"marker0\" viewBox=\"0 0 30 30\"><path d=\"M6,19 l9,10 L24,19\" fill=\"#000000\" stroke=\"none\"></path><circle cx=\"15\" cy=\"15\" r=\"10\" stroke-width=\"1\" stroke=\"#000000\" fill=\"#ffffff\"></circle><text x=\"50%\" y=\"50%\" fill=\"#000000\" stroke-width=\"0\" stroke=\"#000000\" font-size=\"22px\" dominant-baseline=\"central\">?</text></symbol></g>'\n      let cont = document.getElementsByTagName('defs')\n      cont[0].insertAdjacentHTML('afterbegin', symbol)\n      markers = viewbox.append('g').attr('id', 'markers')\n    }\n\n    // version control: ensure required groups are created with correct data\n    if (!labels.select('#burgLabels').size()) {\n      labels.append('g').attr('id', 'burgLabels')\n      $('#labels #capitals, #labels #towns').detach().appendTo($('#burgLabels'))\n    }\n\n    if (!icons.select('#burgIcons').size()) {\n      icons.append('g').attr('id', 'burgIcons')\n      $('#icons #capitals, #icons #towns').detach().appendTo($('#burgIcons'))\n      icons.select('#burgIcons').select('#capitals').attr('size', 1).attr('fill-opacity', .7)\n           .attr('stroke-opacity', 1)\n      icons.select('#burgIcons').select('#towns').attr('size', .5).attr('fill-opacity', .7)\n           .attr('stroke-opacity', 1)\n    }\n\n    icons.selectAll('g').each(function() {\n      const size = this.getAttribute('font-size')\n      if (size === null || size === undefined) return\n      this.removeAttribute('font-size')\n      this.setAttribute('size', size)\n    })\n\n    icons.select('#burgIcons').selectAll('circle').each(function() {\n      this.setAttribute('r', this.parentNode.getAttribute('size'))\n    })\n\n    icons.selectAll('use').each(function() {\n      const size = this.parentNode.getAttribute('size')\n      if (size === null || size === undefined) return\n      this.setAttribute('width', size)\n      this.setAttribute('height', size)\n    })\n\n    if (!labels.select('#countries').size()) {\n      labels.append('g').attr('id', 'countries')\n            .attr('fill', '#3e3e4b').attr('opacity', 1)\n            .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n            .attr('font-size', 14).attr('data-size', 14)\n    }\n\n    burgLabels = labels.select('#burgLabels')\n    burgIcons = icons.select('#burgIcons')\n\n    // restore events\n    svg.call(zoom)\n    restoreDefaultEvents()\n    viewbox.on('touchmove mousemove', moved)\n    overlay.selectAll('*').call(d3.drag().on('start', elementDrag))\n    terrain.selectAll('g').selectAll('g').on('click', editReliefIcon)\n    labels.selectAll('text').on('click', editLabel)\n    icons.selectAll('circle, path, use').on('click', editIcon)\n    burgLabels.selectAll('text').on('click', editBurg)\n    burgIcons.selectAll('circle, path, use').on('click', editBurg)\n    rivers.selectAll('path').on('click', editRiver)\n    routes.selectAll('path').on('click', editRoute)\n    markers.selectAll('use').on('click', editMarker)\n    svg.select('#scaleBar').call(d3.drag().on('start', elementDrag)).on('click', editScale)\n    ruler.selectAll('g').call(d3.drag().on('start', elementDrag))\n    ruler.selectAll('g').selectAll('text').on('click', removeParent)\n    ruler.selectAll('.opisometer').selectAll('circle')\n         .call(d3.drag().on('start', opisometerEdgeDrag))\n    ruler.selectAll('.linear').selectAll('circle:not(.center)')\n         .call(d3.drag().on('drag', rulerEdgeDrag))\n    ruler.selectAll('.linear').selectAll('circle.center')\n         .call(d3.drag().on('drag', rulerCenterDrag))\n\n    // update data\n    const newPoints = []\n    riversData = [], queue = [], elSelected = ''\n    points = JSON.parse(data[1])\n    cells = JSON.parse(data[2])\n    manors = JSON.parse(data[3])\n    if (data[7]) cultures = JSON.parse(data[7])\n    if (data[7] === undefined) generateCultures()\n    if (data[11]) notes = JSON.parse(data[11])\n\n    // place random point\n    function placePoint() {\n      const x = Math.floor(Math.random() * graphWidth * 0.8 + graphWidth * 0.1)\n      const y = Math.floor(Math.random() * graphHeight * 0.8 + graphHeight * 0.1)\n      return [x, y]\n    }\n\n    // ensure each culure has a valid namesbase assigned, if not assign first base\n    if (!nameBase[0]) applyDefaultNamesData()\n    cultures.forEach(function(c) {\n      const b = c.base\n      if (b === undefined) c.base = 0\n      if (!nameBase[b] || !nameBases[b]) c.base = 0\n      if (c.center === undefined) c.center = placePoint()\n    })\n    const graphSizeAdj = 90 / Math.sqrt(cells.length, 2) // adjust to different graphSize\n\n    // cells validations\n    cells.forEach(function(c, d) {\n      // collect points\n      newPoints.push(c.data)\n\n      // update old 0-1 height range to a new 0-100 range\n      if (c.height < 1) c.height = Math.trunc(c.height * 100)\n      if (c.height === 1 && c.region !== undefined && c.flux !== undefined) c.height = 100\n\n      // check if there are any unavailable cultures\n      if (c.culture > cultures.length - 1) {\n        const center = [c.data[0], c.data[1]]\n        const cult = {name: 'AUTO_' + c.culture, color: '#ff0000', base: 0, center}\n        cultures.push(cult)\n      }\n\n      if (c.height >= 20) {\n        if (!polygons[d] || !polygons[d].length) return\n        // calculate area\n        if (c.area === undefined || isNaN(c.area)) {\n          const area = d3.polygonArea(polygons[d])\n          c.area = _.round(Math.abs(area), 2)\n        }\n        // calculate population\n        if (c.pop === undefined || isNaN(c.pop)) {\n          let population = 0\n          const elevationFactor = Math.pow((100 - c.height) / 100, 3)\n          population = elevationFactor * c.area * graphSizeAdj\n          if (c.region === 'neutral') population *= 0.5\n          c.pop = _.round(population, 1)\n        }\n        // if culture is undefined, set to 0\n        if (c.culture === undefined || isNaN(c.culture)) c.culture = 0\n      }\n    })\n\n    land = $.grep(cells, function(e) {return (e.height >= 20)})\n    calculateVoronoi(newPoints)\n\n    // get heights Uint8Array\n    if (data[10]) {heights = new Uint8Array(data[10].split(','))} else {\n      heights = new Uint8Array(points.length)\n      for (let i = 0; i < points.length; i++) {\n        const cell = diagram.find(points[i][0], points[i][1]).index\n        heights[i] = cells[cell].height\n      }\n    }\n\n    // restore Heightmap customization mode\n    if (customization === 1) {\n      optionsTrigger.click()\n      $('#customizeHeightmap, #customizationMenu').slideDown()\n      $('#openEditor').slideUp()\n      updateHistory()\n      customizeTab.click()\n      paintBrushes.click()\n      tip('The map is in Heightmap customization mode. Please finalize the Heightmap', true)\n    }\n    // restore Country Edition mode\n    if (customization === 2 || customization === 3) tip(\n      'The map is in Country Edition mode. Please complete the assignment', true)\n\n    // restore layers state\n    d3.select('#toggleCultures').classed('buttonoff', !cults.selectAll('path').size())\n    d3.select('#toggleHeight').classed('buttonoff', !terrs.selectAll('path').size())\n    d3.select('#toggleCountries').classed('buttonoff', regions.style('display') === 'none')\n    d3.select('#toggleRivers').classed('buttonoff', rivers.style('display') === 'none')\n    d3.select('#toggleOcean').classed('buttonoff', oceanPattern.style('display') === 'none')\n    d3.select('#toggleRelief').classed('buttonoff', terrain.style('display') === 'none')\n    d3.select('#toggleBorders').classed('buttonoff', borders.style('display') === 'none')\n    d3.select('#toggleIcons').classed('buttonoff', icons.style('display') === 'none')\n    d3.select('#toggleLabels').classed('buttonoff', labels.style('display') === 'none')\n    d3.select('#toggleRoutes').classed('buttonoff', routes.style('display') === 'none')\n    d3.select('#toggleGrid').classed('buttonoff', grid.style('display') === 'none')\n\n    // update map to support some old versions and fetch fonts\n    labels.selectAll('g').each(function(d) {\n      const el = d3.select(this)\n      if (el.attr('id') === 'burgLabels') return\n      const font = el.attr('data-font')\n      if (font && FONTS.indexOf(font) === -1) addFonts(\n        'https://fonts.googleapis.com/css?family=' + font)\n      if (!el.attr('data-size')) el.attr('data-size', +el.attr('font-size'))\n      if (el.style('display') === 'none') el.node().style.display = null\n    })\n\n    invokeActiveZooming()\n    console.timeEnd('loadMap')\n  }\n\n  // get square grid with some jirrering\n  function getJitteredGrid() {\n    let sizeMod = _.round((graphWidth + graphHeight) / 1500, 2) // screen size modifier\n    spacing = _.round(7.5 * sizeMod / graphSize, 2) // space between points before jirrering\n    const radius = spacing / 2 // square radius\n    const jittering = radius * 0.9 // max deviation\n    const jitter = function() {return Math.random() * 2 * jittering - jittering}\n    let points = []\n    for (let y = radius; y < graphHeight; y += spacing) {\n      for (let x = radius; x < graphWidth; x += spacing) {\n        let xj = _.round(x + jitter(), 2)\n        let yj = _.round(y + jitter(), 2)\n        points.push([xj, yj])\n      }\n    }\n    return points\n  }\n\n  // Hotkeys, see github.com/Azgaar/Fantasy-Map-Generator/wiki/Hotkeys\n  d3.select('body').on('keydown', function() {\n    const active = document.activeElement.tagName\n    if (active === 'INPUT' || active === 'SELECT' || active === 'TEXTAREA') return\n    const key = d3.event.keyCode\n    const ctrl = d3.event.ctrlKey\n    const p = d3.mouse(this)\n    if (key === 117) $('#randomMap').click() // \"F6\" for new map\n    else if (key === 27) closeDialogs() // Escape to close all dialogs\n    else if (key === 79) optionsTrigger.click() // \"O\" to toggle options\n    else if (key === 80) saveAsImage('png') // \"P\" to save as PNG\n    else if (key === 83) saveAsImage('svg') // \"S\" to save as SVG\n    else if (key === 77) saveMap() // \"M\" to save MAP file\n    else if (key === 76) mapToLoad.click() // \"L\" to load MAP\n    else if (key === 32) console.table(cells[diagram.find(p[0], p[1]).index]) // Space to log focused cell data\n    else if (key === 192) console.log(cells) // \"`\" to log cells data\n    else if (key === 66) console.table(manors) // \"B\" to log burgs data\n    else if (key === 67) console.table(states) // \"C\" to log countries data\n    else if (key === 70) console.table(features) // \"F\" to log features data\n    else if (key === 37) zoom.translateBy(svg, 10, 0) // Left to scroll map left\n    else if (key === 39) zoom.translateBy(svg, -10, 0) // Right to scroll map right\n    else if (key === 38) zoom.translateBy(svg, 0, 10) // Up to scroll map up\n    else if (key === 40) zoom.translateBy(svg, 0, -10) // Up to scroll map up\n    else if (key === 107) zoom.scaleBy(svg, 1.2) // Plus to zoom map up\n    else if (key === 109) zoom.scaleBy(svg, 0.8) // Minus to zoom map out\n    else if (key === 48 || key === 96) resetZoom() // 0 to reset zoom\n    else if (key === 49 || key === 97) zoom.scaleTo(svg, 1) // 1 to zoom to 1\n    else if (key === 50 || key === 98) zoom.scaleTo(svg, 2) // 2 to zoom to 2\n    else if (key === 51 || key === 99) zoom.scaleTo(svg, 3) // 3 to zoom to 3\n    else if (key === 52 || key === 100) zoom.scaleTo(svg, 4) // 4 to zoom to 4\n    else if (key === 53 || key === 101) zoom.scaleTo(svg, 5) // 5 to zoom to 5\n    else if (key === 54 || key === 102) zoom.scaleTo(svg, 6) // 6 to zoom to 6\n    else if (key === 55 || key === 103) zoom.scaleTo(svg, 7) // 7 to zoom to 7\n    else if (key === 56 || key === 104) zoom.scaleTo(svg, 8) // 8 to zoom to 8\n    else if (key === 57 || key === 105) zoom.scaleTo(svg, 9) // 9 to zoom to 9\n    else if (key === 9) $('#updateFullscreen').click() // Tab to fit map to fullscreen\n    else if (ctrl && key === 90) undo.click() // Ctrl + \"Z\" to toggle undo\n    else if (ctrl && key === 89) redo.click() // Ctrl + \"Y\" to toggle undo\n  })\n\n  // move layers on mapLayers dragging (jquery sortable)\n  function moveLayer(event, ui) {\n    const el = getLayer(ui.item.attr('id'))\n    if (el) {\n      const prev = getLayer(ui.item.prev().attr('id'))\n      const next = getLayer(ui.item.next().attr('id'))\n      if (prev) {el.insertAfter(prev)} else if (next) {el.insertBefore(next)}\n    }\n  }\n\n  // define connection between option layer buttons and actual svg groups\n  function getLayer(id) {\n    if (id === 'toggleGrid') {return $('#grid')}\n    if (id === 'toggleOverlay') {return $('#overlay')}\n    if (id === 'toggleHeight') {return $('#terrs')}\n    if (id === 'toggleCultures') {return $('#cults')}\n    if (id === 'toggleRoutes') {return $('#routes')}\n    if (id === 'toggleRivers') {return $('#rivers')}\n    if (id === 'toggleCountries') {return $('#regions')}\n    if (id === 'toggleBorders') {return $('#borders')}\n    if (id === 'toggleRelief') {return $('#terrain')}\n    if (id === 'toggleLabels') {return $('#labels')}\n    if (id === 'toggleIcons') {return $('#icons')}\n  }\n\n  // UI Button handlers\n  $('button, a, li, i').on('click', function() {\n    const id = this.id\n    const parent = this.parentNode.id\n    if (debug.selectAll('.tag').size()) {debug.selectAll('.tag, .line').remove()}\n    if (id === 'toggleCountries') {$('#regions').fadeToggle()}\n    if (id === 'toggleCultures') {toggleCultures()}\n    if (id === 'toggleFlux') {toggleFlux()}\n    if (parent === 'mapLayers' || parent === 'styleContent') {$(this).toggleClass('buttonoff')}\n    if (id === 'randomMap' || id === 'regenerate') {\n      changeSeed()\n      exitCustomization()\n      undraw()\n      resetZoom(1000)\n      generate()\n      return\n    }\n    if (id === 'editCountries') editCountries()\n    if (id === 'editCultures') editCultures()\n    if (id === 'editScale' || id === 'editScaleCountries' || id === 'editScaleBurgs') editScale()\n    if (id === 'countriesManually') {\n      customization = 2\n      tip('Click to select a country, drag the circle to re-assign', true)\n      mockRegions()\n      let temp = regions.append('g').attr('id', 'temp')\n      $('#countriesBottom').children().hide()\n      $('#countriesManuallyButtons').show()\n      // highlight capital cells as it's not allowed to change capital's state that way\n      states.map(function(s) {\n        if (s.capital === 'neutral' || s.capital === 'select') return\n        const capital = s.capital\n        const index = manors[capital].cell\n        temp.append('path')\n            .attr('data-cell', index).attr('data-state', s.i)\n            .attr('d', 'M' + polygons[index].join('L') + 'Z')\n            .attr('fill', s.color).attr('stroke', 'red').attr('stroke-width', .7)\n      })\n      viewbox.style('cursor', 'crosshair').call(drag).on('click', changeSelectedOnClick)\n    }\n    if (id === 'countriesRegenerate') {\n      customization = 3\n      tip('Manually change \"Expansion\" value for a country or click on \"Randomize\" button',\n        true)\n      mockRegions()\n      regions.append('g').attr('id', 'temp')\n      $('#countriesBottom').children().hide()\n      $('#countriesRegenerateButtons').show()\n      $('.statePower, .icon-resize-full, .stateCells, .icon-check-empty').toggleClass('hidden')\n      $('div[data-sortby=\\'expansion\\'],div[data-sortby=\\'cells\\']').toggleClass('hidden')\n    }\n    if (id === 'countriesManuallyComplete') {\n      debug.selectAll('.circle').remove()\n      const changedCells = regions.select('#temp').selectAll('path')\n      let changedStates = []\n      changedCells.each(function() {\n        const el = d3.select(this)\n        const cell = +el.attr('data-cell')\n        let stateOld = cells[cell].region\n        if (stateOld === 'neutral') {stateOld = states.length - 1}\n        const stateNew = +el.attr('data-state')\n        const region = states[stateNew].color === 'neutral' ? 'neutral' : stateNew\n        cells[cell].region = region\n        if (cells[cell].manor !== undefined) {manors[cells[cell].manor].region = region}\n        changedStates.push(stateNew, stateOld)\n      })\n      changedStates = [...new Set(changedStates)]\n      changedStates.map(function(s) {recalculateStateData(s)})\n      const last = states.length - 1\n      if (states[last].capital === 'neutral' && states[last].cells === 0) {\n        $('#state' + last).remove()\n        states.splice(-1)\n      }\n      $('#countriesManuallyCancel').click()\n      if (changedStates.length) {editCountries()}\n    }\n    if (id === 'countriesManuallyCancel') {\n      redrawRegions()\n      debug.selectAll('.circle').remove()\n      if (grid.style('display') === 'inline') {toggleGrid.click()}\n      if (labels.style('display') === 'none') {toggleLabels.click()}\n      $('#countriesBottom').children().show()\n      $('#countriesManuallyButtons, #countriesRegenerateButtons').hide()\n      $('.selected').removeClass('selected')\n      $('div[data-sortby=\\'expansion\\'],.statePower, .icon-resize-full').addClass('hidden')\n      $('div[data-sortby=\\'cells\\'],.stateCells, .icon-check-empty').removeClass('hidden')\n      customization = 0\n      restoreDefaultEvents()\n    }\n    if (id === 'countriesApply') {$('#countriesManuallyCancel').click()}\n    if (id === 'countriesRandomize') {\n      const mod = +powerInput.value * 2\n      $('.statePower').each(function(e, i) {\n        const state = +(this.parentNode.id).slice(5)\n        if (states[state].capital === 'neutral') return\n        const power = _.round(Math.random() * mod / 2 + 1, 1)\n        $(this).val(power)\n        $(this).parent().attr('data-expansion', power)\n        states[state].power = power\n      })\n      regenerateCountries()\n    }\n    if (id === 'countriesAddM' || id === 'countriesAddR' || id === 'countriesAddG') {\n      let i = states.length\n      // move neutrals to the last line\n      if (states[i - 1].capital === 'neutral') {\n        states[i - 1].i = i\n        i -= 1\n      }\n      var name = generateStateName(0)\n      const color = colors20(i)\n      states.push({\n        i,\n        color,\n        name,\n        capital: 'select',\n        cells: 0,\n        burgs: 0,\n        urbanPopulation: 0,\n        ruralPopulation: 0,\n        area: 0,\n        power: 1\n      })\n      states.sort(function(a, b) {return a.i - b.i})\n      editCountries()\n    }\n    if (id === 'countriesRegenerateNames') {\n      const editor = d3.select('#countriesBody')\n      states.forEach(function(s) {\n        if (s.capital === 'neutral') return\n        s.name = generateStateName(s.i)\n        labels.select('#regionLabel' + s.i).text(s.name)\n        editor.select('#state' + s.i).select('.stateName').attr('value', s.name)\n      })\n    }\n    if (id === 'countriesPercentage') {\n      var el = $('#countriesEditor')\n      if (el.attr('data-type') === 'absolute') {\n        el.attr('data-type', 'percentage')\n        const totalCells = land.length\n        const totalBurgs = +countriesFooterBurgs.innerHTML\n        let totalArea = countriesFooterArea.innerHTML\n        totalArea = getInteger(totalArea.split(' ')[0])\n        const totalPopulation = getInteger(countriesFooterPopulation.innerHTML)\n        $('#countriesBody > .states').each(function() {\n          const cells = Math.round($(this).attr('data-cells') / totalCells * 100)\n          const burgs = Math.round($(this).attr('data-burgs') / totalBurgs * 100)\n          const area = Math.round($(this).attr('data-area') / totalArea * 100)\n          const population = Math.round($(this).attr('data-population') / totalPopulation * 100)\n          $(this).children().filter('.stateCells').text(cells + '%')\n          $(this).children().filter('.stateBurgs').text(burgs + '%')\n          $(this).children().filter('.stateArea').text(area + '%')\n          $(this).children().filter('.statePopulation').val(population + '%')\n        })\n      } else {\n        el.attr('data-type', 'absolute')\n        editCountries()\n      }\n    }\n    if (id === 'countriesExport') {\n      if ($('.statePower').length === 0) {return}\n      const unit = areaUnit.value === 'square' ? distanceUnit.value + '2' : areaUnit.value\n      let data = 'Country,Capital,Cells,Burgs,Area (' + unit + '),Population\\n' // countries headers\n      $('#countriesBody > .states').each(function() {\n        const country = $(this).attr('data-country')\n        if (country === 'bottom') {data += 'neutral,'} else {data += country + ','}\n        const capital = $(this).attr('data-capital')\n        if (capital === 'bottom' || capital === 'select') {data += ','} else {\n          data += capital + ','\n        }\n        data += $(this).attr('data-cells') + ','\n        data += $(this).attr('data-burgs') + ','\n        data += $(this).attr('data-area') + ','\n        const population = +$(this).attr('data-population')\n        data += population + '\\n'\n      })\n      data += '\\nBurg,Country,Culture,Population\\n' // burgs headers\n      manors.map(function(m) {\n        if (m.region === 'removed') return // skip removed burgs\n        data += m.name + ','\n        const country = m.region === 'neutral' ? 'neutral' : states[m.region].name\n        data += country + ','\n        data += cultures[m.culture].name + ','\n        const population = m.population * urbanization.value * populationRate.value * 1000\n        data += population + '\\n'\n      })\n      const dataBlob = new Blob([data], {type: 'text/plain'})\n      const url = window.URL.createObjectURL(dataBlob)\n      const link = document.createElement('a')\n      document.body.appendChild(link)\n      link.download = 'countries_data' + Date.now() + '.csv'\n      link.href = url\n      link.click()\n      window.setTimeout(function() {window.URL.revokeObjectURL(url)}, 2000)\n    }\n\n    if (id === 'burgNamesImport') burgsListToLoad.click()\n\n    if (id === 'removeCountries') {\n      alertMessage.innerHTML = `Are you sure you want remove all countries?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove countries',\n        buttons: {\n          Cancel: function() {$(this).dialog('close')},\n          Remove: function() {\n            $(this).dialog('close')\n            $('#countriesBody').empty()\n            manors.map(function(m) {m.region = 'neutral'})\n            land.map(function(l) {l.region = 'neutral'})\n            states.map(function(s) {\n              const c = +s.capital\n              if (isNaN(c)) return\n              moveBurgToGroup(c, 'towns')\n            })\n            removeAllLabelsInGroup('countries')\n            regions.selectAll('path').remove()\n            states = []\n            states.push({i: 0, color: 'neutral', capital: 'neutral', name: 'Neutrals'})\n            recalculateStateData(0)\n            if ($('#burgsEditor').is(':visible')) {$('#burgsEditor').dialog('close')}\n            editCountries()\n          }\n        }\n      })\n    }\n    if (id === 'removeBurgs') {\n      alertMessage.innerHTML =\n        `Are you sure you want to remove all burgs associated with the country?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove associated burgs',\n        buttons: {\n          Cancel: function() {$(this).dialog('close')},\n          Remove: function() {\n            $(this).dialog('close')\n            const state = +$('#burgsEditor').attr('data-state')\n            const region = states[state].capital === 'neutral' ? 'neutral' : state\n            $('#burgsBody').empty()\n            manors.map(function(m) {\n              if (m.region !== region) {return}\n              m.region = 'removed'\n              cells[m.cell].manor = undefined\n              labels.select('[data-id=\\'' + m.i + '\\']').remove()\n              icons.selectAll('[data-id=\\'' + m.i + '\\']').remove()\n            })\n            states[state].urbanPopulation = 0\n            states[state].burgs = 0\n            states[state].capital = 'select'\n            if ($('#countriesEditor').is(':visible')) {\n              editCountries()\n              $('#burgsEditor').dialog('moveToTop')\n            }\n            burgsFooterBurgs.innerHTML = 0\n            burgsFooterPopulation.value = 0\n          }\n        }\n      })\n    }\n    if (id === 'changeCapital') {\n      if ($(this).hasClass('pressed')) {\n        $(this).removeClass('pressed')\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n      }\n    }\n    if (id === 'regenerateBurgNames') {\n      var s = +$('#burgsEditor').attr('data-state')\n      $('.burgName').each(function(e, i) {\n        const b = +(this.parentNode.id).slice(5)\n        const name = generateName(manors[b].culture)\n        $(this).val(name)\n        $(this).parent().attr('data-burg', name)\n        manors[b].name = name\n        labels.select('[data-id=\\'' + b + '\\']').text(name)\n      })\n      if ($('#countriesEditor').is(':visible')) {\n        if (states[s].capital === 'neutral') {return}\n        var c = states[s].capital\n        $('#state' + s).attr('data-capital', manors[c].name)\n        $('#state' + s + ' > .stateCapital').val(manors[c].name)\n      }\n    }\n    if (id === 'burgAdd') {\n      var state = +$('#burgsEditor').attr('data-state')\n      clickToAdd() // to load on click event function\n      $('#addBurg').click().attr('data-state', state)\n    }\n    if (id === 'toggleScaleBar') {$('#scaleBar').toggleClass('hidden')}\n    if (id === 'addRuler') {\n      $('#ruler').show()\n      const rulerNew = ruler.append('g').attr('class', 'linear')\n                            .call(d3.drag().on('start', elementDrag))\n      const factor = _.round(1 / Math.pow(scale, 0.3), 1)\n      const y = Math.floor(Math.random() * graphHeight * 0.5 + graphHeight * 0.25)\n      const x1 = graphWidth * 0.2, x2 = graphWidth * 0.8\n      const dash = _.round(30 / distanceScale.value, 2)\n      rulerNew.append('line').attr('x1', x1).attr('y1', y).attr('x2', x2).attr('y2', y)\n              .attr('class', 'white').attr('stroke-width', factor)\n      rulerNew.append('line').attr('x1', x1).attr('y1', y).attr('x2', x2).attr('y2', y)\n              .attr('class', 'gray').attr('stroke-width', factor).attr('stroke-dasharray', dash)\n      rulerNew.append('circle').attr('r', 2 * factor).attr('stroke-width', 0.5 * factor)\n              .attr('cx', x1).attr('cy', y).attr('data-edge', 'left')\n              .call(d3.drag().on('drag', rulerEdgeDrag))\n      rulerNew.append('circle').attr('r', 2 * factor).attr('stroke-width', 0.5 * factor)\n              .attr('cx', x2).attr('cy', y).attr('data-edge', 'rigth')\n              .call(d3.drag().on('drag', rulerEdgeDrag))\n      rulerNew.append('circle').attr('r', 1.2 * factor).attr('stroke-width', 0.3 * factor)\n              .attr('cx', graphWidth / 2).attr('cy', y).attr('class', 'center')\n              .call(d3.drag().on('start', rulerCenterDrag))\n      const dist = Math.round(x2 - x1)\n      const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      rulerNew.append('text').attr('x', graphWidth / 2).attr('y', y).attr('dy', -1)\n              .attr('data-dist', dist).text(label).text(label).on('click', removeParent)\n              .attr('font-size', 10 * factor)\n      return\n    }\n    if (id === 'addOpisometer' || id === 'addPlanimeter') {\n      if ($(this).hasClass('pressed')) {\n        restoreDefaultEvents()\n        $(this).removeClass('pressed')\n      } else {\n        $(this).addClass('pressed')\n        viewbox.style('cursor', 'crosshair').call(drag)\n      }\n      return\n    }\n    if (id === 'removeAllRulers') {\n      if ($('#ruler > g').length < 1) {return}\n      alertMessage.innerHTML = `Are you sure you want to remove all placed rulers?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove all rulers',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            $('#ruler > g').remove()\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n      return\n    }\n    if (id === 'editHeightmap') {$('#customizeHeightmap').slideToggle()}\n    if (id === 'fromScratch') {\n      alertMessage.innerHTML =\n        'Are you sure you want to clear the map? All progress will be lost'\n      $('#alert').dialog({\n        resizable: false, title: 'Clear map',\n        buttons: {\n          Clear: function() {\n            closeDialogs()\n            undraw()\n            placePoints()\n            calculateVoronoi(points)\n            detectNeighbors('grid')\n            drawScaleBar()\n            customizeHeightmap()\n            openBrushesPanel()\n            $(this).dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    }\n    if (id === 'fromHeightmap') {\n      const message = `Hightmap is a basic element on which secondary data (rivers, burgs, countries etc) is based.\n    If you want to significantly change the hightmap, it may be better to clean up all the secondary data\n    and let the system to re-generate it based on the updated hightmap. In case of minor changes, you can keep the data.\n    Newly added lands will be considered as neutral. Burgs located on a removed land cells will be deleted.\n    Rivers and small lakes will be re-gerenated based on updated heightmap. Routes won't be regenerated.`\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Edit Heightmap',\n        buttons: {\n          'Clean up': function() {\n            editHeightmap('clean')\n            $(this).dialog('close')\n          },\n          Keep: function() {\n            $(this).dialog('close')\n            editHeightmap('keep')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n      return\n    }\n    // heightmap customization buttons\n    if (customization === 1) {\n      if (id === 'paintBrushes') {openBrushesPanel()}\n      if (id === 'rescaleExecute') {\n        const subject = rescaleLower.value + '-' + rescaleHigher.value\n        const sign = conditionSign.value\n        let modifier = rescaleModifier.value\n        if (sign === '×') {modifyHeights(subject, 0, +modifier)}\n        if (sign === '÷') {modifyHeights(subject, 0, (1 / modifier))}\n        if (sign === '+') {modifyHeights(subject, +modifier, 1)}\n        if (sign === '-') {modifyHeights(subject, (-1 * modifier), 1)}\n        if (sign === '^') {modifyHeights(subject, 0, '^' + modifier)}\n        updateHeightmap()\n        updateHistory()\n      }\n      if (id === 'rescaleButton') {\n        $('#modifyButtons').children().not('#rescaleButton, .condition').toggle()\n      }\n      if (id === 'rescaleCondButton') {\n        $('#modifyButtons').children().not('#rescaleCondButton, #rescaler').toggle()\n      }\n      if (id === 'undo' || id === 'templateUndo') {restoreHistory(historyStage - 1)}\n      if (id === 'redo' || id === 'templateRedo') {restoreHistory(historyStage + 1)}\n      if (id === 'smoothHeights') {\n        smoothHeights(4)\n        updateHeightmap()\n        updateHistory()\n      }\n      if (id === 'disruptHeights') {\n        disruptHeights()\n        updateHeightmap()\n        updateHistory()\n      }\n      if (id === 'getMap') getMap()\n      if (id === 'applyTemplate') {\n        if ($('#templateEditor').is(':visible')) {return}\n        $('#templateEditor').dialog({\n          title: 'Template Editor',\n          minHeight: 'auto', width: 'auto', resizable: false,\n          position: {my: 'right top', at: 'right-10 top+10', of: 'svg'}\n        })\n      }\n      if (id === 'convertImage') {convertImage()}\n      if (id === 'convertImageGrid') {$('#grid').fadeToggle()}\n      if (id === 'convertImageHeights') {$('#landmass').fadeToggle()}\n      if (id === 'perspectiveView') {\n        if ($('#perspectivePanel').is(':visible')) return\n        $('#perspectivePanel').dialog({\n          title: 'Perspective View',\n          width: 520, height: 190,\n          position: {my: 'center center', at: 'center center', of: 'svg'}\n        })\n        drawPerspective()\n        return\n      }\n    }\n    if (parent === 'mapFilters') {\n      $('svg').attr('filter', '')\n      if ($(this).hasClass('pressed')) {\n        $('#mapFilters .pressed').removeClass('pressed')\n      } else {\n        $('#mapFilters .pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        $('svg').attr('filter', 'url(#filter-' + id + ')')\n      }\n      return\n    }\n    if (id === 'updateFullscreen') {\n      mapWidthInput.value = window.innerWidth\n      mapHeightInput.value = window.innerHeight\n      localStorage.removeItem('mapHeight')\n      localStorage.removeItem('mapWidth')\n      changeMapSize()\n    }\n    if (id === 'zoomExtentDefault') {\n      zoomExtentMin.value = 1\n      zoomExtentMax.value = 20\n      zoom.scaleExtent([1, 20]).scaleTo(svg, 1)\n    }\n    if (id === 'saveButton') {$('#saveDropdown').slideToggle()}\n    if (id === 'loadMap') {mapToLoad.click()}\n    if (id === 'zoomReset') {resetZoom(1000)}\n    if (id === 'zoomPlus') {\n      scale += 1\n      if (scale > 40) {scale = 40}\n      invokeActiveZooming()\n    }\n    if (id === 'zoomMinus') {\n      scale -= 1\n      if (scale <= 1) {\n        scale = 1\n        viewX = 0\n        viewY = 0\n      }\n      invokeActiveZooming()\n    }\n    if (id === 'styleFontPlus' || id === 'styleFontMinus') {\n      var el = viewbox.select('#' + styleElementSelect.value)\n      var mod = id === 'styleFontPlus' ? 1.1 : 0.9\n      el.selectAll('g').each(function() {\n        const el = d3.select(this)\n        let size = _.round(el.attr('data-size') * mod, 2)\n        if (size < 2) {size = 2}\n        el.attr('data-size', size).attr('font-size', _.round((size + (size / scale)) / 2, 2))\n      })\n      invokeActiveZooming()\n      return\n    }\n    if (id === 'brushClear') {\n      if (customization === 1) {\n        var message = 'Are you sure you want to clear the map?'\n        alertMessage.innerHTML = message\n        $('#alert').dialog({\n          resizable: false, title: 'Clear map',\n          buttons: {\n            Clear: function() {\n              $(this).dialog('close')\n              viewbox.style('cursor', 'crosshair').call(drag)\n              landmassCounter.innerHTML = '0'\n              $('#landmass').empty()\n              heights = new Uint8Array(heights.length)\n              // clear history\n              history = []\n              historyStage = 0\n              updateHistory()\n              redo.disabled = templateRedo.disabled = true\n              undo.disabled = templateUndo.disabled = true\n            },\n            Cancel: function() {$(this).dialog('close')}\n          }\n        })\n      } else {\n        start.click()\n      }\n    }\n    if (id === 'templateComplete') getMap()\n    if (id === 'convertColorsMinus') {\n      var current = +convertColors.value - 1\n      if (current < 4) {current = 3}\n      convertColors.value = current\n      heightsFromImage(current)\n    }\n    if (id === 'convertColorsPlus') {\n      var current = +convertColors.value + 1\n      if (current > 255) {current = 256}\n      convertColors.value = current\n      heightsFromImage(current)\n    }\n    if (id === 'convertOverlayButton') {\n      $('#convertImageButtons').children().not(this).not('#convertColors').toggle()\n    }\n    if (id === 'convertAutoLum') {autoAssing('lum')}\n    if (id === 'convertAutoHue') {autoAssing('hue')}\n    if (id === 'convertComplete') {completeConvertion()}\n  })\n\n  // support save options\n  $('#saveDropdown > div').click(function() {\n    const id = this.id\n    let dns_allow_popup_message = localStorage.getItem('dns_allow_popup_message')\n    if (!dns_allow_popup_message) {\n      localStorage.clear()\n      let message = 'Generator uses pop-up window to download files. '\n      message += 'Please ensure your browser does not block popups. '\n      message += 'Please check browser settings and turn off adBlocker if it is enabled'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        title: 'File saver. Please enable popups!',\n        buttons: {\n          'Don\\'t show again': function() {\n            localStorage.setItem('dns_allow_popup_message', true)\n            $(this).dialog('close')\n          },\n          Close: function() {$(this).dialog('close')}\n        },\n        position: {my: 'center', at: 'center', of: 'svg'}\n      })\n    }\n    if (id === 'saveMap') {saveMap()}\n    if (id === 'saveSVG') {saveAsImage('svg')}\n    if (id === 'savePNG') {saveAsImage('png')}\n    $('#saveDropdown').slideUp('fast')\n  })\n\n  function editHeightmap(type) {\n    closeDialogs()\n    const regionData = [], cultureData = []\n    if (type !== 'clean') {\n      for (let i = 0; i < points.length; i++) {\n        let cell = diagram.find(points[i][0], points[i][1]).index\n        // if closest cell is a small lake, try to find a land neighbor\n        if (cells[cell].lake === 2) cells[cell].neighbors.forEach(function(n) {\n          if (cells[n].height >= 20) {cell = n }\n        })\n        let region = cells[cell].region\n        if (region === undefined) region = -1\n        regionData.push(region)\n        let culture = cells[cell].culture\n        if (culture === undefined) culture = -1\n        cultureData.push(culture)\n      }\n    } else {undraw()}\n    calculateVoronoi(points)\n    detectNeighbors('grid')\n    drawScaleBar()\n    if (type === 'keep') {\n      svg.selectAll(\n        '#lakes, #coastline, #terrain, #rivers, #grid, #terrs, #landmass, #ocean, #regions')\n         .selectAll('path, circle, line').remove()\n      svg.select('#shape').remove()\n      for (let i = 0; i < points.length; i++) {\n        if (regionData[i] !== -1) cells[i].region = regionData[i]\n        if (cultureData[i] !== -1) cells[i].culture = cultureData[i]\n      }\n    }\n    mockHeightmap()\n    customizeHeightmap()\n    openBrushesPanel()\n  }\n\n  function openBrushesPanel() {\n    if ($('#brushesPanel').is(':visible')) {return}\n    $('#brushesPanel').dialog({\n      title: 'Paint Brushes',\n      minHeight: 40, width: 'auto', maxWidth: 200, resizable: false,\n      position: {my: 'right top', at: 'right-10 top+10', of: 'svg'}\n    }).on('dialogclose', function() {\n      restoreDefaultEvents()\n      $('#brushesButtons > .pressed').removeClass('pressed')\n    })\n\n    if (modules.openBrushesPanel) return\n    modules.openBrushesPanel = true\n\n    $('#brushesButtons > button').on('click', function() {\n      const rSlider = $('#brushRadiusLabel, #brushRadius')\n      debug.selectAll('.circle, .tag, .line').remove()\n      if ($(this).hasClass('pressed')) {\n        $(this).removeClass('pressed')\n        restoreDefaultEvents()\n        rSlider.attr('disabled', true).addClass('disabled')\n      } else {\n        $('#brushesButtons > .pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        viewbox.style('cursor', 'crosshair')\n        const id = this.id\n        if (id === 'brushRange' || id === 'brushTrough') {\n          viewbox.on('click', placeLinearFeature)\n        } // on click brushes\n        else {viewbox.call(drag).on('click', null)} // on drag brushes\n        if ($(this).hasClass('feature')) {\n          rSlider.attr('disabled', true).addClass('disabled')\n        } else {rSlider.attr('disabled', false).removeClass('disabled')}\n      }\n    })\n  }\n\n  function drawPerspective() {\n    console.time('drawPerspective')\n    const width = 320, height = 180\n    const wRatio = graphWidth / width, hRatio = graphHeight / height\n    const lineCount = 320, lineGranularity = 90\n    const perspective = document.getElementById('perspective')\n    const pContext = perspective.getContext('2d')\n    const lines = []\n    let i = lineCount\n    while (i--) {\n      const x = i / lineCount * width | 0\n      const canvasPoints = []\n      lines.push(canvasPoints)\n      let j = Math.floor(lineGranularity)\n      while (j--) {\n        const y = j / lineGranularity * height | 0\n        let index = getCellIndex(x * wRatio, y * hRatio)\n        let h = heights[index] - 20\n        if (h < 1) h = 0\n        canvasPoints.push([x, y, h])\n      }\n    }\n    pContext.clearRect(0, 0, perspective.width, perspective.height)\n    for (let canvasPoints of lines) {\n      for (let i = 0; i < canvasPoints.length - 1; i++) {\n        const pt1 = canvasPoints[i]\n        const pt2 = canvasPoints[i + 1]\n        const avHeight = (pt1[2] + pt2[2]) / 200\n        pContext.beginPath()\n        pContext.moveTo(...transformPt(pt1))\n        pContext.lineTo(...transformPt(pt2))\n        let clr = 'rgb(81, 103, 169)' // water\n        if (avHeight !== 0) {clr = color(1 - avHeight - 0.2)}\n        pContext.strokeStyle = clr\n        pContext.stroke()\n      }\n      for (let i = 0; i < canvasPoints.length - 1; i++) {\n\n      }\n    }\n    console.timeEnd('drawPerspective')\n  }\n\n  // get square grid cell index based on coords\n  function getCellIndex(x, y) {\n    const index = diagram.find(x, y).index\n    // let cellsX = Math.round(graphWidth / spacing);\n    // let index = Math.ceil(y / spacing) * cellsX + Math.round(x / spacing);\n    return index\n  }\n\n  function transformPt(pt) {\n    const width = 320, maxHeight = 0.2\n    var [x, y] = projectIsometric(pt[0], pt[1])\n    return [x + width / 2 + 10, y + 10 - pt[2] * maxHeight]\n  }\n\n  function projectIsometric(x, y) {\n    const scale = 1, yProj = 4\n    return [(x - y) * scale, (x + y) / yProj * scale]\n  }\n\n  // Execute custom template\n  $('#templateRun').on('click', function() {\n    if (customization !== 1) return\n    let steps = $('#templateBody > div').length\n    if (!steps) return\n    heights = new Uint8Array(heights.length) // clean all heights\n    for (let step = 1; step <= steps; step++) {\n      const type = $('#templateBody div:nth-child(' + step + ')').attr('data-type')\n      if (type === 'Mountain') {\n        addMountain()\n        continue\n      }\n      let count = $('#templateBody div:nth-child(' + step + ') .templateElCount').val()\n      const dist = $('#templateBody div:nth-child(' + step + ') .templateElDist').val()\n      if (count) {\n        if (count[0] !== '-' && count.includes('-')) {\n          const lim = count.split('-')\n          count = Math.floor(Math.random() * (+lim[1] - +lim[0] + 1) + +lim[0])\n        } else {\n          count = +count // parse string\n        }\n      }\n      if (type === 'Hill') {addHill(count, +dist)}\n      if (type === 'Pit') {addPit(count)}\n      if (type === 'Range') {addRange(count)}\n      if (type === 'Trough') {addRange(-1 * count)}\n      if (type === 'Strait') {addStrait(count)}\n      if (type === 'Add') {modifyHeights(dist, count, 1)}\n      if (type === 'Multiply') {modifyHeights(dist, 0, count)}\n      if (type === 'Smooth') {smoothHeights(count)}\n    }\n    mockHeightmap()\n    updateHistory()\n  })\n\n  $('#templateToLoad').change(function() {\n    const fileToLoad = this.files[0]\n    this.value = ''\n    const fileReader = new FileReader()\n    fileReader.onload = function(fileLoadedEvent) {\n      const dataLoaded = fileLoadedEvent.target.result\n      const data = dataLoaded.split('\\r\\n')\n      $('#templateBody').empty()\n      if (data.length > 0) {\n        $('#templateBody').attr('data-changed', 1)\n        $('#templateSelect').attr('data-prev', 'templateCustom').val('templateCustom')\n      }\n      for (let i = 0; i < data.length; i++) {\n        const line = data[i].split(' ')\n        this.addStep(line[0], line[1], line[2])\n      }\n    }\n    fileReader.readAsText(fileToLoad, 'UTF-8')\n  })\n\n  // Image to Heightmap Converter dialog\n  function convertImage() {\n    canvas.width = svgWidth\n    canvas.height = svgHeight\n    // turn off paint brushes drag and cursor\n    $('.pressed').removeClass('pressed')\n    restoreDefaultEvents()\n    const div = d3.select('#colorScheme')\n    if (div.selectAll('*').size() === 0) {\n      for (let i = 0; i <= 100; i++) {\n        let width = i < 20 || i > 70 ? '1px' : '3px'\n        if (i === 0) width = '4px'\n        const clr = color(1 - i / 100)\n        const style = 'background-color: ' + clr + '; width: ' + width\n        div.append('div').attr('data-color', i).attr('style', style)\n      }\n      div.selectAll('*').on('touchmove mousemove', showHeight).on('click', assignHeight)\n    }\n    if ($('#imageConverter').is(':visible')) {return}\n    $('#imageConverter').dialog({\n      title: 'Image to Heightmap Converter',\n      minHeight: 30, width: 260, resizable: false,\n      position: {my: 'right top', at: 'right-10 top+10', of: 'svg'}\n    })\n                        .on('dialogclose', function() {completeConvertion()})\n  }\n\n  // Load image to convert\n  $('#convertImageLoad').on('click', function() {imageToLoad.click()})\n  $('#imageToLoad').change(function() {\n    console.time('loadImage')\n    // set style\n    resetZoom()\n    grid.attr('stroke-width', .2)\n    // load image\n    const file = this.files[0]\n    this.value = '' // reset input value to get triggered if the same file is uploaded\n    const reader = new FileReader()\n    const img = new Image\n    // draw image\n    img.onload = function() {\n      ctx.drawImage(img, 0, 0, svgWidth, svgHeight)\n      heightsFromImage(+convertColors.value)\n      console.timeEnd('loadImage')\n    }\n    reader.onloadend = function() {img.src = reader.result}\n    reader.readAsDataURL(file)\n  })\n\n  function heightsFromImage(count) {\n    const imageData = ctx.getImageData(0, 0, svgWidth, svgHeight)\n    const data = imageData.data\n    $('#landmass > path, .color-div').remove()\n    $('#landmass, #colorsUnassigned').fadeIn()\n    $('#colorsAssigned').fadeOut()\n    const colors = [], palette = []\n    points.map(function(i) {\n      let x = Math.round(i[0]), y = Math.round(i[1])\n      if (y == svgHeight) {y--}\n      if (x == svgWidth) {x--}\n      const p = (x + y * svgWidth) * 4\n      const r = data[p], g = data[p + 1], b = data[p + 2]\n      colors.push([r, g, b])\n    })\n    const cmap = quantize(colors, count)\n    heights = new Uint8Array(points.length)\n    polygons.map(function(i, d) {\n      const nearest = cmap.nearest(colors[d])\n      const rgb = 'rgb(' + nearest[0] + ', ' + nearest[1] + ', ' + nearest[2] + ')'\n      const hex = toHEX(rgb)\n      if (palette.indexOf(hex) === -1) {palette.push(hex)}\n      landmass.append('path')\n              .attr('d', 'M' + i.join('L') + 'Z').attr('data-i', d)\n              .attr('fill', hex).attr('stroke', hex)\n    })\n    landmass.selectAll('path').on('click', landmassClicked)\n    palette.sort(function(a, b) {return d3.lab(a).b - d3.lab(b).b}).map(function(i) {\n      $('#colorsUnassigned').append(\n        '<div class=\"color-div\" id=\"' + i.substr(1) + '\" style=\"background-color: ' + i + ';\"/>')\n    })\n    $('.color-div').click(selectColor)\n  }\n\n  function landmassClicked() {\n    const color = d3.select(this).attr('fill')\n    $('#' + color.slice(1)).click()\n  }\n\n  function selectColor() {\n    landmass.selectAll('.selectedCell').classed('selectedCell', 0)\n    const el = d3.select(this)\n    if (el.classed('selectedColor')) {\n      el.classed('selectedColor', 0)\n    } else {\n      $('.selectedColor').removeClass('selectedColor')\n      el.classed('selectedColor', 1)\n      $('#colorScheme .hoveredColor').removeClass('hoveredColor')\n      $('#colorsSelectValue').text(0)\n      if (el.attr('data-height')) {\n        const height = el.attr('data-height')\n        $('#colorScheme div[data-color=\\'' + height + '\\']').addClass('hoveredColor')\n        $('#colorsSelectValue').text(height)\n      }\n      const color = '#' + d3.select(this).attr('id')\n      landmass.selectAll('path').classed('selectedCell', 0)\n      landmass.selectAll('path[fill=\\'' + color + '\\']').classed('selectedCell', 1)\n    }\n  }\n\n  function showHeight() {\n    let el = d3.select(this)\n    let height = el.attr('data-color')\n    $('#colorsSelectValue').text(height)\n    $('#colorScheme .hoveredColor').removeClass('hoveredColor')\n    el.classed('hoveredColor', 1)\n  }\n\n  function assignHeight() {\n    const sel = $('.selectedColor')[0]\n    const height = +d3.select(this).attr('data-color')\n    const rgb = color(1 - height / 100)\n    const hex = toHEX(rgb)\n    sel.style.backgroundColor = rgb\n    sel.setAttribute('data-height', height)\n    const cur = '#' + sel.id\n    sel.id = hex.substr(1)\n    landmass.selectAll('.selectedCell').each(function() {\n      d3.select(this).attr('fill', hex).attr('stroke', hex)\n      let i = +d3.select(this).attr('data-i')\n      heights[i] = height\n    })\n    const parent = sel.parentNode\n    if (parent.id === 'colorsUnassigned') {\n      colorsAssigned.appendChild(sel)\n      $('#colorsAssigned').fadeIn()\n      if ($('#colorsUnassigned .color-div').length < 1) {$('#colorsUnassigned').fadeOut()}\n    }\n    if ($('#colorsAssigned .color-div').length > 1) {sortAssignedColors()}\n  }\n\n  // sort colors based on assigned height\n  function sortAssignedColors() {\n    const data = []\n    const colors = d3.select('#colorsAssigned').selectAll('.color-div')\n    colors.each(function(d) {\n      const id = d3.select(this).attr('id')\n      const height = +d3.select(this).attr('data-height')\n      data.push({id, height})\n    })\n    data.sort(function(a, b) {return a.height - b.height}).map(function(i) {\n      $('#colorsAssigned').append($('#' + i.id))\n    })\n  }\n\n  // auto assign color based on luminosity or hue\n  function autoAssing(type) {\n    const imageData = ctx.getImageData(0, 0, svgWidth, svgHeight)\n    const data = imageData.data\n    $('#landmass > path, .color-div').remove()\n    $('#colorsAssigned').fadeIn()\n    $('#colorsUnassigned').fadeOut()\n    polygons.forEach(function(i, d) {\n      let x = Math.round(i.data[0]), y = Math.round(i.data[1])\n      if (y == svgHeight) y--\n      if (x == svgWidth) x--\n      const p = (x + y * svgWidth) * 4\n      const r = data[p], g = data[p + 1], b = data[p + 2]\n      const lab = d3.lab('rgb(' + r + ', ' + g + ', ' + b + ')')\n      if (type === 'hue') {\n        var normalized = _.round(normalize(lab.b + lab.a / 2, -50, 200), 2)\n      } else {\n        var normalized = _.round(normalize(lab.l, 0, 100), 2)\n      }\n      const rgb = color(1 - normalized)\n      const hex = toHEX(rgb)\n      heights[d] = normalized * 100\n      landmass.append('path').attr('d', 'M' + i.join('L') + 'Z').attr('data-i', d)\n              .attr('fill', hex).attr('stroke', hex)\n    })\n    let unique = [...new Set(heights)].sort()\n    unique.forEach(function(h) {\n      const rgb = color(1 - h / 100)\n      const hex = toHEX(rgb)\n      $('#colorsAssigned').append('<div class=\"color-div\" id=\"' + hex.substr(\n        1) + '\" data-height=\"' + h + '\" style=\"background-color: ' + hex + ';\"/>')\n    })\n    $('.color-div').click(selectColor)\n  }\n\n  function normalize(val, min, max) {\n    let normalized = (val - min) / (max - min)\n    if (normalized < 0) {normalized = 0}\n    if (normalized > 1) {normalized = 1}\n    return normalized\n  }\n\n  function completeConvertion() {\n    mockHeightmap()\n    restartHistory()\n    $('.color-div').remove()\n    $('#colorsAssigned, #colorsUnassigned').fadeOut()\n    grid.attr('stroke-width', .1)\n    canvas.style.opacity = convertOverlay.value = convertOverlayValue.innerHTML = 0\n    // turn on paint brushes drag and cursor\n    viewbox.style('cursor', 'crosshair').call(drag)\n    $('#imageConverter').dialog('close')\n  }\n\n  // Clear the map\n  function undraw() {\n    viewbox.selectAll('path, circle, line, text, use, #ruler > g').remove()\n    defs.selectAll('*').remove()\n    landmass.select('rect').remove()\n    cells = [], land = [], riversData = [], manors = [], states = [], features = [], queue = []\n  }\n\n  // Enter Heightmap Customization mode\n  function customizeHeightmap() {\n    customization = 1\n    tip('Heightmap customization mode is active. Click on \"Complete\" to finalize the Heightmap',\n      true)\n    $('#getMap').removeClass('buttonoff').addClass('glow')\n    resetZoom()\n    landmassCounter.innerHTML = '0'\n    $('#grid').fadeIn()\n    $('#toggleGrid').removeClass('buttonoff')\n    restartHistory()\n    $('#customizationMenu').slideDown()\n    $('#openEditor').slideUp()\n  }\n\n  // Remove all customization related styles, reset values\n  function exitCustomization() {\n    customization = 0\n    tip('', true)\n    canvas.style.opacity = 0\n    $('#customizationMenu').slideUp()\n    $('#getMap').addClass('buttonoff').removeClass('glow')\n    $('#landmass').empty()\n    $('#grid').empty().fadeOut()\n    $('#toggleGrid').addClass('buttonoff')\n    restoreDefaultEvents()\n    if (!$('#toggleHeight').hasClass('buttonoff')) {toggleHeight()}\n    closeDialogs()\n    history = []\n    historyStage = 0\n    $('#customizeHeightmap').slideUp()\n    $('#openEditor').slideDown()\n    debug.selectAll('.circle, .tag, .line').remove()\n  }\n\n  // open editCountries dialog\n  function editCountries() {\n    if (cults.selectAll('path').size()) $('#toggleCultures').click()\n    if (regions.style('display') === 'none') $('#toggleCountries').click()\n    layoutPreset.value = 'layoutPolitical'\n    $('#countriesBody').empty()\n    $('#countriesHeader').children().removeClass(\n      'icon-sort-name-up icon-sort-name-down icon-sort-number-up icon-sort-number-down')\n    let totalArea = 0, totalBurgs = 0, unit, areaConv\n    if (areaUnit.value === 'square') {unit = ' ' + distanceUnit.value + '²'} else {\n      unit = ' ' + areaUnit.value\n    }\n    let totalPopulation = 0\n    for (let s = 0; s < states.length; s++) {\n      $('#countriesBody').append('<div class=\"states\" id=\"state' + s + '\"></div>')\n      const el = $('#countriesBody div:last-child')\n      const burgsCount = states[s].burgs\n      totalBurgs += burgsCount\n      // calculate user-friendly area and population\n      const area = Math.round(states[s].area * Math.pow(distanceScale.value, 2))\n      totalArea += area\n      areaConv = si(area) + unit\n      const urban = Math.round(states[s].urbanPopulation * urbanization.value * populationRate.value)\n      const rural = _.round(states[s].ruralPopulation * populationRate.value)\n      var population = (urban + rural) * 1000\n      totalPopulation += population\n      const populationConv = si(population)\n      const title = '\\'Total population: ' + populationConv + '; Rural population: ' + rural + 'K; Urban population: ' + urban + 'K\\''\n      let neutral = states[s].color === 'neutral' || states[s].capital === 'neutral'\n      // append elements to countriesBody\n      if (!neutral) {\n        el.append(\n          '<input onmouseover=\"tip(\\'Country color. Click to change\\')\" class=\"stateColor\" type=\"color\" value=\"' + states[s].color + '\"/>')\n        el.append(\n          '<input onmouseover=\"tip(\\'Country name. Click and type to change\\')\" class=\"stateName\" value=\"' + states[s].name + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n        var capital = states[s].capital !== 'select' ? manors[states[s].capital].name : 'select'\n        if (capital === 'select') {\n          el.append(\n            '<button onmouseover=\"tip(\\'Click on map to select a capital or to create a new capital\\')\" class=\"selectCapital\" id=\"selectCapital' + s + '\">★ select</button>')\n        } else {\n          el.append(\n            '<span onmouseover=\"tip(\\'Country capital. Click to enlange\\')\" class=\"icon-star-empty enlange\"></span>')\n          el.append(\n            '<input onmouseover=\"tip(\\'Capital name. Click and type to rename\\')\" class=\"stateCapital\" value=\"' + capital + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n        }\n        el.append(\n          '<span onmouseover=\"tip(\\'Country expansionism (defines competitive size)\\')\" class=\"icon-resize-full hidden\"></span>')\n        el.append(\n          '<input onmouseover=\"tip(\\'Capital expansionism (defines competitive size)\\')\" class=\"statePower hidden\" type=\"number\" min=\"0\" max=\"99\" step=\"0.1\" value=\"' + states[s].power + '\"/>')\n      } else {\n        el.append('<input class=\"stateColor placeholder\" disabled type=\"color\"/>')\n        el.append(\n          '<input onmouseover=\"tip(\\'Neutral burgs are united into this group. Click to change the group name\\')\" class=\"stateName italic\" id=\"stateName' + s + '\" value=\"' + states[s].name + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n        el.append('<span class=\"icon-star-empty placeholder\"></span>')\n        el.append('<input class=\"stateCapital placeholder\"/>')\n        el.append('<span class=\"icon-resize-full hidden placeholder\"></span>')\n        el.append('<input class=\"statePower hidden placeholder\" value=\"0.0\"/>')\n      }\n      el.append('<span onmouseover=\"tip(\\'Cells count\\')\" class=\"icon-check-empty\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Cells count\\')\" class=\"stateCells\">' + states[s].cells + '</div>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Burgs count. Click to see a full list\\')\" style=\"padding-right: 1px\" class=\"stateBIcon icon-dot-circled\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Burgs count. Click to see a full list\\')\" class=\"stateBurgs\">' + burgsCount + '</div>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Country area: ' + (area + unit) + '\\')\" style=\"padding-right: 4px\" class=\"icon-map-o\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Country area: ' + (area + unit) + '\\')\" class=\"stateArea\">' + areaConv + '</div>')\n      el.append('<span onmouseover=\"tip(' + title + ')\" class=\"icon-male\"></span>')\n      el.append(\n        '<input onmouseover=\"tip(' + title + ')\" class=\"statePopulation\" value=\"' + populationConv + '\">')\n      if (!neutral) {\n        el.append(\n          '<span onmouseover=\"tip(\\'Remove country, all assigned cells will become Neutral\\')\" class=\"icon-trash-empty\"></span>')\n        el.attr('data-country', states[s].name).attr('data-capital', capital)\n          .attr('data-expansion', states[s].power).attr('data-cells', states[s].cells)\n          .attr('data-burgs', states[s].burgs).attr('data-area', area)\n          .attr('data-population', population)\n      } else {\n        el.attr('data-country', 'bottom').attr('data-capital', 'bottom')\n          .attr('data-expansion', 'bottom').attr('data-cells', states[s].cells)\n          .attr('data-burgs', states[s].burgs).attr('data-area', area)\n          .attr('data-population', population)\n      }\n    }\n    // initialize jQuery dialog\n    if (!$('#countriesEditor').is(':visible')) {\n      $('#countriesEditor').dialog({\n        title: 'Countries Editor',\n        minHeight: 'auto', minWidth: Math.min(svgWidth, 390),\n        position: {my: 'right top', at: 'right-10 top+10', of: 'svg'}\n      }).on('dialogclose', function() {\n        if (customization === 2 || customization === 3) {\n          $('#countriesManuallyCancel').click()\n        }\n      })\n    }\n    // restore customization Editor version\n    if (customization === 3) {\n      $('div[data-sortby=\\'expansion\\'],.statePower, .icon-resize-full').removeClass('hidden')\n      $('div[data-sortby=\\'cells\\'],.stateCells, .icon-check-empty').addClass('hidden')\n    } else {\n      $('div[data-sortby=\\'expansion\\'],.statePower, .icon-resize-full').addClass('hidden')\n      $('div[data-sortby=\\'cells\\'],.stateCells, .icon-check-empty').removeClass('hidden')\n    }\n    // populate total line on footer\n    countriesFooterCountries.innerHTML = states.length\n    if (states[states.length - 1].capital === 'neutral') {\n      countriesFooterCountries.innerHTML = states.length - 1\n    }\n    countriesFooterBurgs.innerHTML = totalBurgs\n    countriesFooterArea.innerHTML = si(totalArea) + unit\n    countriesFooterPopulation.innerHTML = si(totalPopulation)\n    // handle events\n    $('#countriesBody .states').hover(focusOnState, unfocusState)\n    $('.enlange').click(function() {\n      const s = +(this.parentNode.id).slice(5)\n      const capital = states[s].capital\n      const l = labels.select('[data-id=\\'' + capital + '\\']')\n      const x = +l.attr('x'), y = +l.attr('y')\n      zoomTo(x, y, 8, 1600)\n    })\n    $('.stateName').on('input', function() {\n      const s = +(this.parentNode.id).slice(5)\n      states[s].name = this.value\n      labels.select('#regionLabel' + s).text(this.value)\n      if ($('#burgsEditor').is(':visible')) {\n        if ($('#burgsEditor').attr('data-state') == s) {\n          const color = '<input title=\"Country color. Click to change\" type=\"color\" class=\"stateColor\" value=\"' + states[s].color + '\"/>'\n          $('div[aria-describedby=\\'burgsEditor\\'] .ui-dialog-title').text('Burgs of ' + this.value)\n                                                                   .prepend(color)\n        }\n      }\n    })\n    $('.states > .stateColor').on('change', function() {\n      const s = +(this.parentNode.id).slice(5)\n      states[s].color = this.value\n      regions.selectAll('.region' + s).attr('fill', this.value).attr('stroke', this.value)\n      if ($('#burgsEditor').is(':visible')) {\n        if ($('#burgsEditor').attr('data-state') == s) {\n          $('.ui-dialog-title > .stateColor').val(this.value)\n        }\n      }\n    })\n    $('.stateCapital').on('input', function() {\n      const s = +(this.parentNode.id).slice(5)\n      const capital = states[s].capital\n      manors[capital].name = this.value\n      labels.select('[data-id=\\'' + capital + '\\']').text(this.value)\n      if ($('#burgsEditor').is(':visible')) {\n        if ($('#burgsEditor').attr('data-state') == s) {\n          $('#burgs' + capital + ' > .burgName').val(this.value)\n        }\n      }\n    }).hover(focusCapital, unfocus)\n    $('.stateBurgs, .stateBIcon').on('click', editBurgs).hover(focusBurgs, unfocus)\n\n    $('#countriesBody > .states').on('click', function() {\n      if (customization === 2) {\n        $('.selected').removeClass('selected')\n        $(this).addClass('selected')\n        const state = +$(this).attr('id').slice(5)\n        let color = states[state].color\n        if (color === 'neutral') {color = 'white'}\n        if (debug.selectAll('.circle').size()) debug.selectAll('.circle').attr('stroke', color)\n      }\n    })\n\n    $('.selectCapital').on('click', function() {\n      if ($(this).hasClass('pressed')) {\n        $(this).removeClass('pressed')\n        tooltip.setAttribute('data-main', '')\n        restoreDefaultEvents()\n      } else {\n        $(this).addClass('pressed')\n        viewbox.style('cursor', 'crosshair').on('click', selectCapital)\n        tip('Click on the map to select or create a new capital', true)\n      }\n    })\n\n    function selectCapital() {\n      const point = d3.mouse(this)\n      const index = getIndex(point)\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n\n      if (cells[index].height < 20) {\n        tip('Cannot place capital on the water! Select a land cell')\n        return\n      }\n      const state = +$('.selectCapital.pressed').attr('id').replace('selectCapital', '')\n      let oldState = cells[index].region\n      if (oldState === 'neutral') {oldState = states.length - 1}\n      if (cells[index].manor !== undefined) {\n        // cell has burg\n        const burg = cells[index].manor\n        if (states[oldState].capital === burg) {\n          tip('Existing capital cannot be selected as a new state capital! Select other cell')\n          return\n        } else {\n          // make this burg a new capital\n          const urbanFactor = 0.9 // for old neutrals\n          manors[burg].region = state\n          if (oldState === 'neutral') {manors[burg].population *= (1 / urbanFactor)}\n          manors[burg].population *= 2 // give capital x2 population bonus\n          states[state].capital = burg\n          moveBurgToGroup(burg, 'capitals')\n        }\n      } else {\n        // free cell -> create new burg for a capital\n        const closest = cultureTree.find(x, y)\n        const culture = cultureTree.data().indexOf(closest) || 0\n        const name = generateName(culture)\n        const i = manors.length\n        cells[index].manor = i\n        states[state].capital = i\n        let score = cells[index].score\n        if (score <= 0) {score = _.round(Math.random(), 2)}\n        if (cells[index].crossroad) {score += cells[index].crossroad} // crossroads\n        if (cells[index].confluence) {score += Math.pow(cells[index].confluence, 0.3)} // confluences\n        if (cells[index].port !== undefined) {score *= 3} // port-capital\n        const population = _.round(score, 1)\n        manors.push({i, cell: index, x, y, region: state, culture, name, population})\n        burgIcons.select('#capitals').append('circle').attr('id', 'burg' + i).attr('data-id', i)\n                 .attr('cx', x).attr('cy', y).attr('r', 1).on('click', editBurg)\n        burgLabels.select('#capitals').append('text').attr('data-id', i).attr('x', x).attr('y', y)\n                  .attr('dy', '-0.35em').text(name).on('click', editBurg)\n      }\n      cells[index].region = state\n      cells[index].neighbors.map(function(n) {\n        if (cells[n].height < 20) {return}\n        if (cells[n].manor !== undefined) {return}\n        cells[n].region = state\n      })\n      redrawRegions()\n      recalculateStateData(oldState) // re-calc old state data\n      recalculateStateData(state) // calc new state data\n      editCountries()\n      restoreDefaultEvents()\n    }\n\n    $('.statePower').on('input', function() {\n      const s = +(this.parentNode.id).slice(5)\n      states[s].power = +this.value\n      regenerateCountries()\n    })\n    $('.statePopulation').on('change', function() {\n      let s = +(this.parentNode.id).slice(5)\n      const popOr = +$(this).parent().attr('data-population')\n      const popNew = getInteger(this.value)\n      if (!Number.isInteger(popNew) || popNew < 1000) {\n        this.value = si(popOr)\n        return\n      }\n      const change = popNew / popOr\n      states[s].urbanPopulation = _.round(states[s].urbanPopulation * change, 2)\n      states[s].ruralPopulation = _.round(states[s].ruralPopulation * change, 2)\n      const urban = Math.round(states[s].urbanPopulation * urbanization.value * populationRate.value)\n      const rural = Math.round(states[s].ruralPopulation * populationRate.value)\n      const population = (urban + rural) * 1000\n      $(this).parent().attr('data-population', population)\n      this.value = si(population)\n      let total = 0\n      $('#countriesBody > div').each(function(e, i) {\n        total += +$(this).attr('data-population')\n      })\n      countriesFooterPopulation.innerHTML = si(total)\n      if (states[s].capital === 'neutral') {s = 'neutral'}\n      manors.map(function(m) {\n        if (m.region !== s) {return}\n        m.population = _.round(m.population * change, 2)\n      })\n    })\n    // fully remove country\n    $('#countriesBody .icon-trash-empty').on('click', function() {\n      const s = +(this.parentNode.id).slice(5)\n      alertMessage.innerHTML =\n        `Are you sure you want to remove the country? All lands and burgs will become neutral`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove country', buttons: {\n          Remove: function() {\n            removeCountry(s)\n            $(this).dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    function removeCountry(s) {\n      const cellsCount = states[s].cells\n      const capital = +states[s].capital\n      if (!isNaN(capital)) moveBurgToGroup(capital, 'towns')\n      states.splice(s, 1)\n      states.map(function(s, i) {s.i = i})\n      land.map(function(c) {\n        if (c.region === s) c.region = 'neutral'\n        else if (c.region > s) c.region -= 1\n      })\n      // do only if removed state had cells\n      if (cellsCount) {\n        manors.map(function(b) {if (b.region === s) b.region = 'neutral'})\n        // re-calculate neutral data\n        const i = states.length\n        if (states[i - 1].capital !== 'neutral') {\n          states.push({i, color: 'neutral', name: 'Neutrals', capital: 'neutral'})\n        }\n        recalculateStateData(i - 1) // re-calc data for neutrals\n        redrawRegions()\n      }\n      editCountries()\n    }\n\n    $('#countriesNeutral, #countriesNeutralNumber').on('change', regenerateCountries)\n  }\n\n  // burgs list + editor\n  function editBurgs(context, s) {\n    if (s === undefined) {s = +(this.parentNode.id).slice(5)}\n    $('#burgsEditor').attr('data-state', s)\n    $('#burgsBody').empty()\n    $('#burgsHeader').children().removeClass(\n      'icon-sort-name-up icon-sort-name-down icon-sort-number-up icon-sort-number-down')\n    const region = states[s].capital === 'neutral' ? 'neutral' : s\n    const burgs = $.grep(manors, function(e) {\n      return (e.region === region)\n    })\n    const populationArray = []\n    burgs.map(function(b) {\n      $('#burgsBody').append('<div class=\"states\" id=\"burgs' + b.i + '\"></div>')\n      const el = $('#burgsBody div:last-child')\n      el.append(\n        '<span title=\"Click to enlarge the burg\" style=\"padding-right: 2px\" class=\"enlarge icon-globe\"></span>')\n      el.append(\n        '<input title=\"Burg name. Click and type to change\" class=\"burgName\" value=\"' + b.name + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n      el.append(\n        '<span title=\"Burg culture\" class=\"icon-book\" style=\"padding-right: 2px\"></span>')\n      el.append(\n        '<div title=\"Burg culture\" class=\"burgCulture\">' + cultures[b.culture].name + '</div>')\n      let population = b.population * urbanization.value * populationRate.value * 1000\n      populationArray.push(population)\n      population = population > 1e4 ? si(population) : _.round(population, -1)\n      el.append('<span title=\"Population\" class=\"icon-male\"></span>')\n      el.append(\n        '<input title=\"Population. Input to change\" class=\"burgPopulation\" value=\"' + population + '\"/>')\n      const capital = states[s].capital\n      let type = 'z-burg' // usual burg by default\n      if (b.i === capital) {\n        el.append('<span title=\"Capital\" class=\"icon-star-empty\"></span>')\n        type = 'c-capital'\n      } else {el.append('<span class=\"icon-star-empty placeholder\"></span>')}\n      if (cells[b.cell].port !== undefined) {\n        el.append('<span title=\"Port\" class=\"icon-anchor small\"></span>')\n        if (type === 'c-capital') {type = 'a-capital-port'} else {type = 'p-port'}\n      } else {\n        el.append('<span class=\"icon-anchor placeholder\"></span>')\n      }\n      if (b.i !== capital) {\n        el.append('<span title=\"Remove burg\" class=\"icon-trash-empty\"></span>')\n      }\n      el.attr('data-burg', b.name).attr('data-culture', cultures[b.culture].name)\n        .attr('data-population', b.population).attr('data-type', type)\n    })\n    if (!$('#burgsEditor').is(':visible')) {\n      $('#burgsEditor').dialog({\n        title: 'Burgs of ' + states[s].name,\n        minHeight: 'auto', width: 'auto',\n        position: {my: 'right bottom', at: 'right-10 bottom-10', of: 'svg'}\n      })\n      const color = '<input title=\"Country color. Click to change\" type=\"color\" class=\"stateColor\" value=\"' + states[s].color + '\"/>'\n      if (region !== 'neutral') {\n        $('div[aria-describedby=\\'burgsEditor\\'] .ui-dialog-title').prepend(color)\n      }\n    }\n    // populate total line on footer\n    burgsFooterBurgs.innerHTML = burgs.length\n    burgsFooterCulture.innerHTML = $('#burgsBody div:first-child .burgCulture').text()\n    const avPop = _.round(d3.mean(populationArray), -1)\n    burgsFooterPopulation.value = avPop\n    $('.enlarge').click(function() {\n      const b = +(this.parentNode.id).slice(5)\n      const l = labels.select('[data-id=\\'' + b + '\\']')\n      const x = +l.attr('x'), y = +l.attr('y')\n      zoomTo(x, y, 8, 1600)\n    })\n\n    $('#burgsBody > div').hover(focusBurg, unfocus)\n\n    $('#burgsBody > div').click(function() {\n      if (!$('#changeCapital').hasClass('pressed')) return\n      const s = +$('#burgsEditor').attr('data-state')\n      const newCap = +$(this).attr('id').slice(5)\n      const oldCap = +states[s].capital\n      if (newCap === oldCap) {\n        tip('This burg is already a capital! Please select a different burg', null, 'error')\n        return\n      }\n      $('#changeCapital').removeClass('pressed')\n      states[s].capital = newCap\n      if (!isNaN(oldCap)) moveBurgToGroup(oldCap, 'towns')\n      recalculateStateData(s)\n      moveBurgToGroup(newCap, 'capitals')\n    })\n\n    $('.burgName').on('input', function() {\n      const b = +(this.parentNode.id).slice(5)\n      manors[b].name = this.value\n      labels.select('[data-id=\\'' + b + '\\']').text(this.value)\n      if (b === s && $('#countriesEditor').is(':visible')) {\n        $('#state' + s + ' > .stateCapital').val(this.value)\n      }\n    })\n    $('.ui-dialog-title > .stateColor').on('change', function() {\n      states[s].color = this.value\n      regions.selectAll('.region' + s).attr('fill', this.value).attr('stroke', this.value)\n      if ($('#countriesEditor').is(':visible')) {\n        $('#state' + s + ' > .stateColor').val(this.value)\n      }\n    })\n    $('.burgPopulation').on('change', function() {\n      const b = +(this.parentNode.id).slice(5)\n      const pop = getInteger(this.value)\n      if (!Number.isInteger(pop) || pop < 10) {\n        const orig = _.round(manors[b].population * urbanization.value * populationRate.value * 1000,\n          2)\n        this.value = si(orig)\n        return\n      }\n      populationRaw = _.round(pop / urbanization.value / populationRate.value / 1000, 2)\n      const change = populationRaw - manors[b].population\n      manors[b].population = populationRaw\n      $(this).parent().attr('data-population', populationRaw)\n      this.value = si(pop)\n      let state = manors[b].region\n      if (state === 'neutral') {state = states.length - 1}\n      states[state].urbanPopulation += change\n      updateCountryPopulationUI(state)\n      const average = states[state].urbanPopulation / states[state].burgs * urbanization.value * populationRate.value * 1000\n      burgsFooterPopulation.value = _.round(average, -1)\n    })\n    $('#burgsFooterPopulation').on('change', function() {\n      const state = +$('#burgsEditor').attr('data-state')\n      const newPop = +this.value\n      const avPop = states[state].urbanPopulation / states[state].burgs * urbanization.value * populationRate.value * 1000\n      if (!Number.isInteger(newPop) || newPop < 10) {\n        this.value = _.round(avPop, -1)\n        return\n      }\n      const change = +this.value / avPop\n      $('#burgsBody > div').each(function(e, i) {\n        const b = +(this.id).slice(5)\n        const pop = _.round(manors[b].population * change, 2)\n        manors[b].population = pop\n        $(this).attr('data-population', pop)\n        let popUI = pop * urbanization.value * populationRate.value * 1000\n        popUI = popUI > 1e4 ? si(popUI) : _.round(popUI, -1)\n        $(this).children().filter('.burgPopulation').val(popUI)\n      })\n      states[state].urbanPopulation = _.round(states[state].urbanPopulation * change, 2)\n      updateCountryPopulationUI(state)\n    })\n    $('#burgsBody .icon-trash-empty').on('click', function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the burg?`\n      const b = +(this.parentNode.id).slice(5)\n      $('#alert').dialog({\n        resizable: false, title: 'Remove burg',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            const state = +$('#burgsEditor').attr('data-state')\n            $('#burgs' + b).remove()\n            const cell = manors[b].cell\n            manors[b].region = 'removed'\n            cells[cell].manor = undefined\n            states[state].burgs = states[state].burgs - 1\n            burgsFooterBurgs.innerHTML = states[state].burgs\n            countriesFooterBurgs.innerHTML = +countriesFooterBurgs.innerHTML - 1\n            states[state].urbanPopulation = states[state].urbanPopulation - manors[b].population\n            const avPop = states[state].urbanPopulation / states[state].burgs * urbanization.value * populationRate.value * 1000\n            burgsFooterPopulation.value = _.round(avPop, -1)\n            if ($('#countriesEditor').is(':visible')) {\n              $('#state' + state + ' > .stateBurgs').text(states[state].burgs)\n            }\n            labels.select('[data-id=\\'' + b + '\\']').remove()\n            icons.select('[data-id=\\'' + b + '\\']').remove()\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  // onhover style functions\n  function focusOnState() {\n    const s = +(this.id).slice(5)\n    labels.select('#regionLabel' + s).classed('drag', true)\n    document.getElementsByClassName('region' + s)[0].style.stroke = 'red'\n    document.getElementsByClassName('region' + s)[0].setAttribute('filter', 'url(#blur1)')\n  }\n\n  function unfocusState() {\n    const s = +(this.id).slice(5)\n    labels.select('#regionLabel' + s).classed('drag', false)\n    document.getElementsByClassName('region' + s)[0].style.stroke = 'none'\n    document.getElementsByClassName('region' + s)[0].setAttribute('filter', null)\n  }\n\n  function focusCapital() {\n    const s = +(this.parentNode.id).slice(5)\n    const capital = states[s].capital\n    labels.select('[data-id=\\'' + capital + '\\']').classed('drag', true)\n    icons.select('[data-id=\\'' + capital + '\\']').classed('drag', true)\n  }\n\n  function focusBurgs() {\n    const s = +(this.parentNode.id).slice(5)\n    const stateManors = $.grep(manors, function(e) {\n      return (e.region === s)\n    })\n    stateManors.map(function(m) {\n      labels.select('[data-id=\\'' + m.i + '\\']').classed('drag', true)\n      icons.select('[data-id=\\'' + m.i + '\\']').classed('drag', true)\n    })\n  }\n\n  function focusBurg() {\n    const b = +(this.id).slice(5)\n    const l = labels.select('[data-id=\\'' + b + '\\']')\n    l.classed('drag', true)\n  }\n\n  function unfocus() {$('.drag').removeClass('drag')}\n\n  // save dialog position if \"stable\" dialog window is dragged\n  $('.stable').on('dialogdragstop', function(event, ui) {\n    sessionStorage.setItem(this.id, [ui.offset.left, ui.offset.top])\n  })\n\n  // restore saved dialog position on \"stable\" dialog window open\n  $('.stable').on('dialogopen', function(event, ui) {\n    let pos = sessionStorage.getItem(this.id)\n    if (!pos) {return}\n    pos = pos.split(',')\n    if (pos[0] > $(window).width() - 100 || pos[1] > $(window).width() - 40) {return} // prevent showing out of screen\n    const at = `left+${pos[0]} top+${pos[1]}`\n    $(this).dialog('option', 'position', {my: 'left top', at: at, of: 'svg'})\n  })\n\n  // open editCultures dialog\n  function editCultures() {\n    if (!cults.selectAll('path').size()) $('#toggleCultures').click()\n    if (regions.style('display') !== 'none') $('#toggleCountries').click()\n    layoutPreset.value = 'layoutCultural'\n    $('#culturesBody').empty()\n    $('#culturesHeader').children().removeClass(\n      'icon-sort-name-up icon-sort-name-down icon-sort-number-up icon-sort-number-down')\n\n    // collect data\n    const cellsC = [], areas = [], rurPops = [], urbPops = []\n    const unit = areaUnit.value === 'square' ? ' ' + distanceUnit.value + '²' :\n                 ' ' + areaUnit.value\n    land.map(function(l) {\n      const c = l.culture\n      if (c === undefined) return\n      cellsC[c] = cellsC[c] ? cellsC[c] + 1 : 1\n      areas[c] = areas[c] ? areas[c] + l.area : l.area\n      rurPops[c] = rurPops[c] ? rurPops[c] + l.pop : l.pop\n    })\n\n    manors.map(function(m) {\n      const c = m.culture\n      if (isNaN(c)) return\n      urbPops[c] = urbPops[c] ? urbPops[c] + m.population : m.population\n    })\n\n    if (!nameBases[0]) applyDefaultNamesData()\n    for (let c = 0; c < cultures.length; c++) {\n      $('#culturesBody').append('<div class=\"states cultures\" id=\"culture' + c + '\"></div>')\n      if (cellsC[c] === undefined) {\n        cellsC[c] = 0\n        areas[c] = 0\n        rurPops[c] = 0\n      }\n      if (urbPops[c] === undefined) urbPops[c] = 0\n      const area = Math.round(areas[c] * Math.pow(distanceScale.value, 2))\n      const areaConv = si(area) + unit\n      const urban = Math.round(urbPops[c] * +urbanization.value * populationRate.value)\n      const rural = Math.round(rurPops[c] * populationRate.value)\n      const population = (urban + rural) * 1000\n      const populationConv = si(population)\n      const title = '\\'Total population: ' + populationConv + '; Rural population: ' + rural + 'K; Urban population: ' + urban + 'K\\''\n      let b = cultures[c].base\n      if (b >= nameBases.length) b = 0\n      const base = nameBases[b].name\n      const el = $('#culturesBody div:last-child')\n      el.append(\n        '<input onmouseover=\"tip(\\'Culture color. Click to change\\')\" class=\"stateColor\" type=\"color\" value=\"' + cultures[c].color + '\"/>')\n      el.append(\n        '<input onmouseover=\"tip(\\'Culture name. Click and type to change\\')\" class=\"cultureName\" value=\"' + cultures[c].name + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Culture cells count\\')\" class=\"icon-check-empty\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Culture cells count\\')\" class=\"stateCells\">' + cellsC[c] + '</div>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Culture area: ' + areaConv + '\\')\" style=\"padding-right: 4px\" class=\"icon-map-o\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Culture area: ' + areaConv + '\\')\" class=\"stateArea\">' + areaConv + '</div>')\n      el.append('<span onmouseover=\"tip(' + title + ')\" class=\"icon-male\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(' + title + ')\" class=\"culturePopulation\">' + populationConv + '</div>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Click to re-generate names for burgs with this culture assigned\\')\" class=\"icon-arrows-cw\"></span>')\n      el.append(\n        '<select onmouseover=\"tip(\\'Culture namesbase. Click to change\\')\" class=\"cultureBase\"></select>')\n      if (cultures.length > 1) {\n        el.append(\n          '<span onmouseover=\"tip(\\'Remove culture. Remaining cultures will be recalculated\\')\" class=\"icon-trash-empty\"></span>')\n      }\n      el.attr('data-color', cultures[c].color).attr('data-culture', cultures[c].name)\n        .attr('data-cells', cellsC[c]).attr('data-area', area).attr('data-population', population)\n        .attr('data-base', base)\n    }\n\n    addCultureBaseOptions()\n    drawCultureCenters()\n\n    let activeCultures = cellsC.reduce(function(s, v) {if (v) {return s + 1} else {return s}},\n      0)\n    culturesFooterCultures.innerHTML = activeCultures + '/' + cultures.length\n    culturesFooterCells.innerHTML = land.length\n    let totalArea = areas.reduce(function(s, v) {return s + v})\n    totalArea = Math.round(totalArea * Math.pow(distanceScale.value, 2))\n    culturesFooterArea.innerHTML = si(totalArea) + unit\n    let totalPopulation = rurPops.reduce(function(s, v) {return s + v}) * urbanization.value\n    totalPopulation += urbPops.reduce(function(s, v) {return s + v})\n    culturesFooterPopulation.innerHTML = si(totalPopulation * 1000 * populationRate.value)\n\n    // initialize jQuery dialog\n    if (!$('#culturesEditor').is(':visible')) {\n      $('#culturesEditor').dialog({\n        title: 'Cultures Editor',\n        minHeight: 'auto', minWidth: Math.min(svgWidth, 336),\n        position: {my: 'right top', at: 'right-10 top+10', of: 'svg'},\n        close: function() {\n          debug.select('#cultureCenters').selectAll('*').remove()\n          exitCulturesManualAssignment()\n        }\n      })\n    }\n\n    $('.cultures').hover(function() {\n      const c = +(this.id).slice(7)\n      debug.select('#cultureCenter' + c).attr('stroke', '#000000e6')\n    }, function() {\n      const c = +(this.id).slice(7)\n      debug.select('#cultureCenter' + c).attr('stroke', '#00000080')\n    })\n\n    $('.cultures').on('click', function() {\n      if (customization !== 4) return\n      const c = +(this.id).slice(7)\n      $('.selected').removeClass('selected')\n      $(this).addClass('selected')\n      let color = cultures[c].color\n      debug.selectAll('.circle').attr('stroke', color)\n    })\n\n    $('.cultures .stateColor').on('input', function() {\n      const c = +(this.parentNode.id).slice(7)\n      const old = cultures[c].color\n      cultures[c].color = this.value\n      debug.select('#cultureCenter' + c).attr('fill', this.value)\n      cults.selectAll('[fill=\"' + old + '\"]').attr('fill', this.value).attr('stroke', this.value)\n    })\n\n    $('.cultures .cultureName').on('input', function() {\n      const c = +(this.parentNode.id).slice(7)\n      cultures[c].name = this.value\n    })\n\n    $('.cultures .icon-arrows-cw').on('click', function() {\n      const c = +(this.parentNode.id).slice(7)\n      manors.forEach(function(m) {\n        if (m.region === 'removed') return\n        if (m.culture !== c) return\n        m.name = generateName(c)\n        labels.select('[data-id=\\'' + m.i + '\\']').text(m.name)\n      })\n    })\n\n    $('#culturesBody .icon-trash-empty').on('click', function() {\n      const c = +(this.parentNode.id).slice(7)\n      cultures.splice(c, 1)\n      const centers = cultures.map(function(c) {return c.center})\n      cultureTree = d3.quadtree(centers)\n      recalculateCultures('fullRedraw')\n      editCultures()\n    })\n\n    if (modules.editCultures) return\n    modules.editCultures = true\n\n    function addCultureBaseOptions() {\n      $('.cultureBase').each(function() {\n        const c = +(this.parentNode.id).slice(7)\n        for (let i = 0; i < nameBases.length; i++) {\n          this.options.add(new Option(nameBases[i].name, i))\n        }\n        this.value = cultures[c].base\n        this.addEventListener('change', function() {\n          cultures[c].base = +this.value\n        })\n      })\n    }\n\n    function drawCultureCenters() {\n      let cultureCenters = debug.select('#cultureCenters')\n      if (cultureCenters.size()) {cultureCenters.selectAll('*').remove()} else {\n        cultureCenters = debug.append('g').attr('id', 'cultureCenters')\n      }\n      for (let c = 0; c < cultures.length; c++) {\n        cultureCenters.append('circle').attr('id', 'cultureCenter' + c)\n                      .attr('cx', cultures[c].center[0]).attr('cy', cultures[c].center[1])\n                      .attr('r', 6).attr('stroke-width', 2).attr('stroke', '#00000080')\n                      .attr('fill', cultures[c].color)\n                      .on('mousemove', cultureCenterTip)\n                      .on('mouseleave', function() {tip('', true)})\n                      .call(d3.drag().on('start', cultureCenterDrag))\n      }\n    }\n\n    function cultureCenterTip() {\n      tip('Drag to move culture center and re-calculate cultures', true)\n    }\n\n    function cultureCenterDrag() {\n      const el = d3.select(this)\n      const c = +this.id.slice(13)\n\n      d3.event.on('drag', function() {\n        const x = d3.event.x, y = d3.event.y\n        el.attr('cx', x).attr('cy', y)\n        cultures[c].center = [x, y]\n        const centers = cultures.map(function(c) {return c.center})\n        cultureTree = d3.quadtree(centers)\n        recalculateCultures()\n      })\n    }\n\n    $('#culturesPercentage').on('click', function() {\n      const el = $('#culturesEditor')\n      if (el.attr('data-type') === 'absolute') {\n        el.attr('data-type', 'percentage')\n        const totalCells = land.length\n        let totalArea = culturesFooterArea.innerHTML\n        totalArea = getInteger(totalArea.split(' ')[0])\n        const totalPopulation = getInteger(culturesFooterPopulation.innerHTML)\n        $('#culturesBody > .cultures').each(function() {\n          const cells = Math.round($(this).attr('data-cells') / totalCells * 100)\n          const area = Math.round($(this).attr('data-area') / totalArea * 100)\n          const population = Math.round($(this).attr('data-population') / totalPopulation * 100)\n          $(this).children().filter('.stateCells').text(cells + '%')\n          $(this).children().filter('.stateArea').text(area + '%')\n          $(this).children().filter('.culturePopulation').text(population + '%')\n        })\n      } else {\n        el.attr('data-type', 'absolute')\n        editCultures()\n      }\n    })\n\n    $('#culturesManually').on('click', function() {\n      customization = 4\n      tip('Click to select a culture, drag the circle to re-assign', true)\n      $('#culturesBottom').children().hide()\n      $('#culturesManuallyButtons').show()\n      viewbox.style('cursor', 'crosshair').call(drag).on('click', changeSelectedOnClick)\n      debug.select('#cultureCenters').selectAll('*').remove()\n    })\n\n    $('#culturesManuallyComplete').on('click', function() {\n      const changed = cults.selectAll('[data-culture]')\n      changed.each(function() {\n        const i = +(this.id).slice(4)\n        const c = +this.getAttribute('data-culture')\n        this.removeAttribute('data-culture')\n        cells[i].culture = c\n        const manor = cells[i].manor\n        if (manor !== undefined) manors[manor].culture = c\n      })\n      exitCulturesManualAssignment()\n      if (changed.size()) editCultures()\n    })\n\n    $('#culturesManuallyCancel').on('click', function() {\n      cults.selectAll('[data-culture]').each(function() {\n        const i = +(this.id).slice(4)\n        const c = cells[i].culture\n        this.removeAttribute('data-culture')\n        const color = cultures[c].color\n        this.setAttribute('fill', color)\n        this.setAttribute('stroke', color)\n      })\n      exitCulturesManualAssignment()\n      drawCultureCenters()\n    })\n\n    function exitCulturesManualAssignment() {\n      debug.selectAll('.circle').remove()\n      $('#culturesBottom').children().show()\n      $('#culturesManuallyButtons').hide()\n      $('.selected').removeClass('selected')\n      customization = 0\n      restoreDefaultEvents()\n    }\n\n    $('#culturesRandomize').on('click', function() {\n      const centers = cultures.map(function(c) {\n        const x = Math.floor(Math.random() * graphWidth * 0.8 + graphWidth * 0.1)\n        const y = Math.floor(Math.random() * graphHeight * 0.8 + graphHeight * 0.1)\n        const center = [x, y]\n        c.center = center\n        return center\n      })\n      cultureTree = d3.quadtree(centers)\n      recalculateCultures()\n      drawCultureCenters()\n      editCultures()\n    })\n\n    $('#culturesExport').on('click', function() {\n      const unit = areaUnit.value === 'square' ? distanceUnit.value + '2' : areaUnit.value\n      let data = 'Culture,Cells,Area (' + unit + '),Population,Namesbase\\n' // headers\n      $('#culturesBody > .cultures').each(function() {\n        data += $(this).attr('data-culture') + ','\n        data += $(this).attr('data-cells') + ','\n        data += $(this).attr('data-area') + ','\n        data += $(this).attr('data-population') + ','\n        data += $(this).attr('data-base') + '\\n'\n      })\n\n      const dataBlob = new Blob([data], {type: 'text/plain'})\n      const url = window.URL.createObjectURL(dataBlob)\n      const link = document.createElement('a')\n      document.body.appendChild(link)\n      link.download = 'cultures_data' + Date.now() + '.csv'\n      link.href = url\n      link.click()\n      window.setTimeout(function() {window.URL.revokeObjectURL(url)}, 2000)\n    })\n\n    $('#culturesRegenerateNames').on('click', function() {\n      manors.forEach(function(m) {\n        if (m.region === 'removed') return\n        const culture = m.culture\n        m.name = generateName(culture)\n        labels.select('[data-id=\\'' + m.i + '\\']').text(m.name)\n      })\n    })\n\n    $('#culturesEditNamesBase').on('click', editNamesbase)\n\n    $('#culturesAdd').on('click', function() {\n      const x = Math.floor(Math.random() * graphWidth * 0.8 + graphWidth * 0.1)\n      const y = Math.floor(Math.random() * graphHeight * 0.8 + graphHeight * 0.1)\n      const center = [x, y]\n\n      let culture, base, name, color\n      if (cultures.length < defaultCultures.length) {\n        // add one of the default cultures\n        culture = cultures.length\n        base = defaultCultures[culture].base\n        color = defaultCultures[culture].color\n        name = defaultCultures[culture].name\n      } else {\n        // add random culture besed on one of the current ones\n        culture = _.random(cultures.length - 1)\n        name = generateName(culture)\n        color = colors20(cultures.length % 20)\n        base = cultures[culture].base\n      }\n      cultures.push({name, color, base, center})\n      const centers = cultures.map(function(c) {return c.center})\n      cultureTree = d3.quadtree(centers)\n      recalculateCultures()\n      editCultures()\n    })\n  }\n\n  // open editNamesbase dialog\n  function editNamesbase() {\n    // update list of bases\n    const select = document.getElementById('namesbaseSelect')\n    for (let i = select.options.length; i < nameBases.length; i++) {\n      const option = new Option(nameBases[i].name, i)\n      select.options.add(option)\n    }\n\n    // restore previous state\n    const textarea = document.getElementById('namesbaseTextarea')\n    let selected = +textarea.getAttribute('data-base')\n    if (selected >= nameBases.length) selected = 0\n    select.value = selected\n    if (textarea.value === '') namesbaseUpdateInputs(selected)\n    const examples = document.getElementById('namesbaseExamples')\n    if (examples.innerHTML === '') namesbaseUpdateExamples(selected)\n\n    // open a dialog\n    $('#namesbaseEditor').dialog({\n      title: 'Namesbase Editor',\n      minHeight: 'auto', minWidth: Math.min(svgWidth, 400),\n      position: {my: 'center', at: 'center', of: 'svg'}\n    })\n\n    if (modules.editNamesbase) return\n    modules.editNamesbase = true\n\n    function namesbaseUpdateInputs(selected) {\n      const textarea = document.getElementById('namesbaseTextarea')\n      textarea.value = nameBase[selected].join(', ')\n      textarea.setAttribute('data-base', selected)\n      const name = document.getElementById('namesbaseName')\n      const method = document.getElementById('namesbaseMethod')\n      const min = document.getElementById('namesbaseMin')\n      const max = document.getElementById('namesbaseMax')\n      const dublication = document.getElementById('namesbaseDouble')\n      name.value = nameBases[selected].name\n      method.value = nameBases[selected].method\n      min.value = nameBases[selected].min\n      max.value = nameBases[selected].max\n      dublication.value = nameBases[selected].d\n    }\n\n    function namesbaseUpdateExamples(selected) {\n      const examples = document.getElementById('namesbaseExamples')\n      let text = ''\n      for (let i = 0; i < 10; i++) {\n        const name = generateName(false, selected)\n        if (name === undefined) {\n          text = 'Cannot generate examples. Please verify the data'\n          break\n        }\n        if (i !== 0) text += ', '\n        text += name\n      }\n      examples.innerHTML = text\n    }\n\n    $('#namesbaseSelect').on('change', function() {\n      const selected = +this.value\n      namesbaseUpdateInputs(selected)\n      namesbaseUpdateExamples(selected)\n    })\n\n    $('#namesbaseName').on('input', function() {\n      const base = +textarea.getAttribute('data-base')\n      const select = document.getElementById('namesbaseSelect')\n      select.options[base].innerHTML = this.value\n      nameBases[base].name = this.value\n    })\n\n    $('#namesbaseTextarea').on('input', function() {\n      const base = +this.getAttribute('data-base')\n      const data = textarea.value.replace(/ /g, '').split(',')\n      nameBase[base] = data\n      if (data.length < 3) {\n        chain[base] = []\n        const examples = document.getElementById('namesbaseExamples')\n        examples.innerHTML = 'Please provide a correct source data'\n        return\n      }\n      const method = document.getElementById('namesbaseMethod').value\n      if (method !== 'selection') chain[base] = calculateChain(base)\n    })\n\n    $('#namesbaseMethod').on('change', function() {\n      const base = +textarea.getAttribute('data-base')\n      nameBases[base].method = this.value\n      if (this.value !== 'selection') chain[base] = calculateChain(base)\n    })\n\n    $('#namesbaseMin').on('change', function() {\n      const base = +textarea.getAttribute('data-base')\n      if (+this.value > nameBases[base].max) {\n        tip('Minimal length cannot be greated that maximal')\n      } else {\n        nameBases[base].min = +this.value\n      }\n    })\n\n    $('#namesbaseMax').on('change', function() {\n      const base = +textarea.getAttribute('data-base')\n      if (+this.value < nameBases[base].min) {\n        tip('Maximal length cannot be less than minimal')\n      } else {\n        nameBases[base].max = +this.value\n      }\n    })\n\n    $('#namesbaseDouble').on('change', function() {\n      const base = +textarea.getAttribute('data-base')\n      nameBases[base].d = this.value\n    })\n\n    $('#namesbaseDefault').on('click', function() {\n      alertMessage.innerHTML = `Are you sure you want to restore the default namesbase?\n      All custom bases will be removed and default ones will be assigned to existing cultures.\n      Meanwhile existing names will not be changed.`\n      $('#alert').dialog({\n        resizable: false, title: 'Restore default data',\n        buttons: {\n          Restore: function() {\n            $(this).dialog('close')\n            $('#namesbaseEditor').dialog('close')\n            const select = document.getElementById('namesbaseSelect')\n            select.options.length = 0\n            document.getElementById('namesbaseTextarea').value = ''\n            document.getElementById('namesbaseTextarea').setAttribute('data-base', 0)\n            document.getElementById('namesbaseExamples').innerHTML === ''\n            applyDefaultNamesData()\n            const baseMax = nameBases.length - 1\n            cultures.forEach(function(c) {if (c.base > baseMax) c.base = baseMax})\n            chains = {}\n            calculateChains()\n            editCultures()\n            editNamesbase()\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    $('#namesbaseAdd').on('click', function() {\n      const base = nameBases.length\n      const name = 'Base' + base\n      const method = document.getElementById('namesbaseMethod').value\n      const select = document.getElementById('namesbaseSelect')\n      select.options.add(new Option(name, base))\n      select.value = base\n      nameBases.push({name, method, min: 4, max: 10, d: '', m: 1})\n      nameBase.push([])\n      document.getElementById('namesbaseName').value = name\n      const textarea = document.getElementById('namesbaseTextarea')\n      textarea.value = ''\n      textarea.setAttribute('data-base', base)\n      document.getElementById('namesbaseExamples').innerHTML = ''\n      chain[base] = []\n      editCultures()\n    })\n\n    $('#namesbaseExamples, #namesbaseUpdateExamples').on('click', function() {\n      const select = document.getElementById('namesbaseSelect')\n      namesbaseUpdateExamples(+select.value)\n    })\n\n    $('#namesbaseDownload').on('click', function() {\n      const nameBaseString = JSON.stringify(nameBase) + '\\r\\n'\n      const nameBasesString = JSON.stringify(nameBases)\n      const dataBlob = new Blob([nameBaseString + nameBasesString], {type: 'text/plain'})\n      const url = window.URL.createObjectURL(dataBlob)\n      const link = document.createElement('a')\n      link.download = 'namebase' + Date.now() + '.txt'\n      link.href = url\n      link.click()\n    })\n\n    $('#namesbaseUpload').on('click', function() {namesbaseToLoad.click()})\n    $('#namesbaseToLoad').change(function() {\n      const fileToLoad = this.files[0]\n      this.value = ''\n      const fileReader = new FileReader()\n      fileReader.onload = function(fileLoadedEvent) {\n        const dataLoaded = fileLoadedEvent.target.result\n        const data = dataLoaded.split('\\r\\n')\n        if (data[0] && data[1]) {\n          nameBase = JSON.parse(data[0])\n          nameBases = JSON.parse(data[1])\n          const select = document.getElementById('namesbaseSelect')\n          select.options.length = 0\n          document.getElementById('namesbaseTextarea').value = ''\n          document.getElementById('namesbaseTextarea').setAttribute('data-base', 0)\n          document.getElementById('namesbaseExamples').innerHTML === ''\n          const baseMax = nameBases.length - 1\n          cultures.forEach(function(c) {if (c.base > baseMax) c.base = baseMax})\n          chains = {}\n          calculateChains()\n          editCultures()\n          editNamesbase()\n        } else {\n          tip('Cannot load a namesbase. Please check the data format')\n        }\n      }\n      fileReader.readAsText(fileToLoad, 'UTF-8')\n    })\n  }\n\n  // open editLegends dialog\n  function editLegends(id, name) {\n    // update list of objects\n    const select = document.getElementById('legendSelect')\n    for (let i = select.options.length; i < notes.length; i++) {\n      let option = new Option(notes[i].id, notes[i].id)\n      select.options.add(option)\n    }\n\n    // select an object\n    if (id) {\n      let note = notes.find(note => note.id === id)\n      if (note === undefined) {\n        if (!name) name = id\n        note = {id, name, legend: ''}\n        notes.push(note)\n        let option = new Option(id, id)\n        select.options.add(option)\n      }\n      select.value = id\n      legendName.value = note.name\n      legendText.value = note.legend\n    }\n\n    // open a dialog\n    $('#legendEditor').dialog({\n      title: 'Legends Editor',\n      minHeight: 'auto', minWidth: Math.min(svgWidth, 400),\n      position: {my: 'center', at: 'center', of: 'svg'}\n    })\n\n    if (modules.editLegends) return\n    modules.editLegends = true\n\n    // select another object\n    document.getElementById('legendSelect').addEventListener('change', function() {\n      let note = notes.find(note => note.id === this.value)\n      legendName.value = note.name\n      legendText.value = note.legend\n    })\n\n    // change note name on input\n    document.getElementById('legendName').addEventListener('input', function() {\n      let select = document.getElementById('legendSelect')\n      let id = select.value\n      let note = notes.find(note => note.id === id)\n      note.name = this.value\n    })\n\n    // change note text on input\n    document.getElementById('legendText').addEventListener('input', function() {\n      let select = document.getElementById('legendSelect')\n      let id = select.value\n      let note = notes.find(note => note.id === id)\n      note.legend = this.value\n    })\n\n    // hightlight DOM element\n    document.getElementById('legendFocus').addEventListener('click', function() {\n      let select = document.getElementById('legendSelect')\n      let element = document.getElementById(select.value)\n\n      // if element is not found\n      if (element === null) {\n        const message = 'Related element is not found. Would you like to remove the note (legend item)?'\n        alertMessage.innerHTML = message\n        $('#alert').dialog({\n          resizable: false, title: 'Element not found',\n          buttons: {\n            Remove: function() {\n              $(this).dialog('close')\n              removeLegend()\n            },\n            Keep: function() {$(this).dialog('close')}\n          }\n        })\n        return\n      }\n\n      // if element is found\n      highlightElement(element)\n    })\n\n    function highlightElement(element) {\n      if (debug.select('.highlighted').size()) return // allow only 1 highlight element simultaniosly\n      let box = element.getBBox()\n      let transform = element.getAttribute('transform') || null\n      let t = d3.transition().duration(1000).ease(d3.easeBounceOut)\n      let r = d3.transition().duration(500).ease(d3.easeLinear)\n      let highlight = debug.append('rect').attr('x', box.x).attr('y', box.y)\n                           .attr('width', box.width).attr('height', box.height)\n                           .attr('transform', transform)\n      highlight.classed('highlighted', 1)\n               .transition(t).style('outline-offset', '0px')\n               .transition(r).style('outline-color', 'transparent').remove()\n      let tr = parseTransform(transform)\n      let x = box.x + box.width / 2\n      if (tr[0]) x += tr[0]\n      let y = box.y + box.height / 2\n      if (tr[1]) y += tr[1]\n      if (scale >= 2) zoomTo(x, y, scale, 1600)\n    }\n\n    // download legends object as text file\n    document.getElementById('legendDownload').addEventListener('click', function() {\n      const legendString = JSON.stringify(notes)\n      const dataBlob = new Blob([legendString], {type: 'text/plain'})\n      const url = window.URL.createObjectURL(dataBlob)\n      const link = document.createElement('a')\n      link.download = 'legends' + Date.now() + '.txt'\n      link.href = url\n      link.click()\n    })\n\n    // upload legends object as text file and parse to json\n    document.getElementById('legendUpload').addEventListener('click', function() {\n      document.getElementById('lagendsToLoad').click()\n    })\n    document.getElementById('lagendsToLoad').addEventListener('change', function() {\n      const fileToLoad = this.files[0]\n      this.value = ''\n      const fileReader = new FileReader()\n      fileReader.onload = function(fileLoadedEvent) {\n        const dataLoaded = fileLoadedEvent.target.result\n        if (dataLoaded) {\n          notes = JSON.parse(dataLoaded)\n          const select = document.getElementById('legendSelect')\n          select.options.length = 0\n          editLegends(notes[0].id, notes[0].name)\n        } else {\n          tip('Cannot load a file. Please check the data format')\n        }\n      }\n      fileReader.readAsText(fileToLoad, 'UTF-8')\n    })\n\n    // remove the legend item\n    document.getElementById('legendRemove').addEventListener('click', function() {\n      alertMessage.innerHTML = 'Are you sure you want to remove the selected legend?'\n      $('#alert').dialog({\n        resizable: false, title: 'Remove legend element',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            removeLegend()\n          },\n          Keep: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    function removeLegend() {\n      let select = document.getElementById('legendSelect')\n      let index = notes.findIndex(n => n.id === select.value)\n      notes.splice(index, 1)\n      select.options.length = 0\n      if (notes.length === 0) {\n        $('#legendEditor').dialog('close')\n        return\n      }\n      editLegends(notes[0].id, notes[0].name)\n    }\n\n  }\n\n  // Map scale and measurements editor\n  function editScale() {\n    $('#ruler').fadeIn()\n    $('#scaleEditor').dialog({\n      title: 'Scale Editor',\n      minHeight: 'auto', width: 'auto', resizable: false,\n      position: {my: 'center bottom', at: 'center bottom-10', of: 'svg'}\n    })\n  }\n\n  // update only UI and sorting value in countryEditor screen\n  function updateCountryPopulationUI(s) {\n    if ($('#countriesEditor').is(':visible')) {\n      const urban = Math.round(states[s].urbanPopulation * +urbanization.value * populationRate.value)\n      const rural = Math.round(states[s].ruralPopulation * populationRate.value)\n      const population = (urban + rural) * 1000\n      $('#state' + s).attr('data-population', population)\n      $('#state' + s).children().filter('.statePopulation').val(si(population))\n    }\n  }\n\n  // update dialogs if measurements are changed\n  function updateCountryEditors() {\n    if ($('#countriesEditor').is(':visible')) {editCountries()}\n    if ($('#burgsEditor').is(':visible')) {\n      const s = +$('#burgsEditor').attr('data-state')\n      editBurgs(this, s)\n    }\n  }\n\n  // remove drawn regions and draw all regions again\n  function redrawRegions() {\n    regions.selectAll('*').remove()\n    borders.selectAll('path').remove()\n    removeAllLabelsInGroup('countries')\n    drawRegions()\n  }\n\n  // remove all labels in group including textPaths\n  function removeAllLabelsInGroup(group) {\n    labels.select('#' + group).selectAll('text').each(function() {\n      defs.select('#textPath_' + this.id).remove()\n      this.remove()\n    })\n    if (group !== 'countries') {\n      labels.select('#' + group).remove()\n      updateLabelGroups()\n    }\n  }\n\n  // restore keeped region / burgs / cultures data on edit heightmap completion\n  function restoreRegions() {\n    borders.selectAll('path').remove()\n    removeAllLabelsInGroup('countries')\n    manors.map(function(m) {\n      const cell = diagram.find(m.x, m.y).index\n      if (cells[cell].height < 20) {\n        // remove manor in ocean\n        m.region = 'removed'\n        m.cell = cell\n        d3.selectAll('[data-id=\\'' + m.i + '\\']').remove()\n      } else {\n        m.cell = cell\n        cells[cell].manor = m.i\n      }\n    })\n    cells.map(function(c) {\n      if (c.height < 20) {\n        // no longer a land cell\n        delete c.region\n        delete c.culture\n        return\n      }\n      if (c.region === undefined) {\n        c.region = 'neutral'\n        if (states[states.length - 1].capital !== 'neutral') {\n          states.push({i: states.length, color: 'neutral', capital: 'neutral', name: 'Neutrals'})\n        }\n      }\n      if (c.culture === undefined) {\n        const closest = cultureTree.find(c.data[0], c.data[1])\n        c.culture = cultureTree.data().indexOf(closest)\n      }\n    })\n    states.map(function(s) {recalculateStateData(s.i)})\n    drawRegions()\n  }\n\n  function regenerateCountries() {\n    regions.selectAll('*').remove()\n    const neutral = neutralInput.value = +countriesNeutral.value\n    manors.forEach(function(m) {\n      if (m.region === 'removed') return\n      let state = 'neutral', closest = neutral\n      states.map(function(s) {\n        if (s.capital === 'neutral' || s.capital === 'select') return\n        const c = manors[s.capital]\n        let dist = Math.hypot(c.x - m.x, c.y - m.y) / s.power\n        if (cells[m.cell].fn !== cells[c.cell].fn) dist *= 3\n        if (dist < closest) {\n          state = s.i\n          closest = dist\n        }\n      })\n      m.region = state\n      cells[m.cell].region = state\n    })\n\n    defineRegions()\n    const temp = regions.append('g').attr('id', 'temp')\n    land.forEach(function(l) {\n      if (l.region === undefined) return\n      if (l.region === 'neutral') return\n      const color = states[l.region].color\n      temp.append('path')\n          .attr('data-cell', l.index).attr('data-state', l.region)\n          .attr('d', 'M' + polygons[l.index].join('L') + 'Z')\n          .attr('fill', color).attr('stroke', color)\n    })\n    const neutralCells = $.grep(cells, function(e) {return e.region === 'neutral'})\n    const last = states.length - 1\n    const type = states[last].color\n    if (type === 'neutral' && !neutralCells.length) {\n      // remove neutral line\n      $('#state' + last).remove()\n      states.splice(-1)\n    }\n    // recalculate data for all countries\n    states.map(function(s) {\n      recalculateStateData(s.i)\n      $('#state' + s.i + ' > .stateCells').text(s.cells)\n      $('#state' + s.i + ' > .stateBurgs').text(s.burgs)\n      const area = Math.round(s.area * Math.pow(distanceScale.value, 2))\n      const unit = areaUnit.value === 'square' ? ' ' + distanceUnit.value + '²' :\n                   ' ' + areaUnit.value\n      $('#state' + s.i + ' > .stateArea').text(si(area) + unit)\n      const urban = Math.round(s.urbanPopulation * urbanization.value * populationRate.value)\n      const rural = Math.round(s.ruralPopulation * populationRate.value)\n      const population = (urban + rural) * 1000\n      $('#state' + s.i + ' > .statePopulation').val(si(population))\n      $('#state' + s.i).attr('data-cells', s.cells).attr('data-burgs', s.burgs)\n                       .attr('data-area', area).attr('data-population', population)\n    })\n    if (type !== 'neutral' && neutralCells.length) {\n      // add neutral line\n      states.push({i: states.length, color: 'neutral', capital: 'neutral', name: 'Neutrals'})\n      recalculateStateData(states.length - 1)\n      editCountries()\n    }\n  }\n\n  // enter state edit mode\n  function mockRegions() {\n    if (grid.style('display') !== 'inline') {toggleGrid.click()}\n    if (labels.style('display') !== 'none') {toggleLabels.click()}\n    stateBorders.selectAll('*').remove()\n    neutralBorders.selectAll('*').remove()\n  }\n\n  // handle DOM elements sorting on header click\n  $('.sortable').on('click', function() {\n    const el = $(this)\n    // remove sorting for all siglings except of clicked element\n    el.siblings().removeClass(\n      'icon-sort-name-up icon-sort-name-down icon-sort-number-up icon-sort-number-down')\n    const type = el.hasClass('alphabetically') ? 'name' : 'number'\n    let state = 'no'\n    if (el.is('[class*=\\'down\\']')) {state = 'asc'}\n    if (el.is('[class*=\\'up\\']')) {state = 'desc'}\n    const sortby = el.attr('data-sortby')\n    const list = el.parent().next() // get list container element (e.g. \"countriesBody\")\n    const lines = list.children('div') // get list elements\n    if (state === 'no' || state === 'asc') { // sort desc\n      el.removeClass('icon-sort-' + type + '-down')\n      el.addClass('icon-sort-' + type + '-up')\n      lines.sort(function(a, b) {\n        let an = a.getAttribute('data-' + sortby)\n        if (an === 'bottom') {return 1}\n        let bn = b.getAttribute('data-' + sortby)\n        if (bn === 'bottom') {return -1}\n        if (type === 'number') {\n          an = +an\n          bn = +bn\n        }\n        if (an > bn) {return 1}\n        if (an < bn) {return -1}\n        return 0\n      })\n    }\n    if (state === 'desc') { // sort asc\n      el.removeClass('icon-sort-' + type + '-up')\n      el.addClass('icon-sort-' + type + '-down')\n      lines.sort(function(a, b) {\n        let an = a.getAttribute('data-' + sortby)\n        if (an === 'bottom') {return 1}\n        let bn = b.getAttribute('data-' + sortby)\n        if (bn === 'bottom') {return -1}\n        if (type === 'number') {\n          an = +an\n          bn = +bn\n        }\n        if (an < bn) {return 1}\n        if (an > bn) {return -1}\n        return 0\n      })\n    }\n    lines.detach().appendTo(list)\n  })\n\n  // load text file with new burg names\n  $('#burgsListToLoad').change(function() {\n    const fileToLoad = this.files[0]\n    this.value = ''\n    const fileReader = new FileReader()\n    fileReader.onload = function(fileLoadedEvent) {\n      const dataLoaded = fileLoadedEvent.target.result\n      const data = dataLoaded.split('\\r\\n')\n      if (data.length === 0) {return}\n      let change = []\n      let message = `Burgs will be renamed as below. Please confirm`\n      message +=\n        `<div class=\"overflow-div\"><table class=\"overflow-table\"><tr><th>Id</th><th>Current name</th><th>New Name</th></tr>`\n      for (let i = 0; i < data.length && i < manors.length; i++) {\n        const v = data[i]\n        if (v === '' || v === undefined) {continue}\n        if (v === manors[i].name) {continue}\n        change.push({i, name: v})\n        message +=\n          `<tr><td style=\"width:20%\">${i}</td><td style=\"width:40%\">${manors[i].name}</td><td style=\"width:40%\">${v}</td></tr>`\n      }\n      message += `</tr></table></div>`\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        title: 'Burgs bulk renaming', position: {my: 'center', at: 'center', of: 'svg'},\n        buttons: {\n          Cancel: function() {$(this).dialog('close')},\n          Confirm: function() {\n            for (let i = 0; i < change.length; i++) {\n              const id = change[i].i\n              manors[id].name = change[i].name\n              labels.select('[data-id=\\'' + id + '\\']').text(change[i].name)\n            }\n            $(this).dialog('close')\n            updateCountryEditors()\n          }\n        }\n      })\n    }\n    fileReader.readAsText(fileToLoad, 'UTF-8')\n  })\n\n  // just apply map size that was already set, apply graph size!\n  function applyMapSize() {\n    svgWidth = graphWidth = +mapWidthInput.value\n    svgHeight = graphHeight = +mapHeightInput.value\n    svg.attr('width', svgWidth).attr('height', svgHeight)\n    // set extent to map borders + 100px to get infinity world reception\n    voronoi = d3.voronoi().extent([[-1, -1], [graphWidth + 1, graphHeight + 1]])\n    zoom.translateExtent([[0, 0], [graphWidth, graphHeight]]).scaleExtent([1, 20])\n        .scaleTo(svg, 1)\n    viewbox.attr('transform', null)\n    ocean.selectAll('rect').attr('x', 0).attr('y', 0).attr('width', graphWidth)\n         .attr('height', graphHeight)\n  }\n\n  // change svg size on manual size change or window resize, do not change graph size\n  function changeMapSize() {\n    fitScaleBar()\n    svgWidth = +mapWidthInput.value\n    svgHeight = +mapHeightInput.value\n    svg.attr('width', svgWidth).attr('height', svgHeight)\n    const width = Math.max(svgWidth, graphWidth)\n    const height = Math.max(svgHeight, graphHeight)\n    zoom.translateExtent([[0, 0], [width, height]])\n    svg.select('#ocean').selectAll('rect').attr('x', 0)\n       .attr('y', 0).attr('width', width).attr('height', height)\n  }\n\n  // fit full-screen map if window is resized\n  $(window).resize(function(e) {\n    // trick to prevent resize on download bar opening\n    if (autoResize === false) return\n    mapWidthInput.value = window.innerWidth\n    mapHeightInput.value = window.innerHeight\n    changeMapSize()\n  })\n\n  // fit ScaleBar to map size\n  function fitScaleBar() {\n    const el = d3.select('#scaleBar')\n    if (!el.select('rect').size()) return\n    const bbox = el.select('rect').node().getBBox()\n    let tr = [svgWidth - bbox.width, svgHeight - (bbox.height - 10)]\n    if (sessionStorage.getItem('scaleBar')) {\n      const scalePos = sessionStorage.getItem('scaleBar').split(',')\n      tr = [+scalePos[0] - bbox.width, +scalePos[1] - bbox.height]\n    }\n    el.attr('transform', 'translate(' + Math.round(tr[0]) + ',' + Math.round(tr[1]) + ')')\n  }\n\n  // Other Options handlers\n  $('input, select').on('input change', function() {\n    const id = this.id\n    if (id === 'hideLabels') invokeActiveZooming()\n    if (id === 'mapWidthInput' || id === 'mapHeightInput') {\n      changeMapSize()\n      autoResize = false\n      localStorage.setItem('mapWidth', mapWidthInput.value)\n      localStorage.setItem('mapHeight', mapHeightInput.value)\n    }\n    if (id === 'sizeInput') {\n      graphSize = sizeOutput.value = +this.value\n      if (graphSize === 3) {sizeOutput.style.color = 'red'}\n      if (graphSize === 2) {sizeOutput.style.color = 'yellow'}\n      if (graphSize === 1) {sizeOutput.style.color = 'green'}\n      // localStorage.setItem(\"graphSize\", this.value); - temp off to always start with size 1\n    }\n    if (id === 'templateInput') {localStorage.setItem('template', this.value)}\n    if (id === 'manorsInput') {\n      manorsOutput.value = this.value\n      localStorage.setItem('manors', this.value)\n    }\n    if (id === 'regionsInput') {\n      regionsOutput.value = this.value\n      let size = Math.round(6 - this.value / 20)\n      if (size < 3) {size = 3}\n      burgLabels.select('#capitals').attr('data-size', size)\n      size = Math.round(18 - this.value / 6)\n      if (size < 4) {size = 4}\n      labels.select('#countries').attr('data-size', size)\n      localStorage.setItem('regions', this.value)\n    }\n    if (id === 'powerInput') {\n      powerOutput.value = this.value\n      localStorage.setItem('power', this.value)\n    }\n    if (id === 'neutralInput') {\n      neutralOutput.value = countriesNeutral.value = this.value\n      localStorage.setItem('neutal', this.value)\n    }\n    if (id === 'culturesInput') {\n      culturesOutput.value = this.value\n      localStorage.setItem('cultures', this.value)\n    }\n    if (id === 'precInput') {\n      precOutput.value = +precInput.value\n      localStorage.setItem('prec', this.value)\n    }\n    if (id === 'swampinessInput') {\n      swampinessOutput.value = this.value\n      localStorage.setItem('swampiness', this.value)\n    }\n    if (id === 'outlineLayersInput') localStorage.setItem('outlineLayers', this.value)\n    if (id === 'transparencyInput') changeDialogsTransparency(this.value)\n    if (id === 'pngResolutionInput') localStorage.setItem('pngResolution', this.value)\n    if (id === 'zoomExtentMin' || id === 'zoomExtentMax') {\n      zoom.scaleExtent([+zoomExtentMin.value, +zoomExtentMax.value])\n      zoom.scaleTo(svg, +this.value)\n    }\n\n    if (id === 'convertOverlay') {\n      canvas.style.opacity = convertOverlayValue.innerHTML = +this.value\n    }\n    if (id === 'populationRate') {\n      populationRateOutput.value = si(+populationRate.value * 1000)\n      updateCountryEditors()\n    }\n    if (id === 'urbanization') {\n      urbanizationOutput.value = this.value\n      updateCountryEditors()\n    }\n    if (id === 'distanceUnit' || id === 'distanceScale' || id === 'areaUnit') {\n      const dUnit = distanceUnit.value\n      if (id === 'distanceUnit' && dUnit === 'custom_name') {\n        const custom = prompt('Provide a custom name for distance unit')\n        if (custom) {\n          const opt = document.createElement('option')\n          opt.value = opt.innerHTML = custom\n          distanceUnit.add(opt)\n          distanceUnit.value = custom\n        } else {\n          this.value = 'km'\n          return\n        }\n      }\n      const scale = distanceScale.value\n      scaleOutput.value = scale + ' ' + dUnit\n      ruler.selectAll('g').each(function() {\n        let label\n        const g = d3.select(this)\n        const area = +g.select('text').attr('data-area')\n        if (area) {\n          const areaConv = area * Math.pow(scale, 2) // convert area to distanceScale\n          let unit = areaUnit.value\n          if (unit === 'square') {unit = dUnit + '²'} else {unit = areaUnit.value}\n          label = si(areaConv) + ' ' + unit\n        } else {\n          const dist = +g.select('text').attr('data-dist')\n          label = Math.round(dist * scale) + ' ' + dUnit\n        }\n        g.select('text').text(label)\n      })\n      ruler.selectAll('.gray').attr('stroke-dasharray', _.round(30 / scale, 2))\n      drawScaleBar()\n      updateCountryEditors()\n    }\n    if (id === 'barSize') {\n      barSizeOutput.innerHTML = this.value\n      $('#scaleBar').removeClass('hidden')\n      drawScaleBar()\n    }\n    if (id === 'barLabel') {\n      $('#scaleBar').removeClass('hidden')\n      drawScaleBar()\n    }\n    if (id === 'barBackOpacity' || id === 'barBackColor') {\n      d3.select('#scaleBar > rect')\n        .attr('opacity', +barBackOpacity.value)\n        .attr('fill', barBackColor.value)\n      $('#scaleBar').removeClass('hidden')\n    }\n  })\n\n  $('#scaleOutput').change(function() {\n    if (this.value === '' || isNaN(+this.value) || this.value < 0.01 || this.value > 10) {\n      tip('Manually entered distance scale should be a number in a [0.01; 10] range')\n      this.value = distanceScale.value + ' ' + distanceUnit.value\n      return\n    }\n    distanceScale.value = +this.value\n    scaleOutput.value = this.value + ' ' + distanceUnit.value\n    updateCountryEditors()\n  })\n\n  $('#populationRateOutput').change(function() {\n    if (this.value === '' || isNaN(+this.value) || this.value < 0.001 || this.value > 10) {\n      tip('Manually entered population rate should be a number in a [0.001; 10] range')\n      this.value = si(populationRate.value * 1000)\n      return\n    }\n    populationRate.value = +this.value\n    populationRateOutput.value = si(this.value * 1000)\n    updateCountryEditors()\n  })\n\n  $('#urbanizationOutput').change(function() {\n    if (this.value === '' || isNaN(+this.value) || this.value < 0 || this.value > 10) {\n      tip('Manually entered urbanization rate should be a number in a [0; 10] range')\n      this.value = urbanization.value\n      return\n    }\n    const val = parseFloat(+this.value)\n    if (val > 2) urbanization.setAttribute('max', val)\n    urbanization.value = urbanizationOutput.value = val\n    updateCountryEditors()\n  })\n\n  // lock manually changed option to restrict it randomization\n  $('#optionsContent input, #optionsContent select').change(function() {\n    const icon = 'lock' + this.id.charAt(0).toUpperCase() + this.id.slice(1)\n    const el = document.getElementById(icon)\n    if (!el) return\n    el.setAttribute('data-locked', 1)\n    el.className = 'icon-lock'\n  })\n\n  $('#optionsReset').click(restoreDefaultOptions)\n\n  $('#rescaler').change(function() {\n    const change = _.round((+this.value - 5), 2)\n    modifyHeights('all', change, 1)\n    updateHeightmap()\n    updateHistory()\n    rescaler.value = 5\n  })\n\n  $('#layoutPreset').on('change', function() {\n    const preset = this.value\n    $('#mapLayers li').not('#toggleOcean').addClass('buttonoff')\n    $('#toggleOcean').removeClass('buttonoff')\n    $('#oceanPattern').fadeIn()\n    $('#rivers, #terrain, #borders, #regions, #icons, #labels, #routes, #grid, #markers')\n      .fadeOut()\n    cults.selectAll('path').remove()\n    terrs.selectAll('path').remove()\n    if (preset === 'layoutPolitical') {\n      toggleRivers.click()\n      toggleRelief.click()\n      toggleBorders.click()\n      toggleCountries.click()\n      toggleIcons.click()\n      toggleLabels.click()\n      toggleRoutes.click()\n      toggleMarkers.click()\n    }\n    if (preset === 'layoutCultural') {\n      toggleRivers.click()\n      toggleRelief.click()\n      toggleBorders.click()\n      $('#toggleCultures').click()\n      toggleIcons.click()\n      toggleLabels.click()\n      toggleMarkers.click()\n    }\n    if (preset === 'layoutHeightmap') {\n      $('#toggleHeight').click()\n      toggleRivers.click()\n    }\n  })\n\n  // UI Button handlers\n  $('.tab > button').on('click', function() {\n    $('.tabcontent').hide()\n    $('.tab > button').removeClass('active')\n    $(this).addClass('active')\n    const id = this.id\n    if (id === 'layoutTab') {$('#layoutContent').show()}\n    if (id === 'styleTab') {$('#styleContent').show()}\n    if (id === 'optionsTab') {$('#optionsContent').show()}\n    if (id === 'customizeTab') {$('#customizeContent').show()}\n    if (id === 'aboutTab') {$('#aboutContent').show()}\n  })\n\n  // re-load page with provided seed\n  $('#optionsSeedGenerate').on('click', function() {\n    if ($('#optionsSeed').value == seed) return\n    seed = $('#optionsSeed').value\n    const url = new URL(window.location.href)\n    window.location.href = url.pathname + '?seed=' + seed\n  })\n\n  // Pull request from @evyatron\n  // https://github.com/Azgaar/Fantasy-Map-Generator/pull/49\n  function addDragToUpload() {\n    document.addEventListener('dragover', function(e) {\n      e.stopPropagation()\n      e.preventDefault()\n      $('#map-dragged').show()\n    })\n\n    document.addEventListener('dragleave', function(e) {\n      $('#map-dragged').hide()\n    })\n\n    document.addEventListener('drop', function(e) {\n      e.stopPropagation()\n      e.preventDefault()\n      $('#map-dragged').hide()\n      // no files or more than one\n      if (e.dataTransfer.items == null || e.dataTransfer.items.length != 1) {return}\n      const file = e.dataTransfer.items[0].getAsFile()\n      // not a .map file\n      if (file.name.indexOf('.map') == -1) {\n        alertMessage.innerHTML =\n          'Please upload a <b>.map</b> file you have previously downloaded'\n        $('#alert').dialog({\n          resizable: false, title: 'Invalid file format',\n          width: 400, buttons: {\n            Close: function() { $(this).dialog('close') }\n          }, position: {my: 'center', at: 'center', of: 'svg'}\n        })\n        return\n      }\n      // all good - show uploading text and load the map\n      $('#map-dragged > p').text('Uploading<span>.</span><span>.</span><span>.</span>')\n      uploadFile(file, function onUploadFinish() {\n        $('#map-dragged > p').text('Drop to upload')\n      })\n    })\n  }\n}\n\nfunction tip(tip, main, error) {\n  const tooltip = d3.select('#tooltip')\n  const reg = 'linear-gradient(0.1turn, #ffffff00, #5e5c5c4d, #ffffff00)'\n  const red = 'linear-gradient(0.1turn, #ffffff00, #c71d1d66, #ffffff00)'\n  tooltip.text(tip).style('background', error ? red : reg)\n  if (main) tooltip.attr('data-main', tip)\n}\n\nwindow.tip = tip\n\n",{"version":3,"sources":["FantasyMapGenerator.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"FantasyMapGenerator.vue","sourceRoot":"src/components","sourcesContent":["<template>\n<!-- eslint-disable -->\n<div class=\"app\">\n  <Graphic/>\n  <div id=\"loading\">\n    <div id=\"title_name\">Azgaar's</div>\n    <div id=\"title\">Fantasy Map Generator</div>\n    <div id=\"version\">v. 0.60b</div>\n    <p id=\"loading-text\">LOADING<span>.</span><span>.</span><span>.</span></p>\n  </div>\n  <canvas id=\"canvas\" style=\"opacity: 0\"/>\n  <Options\n    @updateLabelGroups=\"updateLabelGroups\"\n    @applyDefaultStyle=\"applyDefaultStyle\"\n    @toggleHeight=\"toggleHeight\"\n  />\n  <Dialogs/>\n  <div id=\"map-dragged\" style=\"display: none\">\n    <p>Drop to upload</p>\n  </div>\n  <div id=\"legend\">\n    <div id=\"legendHeader\"/>\n    <div id=\"legendBody\"/>\n  </div>\n  <div id=\"tooltip\" data-main=\"Сlick the arrow button to open options\">\n    Сlick the arrow button to open options\n  </div>\n  <div id=\"fileInputs\" class=\"hidden\">\n    <input type=\"file\" accept=\".map\" id=\"mapToLoad\">\n    <input type=\"file\" accept=\".txt,.csv\" id=\"burgsListToLoad\">\n    <input type=\"file\" accept=\".txt\" id=\"lagendsToLoad\">\n    <input type=\"file\" accept=\"image/*\" id=\"imageToLoad\">\n    <input type=\"file\" accept=\".txt\" id=\"templateToLoad\">\n    <input type=\"file\" accept=\".txt\" id=\"namesbaseToLoad\">\n  </div>\n</div>\n</template>\n\n<script>\nimport seedrandom from 'seedrandom'\nimport * as d3 from 'd3'\nimport * as d3chromatic from 'd3-scale-chromatic'\nimport * as polylabel from 'polylabel'\nimport * as quantize from 'quantize'\nimport * as PriorityQueue from 'js-priority-queue'\nimport * as $ from 'jquery'\nimport 'jquery-ui-bundle'\nimport 'jquery-ui-bundle/jquery-ui.css'\nimport * as _ from 'lodash'\nimport {toHEX, round, si, getInteger, GFontToDataURI, ifDefined} from './utils'\nimport Dialogs from './dialogs/Dialogs.vue'\nimport Graphic from './Graphic.vue'\nimport Options from './options/Options.vue'\n\n/* eslint-disable */\n\nexport default {\n  name: 'FantasyMapGenerator',\n  mounted() {\n    fantasyMap()\n  },\n  components: {\n    Dialogs,\n    Graphic,\n    Options,\n  },\n  methods: {\n    updateLabelGroups() { updateLabelGroups() },\n    applyDefaultStyle() { applyDefaultStyle() },\n    toggleHeight() { toggleHeight() },\n  },\n}\n\n'use strict'\n\n// consants\nconst ICONS = [\n  // emoticons in FF:\n  ['2693', '⚓', 'Anchor'],\n  ['26EA', '⛪', 'Church'],\n  ['1F3EF', '🏯', 'Japanese Castle'],\n  ['1F3F0', '🏰', 'Castle'],\n  ['1F5FC', '🗼', 'Tower'],\n  ['1F3E0', '🏠', 'House'],\n  ['1F3AA', '🎪', 'Tent'],\n  ['1F3E8', '🏨', 'Hotel'],\n  ['1F4B0', '💰', 'Money bag'],\n  ['1F4A8', '💨', 'Dashing away'],\n  ['1F334', '🌴', 'Palm'],\n  ['1F335', '🌵', 'Cactus'],\n  ['1F33E', '🌾', 'Sheaf'],\n  ['1F5FB', '🗻', 'Mountain'],\n  ['1F30B', '🌋', 'Volcano'],\n  ['1F40E', '🐎', 'Horse'],\n  ['1F434', '🐴', 'Horse Face'],\n  ['1F42E', '🐮', 'Cow'],\n  ['1F43A', '🐺', 'Wolf Face'],\n  ['1F435', '🐵', 'Monkey face'],\n  ['1F437', '🐷', 'Pig face'],\n  ['1F414', '🐔', 'Chiken'],\n  ['1F411', '🐑', 'Eve'],\n  ['1F42B', '🐫', 'Camel'],\n  ['1F418', '🐘', 'Elephant'],\n  ['1F422', '🐢', 'Turtle'],\n  ['1F40C', '🐌', 'Snail'],\n  ['1F40D', '🐍', 'Snake'],\n  ['1F433', '🐳', 'Whale'],\n  ['1F42C', '🐬', 'Dolphin'],\n  ['1F420', '🐟', 'Fish'],\n  ['1F432', '🐲', 'Dragon Head'],\n  ['1F479', '👹', 'Ogre'],\n  ['1F47B', '👻', 'Ghost'],\n  ['1F47E', '👾', 'Alien'],\n  ['1F480', '💀', 'Skull'],\n  ['1F374', '🍴', 'Fork and knife'],\n  ['1F372', '🍲', 'Food'],\n  ['1F35E', '🍞', 'Bread'],\n  ['1F357', '🍗', 'Poultry leg'],\n  ['1F347', '🍇', 'Grapes'],\n  ['1F34F', '🍏', 'Apple'],\n  ['1F352', '🍒', 'Cherries'],\n  ['1F36F', '🍯', 'Honey pot'],\n  ['1F37A', '🍺', 'Beer'],\n  ['1F377', '🍷', 'Wine glass'],\n  ['1F3BB', '🎻', 'Violin'],\n  ['1F3B8', '🎸', 'Guitar'],\n  ['26A1', '⚡', 'Electricity'],\n  ['1F320', '🌠', 'Shooting star'],\n  ['1F319', '🌙', 'Crescent moon'],\n  ['1F525', '🔥', 'Fire'],\n  ['1F4A7', '💧', 'Droplet'],\n  ['1F30A', '🌊', 'Wave'],\n  ['231B', '⌛', 'Hourglass'],\n  ['1F3C6', '🏆', 'Goblet'],\n  ['26F2', '⛲', 'Fountain'],\n  ['26F5', '⛵', 'Sailboat'],\n  ['26FA', '⛺', 'Tend'],\n  ['1F489', '💉', 'Syringe'],\n  ['1F4D6', '📚', 'Books'],\n  ['1F3AF', '🎯', 'Archery'],\n  ['1F52E', '🔮', 'Magic ball'],\n  ['1F3AD', '🎭', 'Performing arts'],\n  ['1F3A8', '🎨', 'Artist palette'],\n  ['1F457', '👗', 'Dress'],\n  ['1F451', '👑', 'Crown'],\n  ['1F48D', '💍', 'Ring'],\n  ['1F48E', '💎', 'Gem'],\n  ['1F514', '🔔', 'Bell'],\n  ['1F3B2', '🎲', 'Die'],\n  // black and white icons in FF:\n  ['26A0', '⚠', 'Alert'],\n  ['2317', '⌗', 'Hash'],\n  ['2318', '⌘', 'POI'],\n  ['2307', '⌇', 'Wavy'],\n  ['21E6', '⇦', 'Left arrow'],\n  ['21E7', '⇧', 'Top arrow'],\n  ['21E8', '⇨', 'Right arrow'],\n  ['21E9', '⇩', 'Left arrow'],\n  ['21F6', '⇶', 'Three arrows'],\n  ['2699', '⚙', 'Gear'],\n  ['269B', '⚛', 'Atom'],\n  ['0024', '$', 'Dollar'],\n  ['2680', '⚀', 'Die1'],\n  ['2681', '⚁', 'Die2'],\n  ['2682', '⚂', 'Die3'],\n  ['2683', '⚃', 'Die4'],\n  ['2684', '⚄', 'Die5'],\n  ['2685', '⚅', 'Die6'],\n  ['26B4', '⚴', 'Pallas'],\n  ['26B5', '⚵', 'Juno'],\n  ['26B6', '⚶', 'Vesta'],\n  ['26B7', '⚷', 'Chiron'],\n  ['26B8', '⚸', 'Lilith'],\n  ['263F', '☿', 'Mercury'],\n  ['2640', '♀', 'Venus'],\n  ['2641', '♁', 'Earth'],\n  ['2642', '♂', 'Mars'],\n  ['2643', '♃', 'Jupiter'],\n  ['2644', '♄', 'Saturn'],\n  ['2645', '♅', 'Uranus'],\n  ['2646', '♆', 'Neptune'],\n  ['2647', '♇', 'Pluto'],\n  ['26B3', '⚳', 'Ceres'],\n  ['2654', '♔', 'Chess king'],\n  ['2655', '♕', 'Chess queen'],\n  ['2656', '♖', 'Chess rook'],\n  ['2657', '♗', 'Chess bishop'],\n  ['2658', '♘', 'Chess knight'],\n  ['2659', '♙', 'Chess pawn'],\n  ['2660', '♠', 'Spade'],\n  ['2663', '♣', 'Club'],\n  ['2665', '♥', 'Heart'],\n  ['2666', '♦', 'Diamond'],\n  ['2698', '⚘', 'Flower'],\n  ['2625', '☥', 'Ankh'],\n  ['2626', '☦', 'Orthodox'],\n  ['2627', '☧', 'Chi Rho'],\n  ['2628', '☨', 'Lorraine'],\n  ['2629', '☩', 'Jerusalem'],\n  ['2670', '♰', 'Syriac cross'],\n  ['2020', '†', 'Dagger'],\n  ['262A', '☪', 'Muslim'],\n  ['262D', '☭', 'Soviet'],\n  ['262E', '☮', 'Peace'],\n  ['262F', '☯', 'Yin yang'],\n  ['26A4', '⚤', 'Heterosexuality'],\n  ['26A2', '⚢', 'Female homosexuality'],\n  ['26A3', '⚣', 'Male homosexuality'],\n  ['26A5', '⚥', 'Male and female'],\n  ['26AD', '⚭', 'Rings'],\n  ['2690', '⚐', 'White flag'],\n  ['2691', '⚑', 'Black flag'],\n  ['263C', '☼', 'Sun'],\n  ['263E', '☾', 'Moon'],\n  ['2668', '♨', 'Hot springs'],\n  ['2600', '☀', 'Black sun'],\n  ['2601', '☁', 'Cloud'],\n  ['2602', '☂', 'Umbrella'],\n  ['2603', '☃', 'Snowman'],\n  ['2604', '☄', 'Comet'],\n  ['2605', '★', 'Black star'],\n  ['2606', '☆', 'White star'],\n  ['269D', '⚝', 'Outlined star'],\n  ['2618', '☘', 'Shamrock'],\n  ['21AF', '↯', 'Lightning'],\n  ['269C', '⚜', 'FleurDeLis'],\n  ['2622', '☢', 'Radiation'],\n  ['2623', '☣', 'Biohazard'],\n  ['2620', '☠', 'Skull'],\n  ['2638', '☸', 'Dharma'],\n  ['2624', '☤', 'Caduceus'],\n  ['2695', '⚕', 'Aeculapius staff'],\n  ['269A', '⚚', 'Hermes staff'],\n  ['2697', '⚗', 'Alembic'],\n  ['266B', '♫', 'Music'],\n  ['2702', '✂', 'Scissors'],\n  ['2696', '⚖', 'Scales'],\n  ['2692', '⚒', 'Hammer and pick'],\n  ['2694', '⚔', 'Swords']\n]\nconst FONTS = ['Almendra+SC', 'Georgia', 'Times+New+Roman', 'Comic+Sans+MS', 'Lucida+Sans+Unicode', 'Courier+New']\nconst VOWELS = 'aeiouy'\n\n// global variables\nlet svg\nlet defs\nlet viewbox\nlet ocean\nlet oceanLayers\nlet oceanPattern\nlet landmass\nlet terrs\nlet grid\nlet overlay\nlet rivers\nlet terrain\nlet cults\nlet regions\nlet borders\nlet stateBorders\nlet neutralBorders\nlet lakes\nlet routes\nlet roads\nlet trails\nlet searoutes\nlet coastline\nlet labels\nlet burgLabels\nlet icons\nlet burgIcons\nlet markers\nlet ruler\nlet debug\nlet seed\nlet params\nlet voronoi\nlet diagram\nlet polygons\nlet spacing\nlet points = []\nlet heights\nlet modules = []\nlet customization = 0\nlet history = []\nlet historyStage = 0\nlet elSelected\nlet autoResize = true\nlet graphSize\nlet cells = []\nlet land = []\nlet riversData = []\nlet manors = []\nlet states = []\nlet features = []\nlet notes = []\nlet queue = []\nlet defaultCultures = []\nlet cultures = []\nlet chain = []\nlet nameBases = []\nlet nameBase = []\nlet cultureTree\n\n// global methods\n\n// download map as SVG or PNG file\nfunction saveAsImage(type) {\n  console.time('saveAsImage')\n  const webSafe = ['Georgia', 'Times+New+Roman', 'Comic+Sans+MS', 'Lucida+Sans+Unicode', 'Courier+New', 'Verdana', 'Arial', 'Impact']\n  // get non-standard fonts used for labels to fetch them from web\n  const fontsInUse = [] // to store fonts currently in use\n  labels.selectAll('g').each(function(d) {\n    const font = d3.select(this).attr('data-font')\n    if (!font) return\n    if (webSafe.indexOf(font) !== -1) return // do not fetch web-safe fonts\n    if (fontsInUse.indexOf(font) === -1) fontsInUse.push(font)\n  })\n  const fontsToLoad = 'https://fonts.googleapis.com/css?family=' + fontsInUse.join('|')\n\n  // clone svg\n  const cloneEl = document.getElementsByTagName('svg')[0].cloneNode(true)\n  cloneEl.id = 'fantasyMap'\n  document.getElementsByTagName('body')[0].appendChild(cloneEl)\n  const clone = d3.select('#fantasyMap')\n\n  // rteset transform for svg\n  if (type === 'svg') {\n    clone.attr('width', graphWidth).attr('height', graphHeight)\n    clone.select('#viewbox').attr('transform', null)\n    if (svgWidth !== graphWidth || svgHeight !== graphHeight) {\n      // move scale bar to right bottom corner\n      const el = clone.select('#scaleBar')\n      if (!el.size()) return\n      const bbox = el.select('rect').node().getBBox()\n      const tr = [graphWidth - bbox.width, graphHeight - (bbox.height - 10)]\n      el.attr('transform', 'translate(' + Math.round(tr[0]) + ',' + Math.round(tr[1]) + ')')\n    }\n\n    // to fix use elements sizing\n    clone.selectAll('use').each(function() {\n      const size = this.parentNode.getAttribute('size') || 1\n      this.setAttribute('width', size + 'px')\n      this.setAttribute('height', size + 'px')\n    })\n\n    // clean attributes\n    //clone.selectAll(\"*\").each(function() {\n    //  const attributes = this.attributes;\n    //  for (let i = 0; i < attributes.length; i++) {\n    //    const attr = attributes[i];\n    //    if (attr.value === \"\" || attr.name.includes(\"data\")) {\n    //      this.removeAttribute(attr.name);\n    //    }\n    //  }\n    //});\n\n  }\n\n  // for each g element get inline style\n  const emptyG = clone.append('g').node()\n  const defaultStyles = window.getComputedStyle(emptyG)\n\n  // show hidden labels but in reduced size\n  clone.select('#labels').selectAll('.hidden').each(function(e) {\n    const size = d3.select(this).attr('font-size')\n    d3.select(this).classed('hidden', false).attr('font-size', _.round(size * 0.4, 2))\n  })\n\n  // save group css to style attribute\n  clone.selectAll('g, #ruler > g > *, #scaleBar > text').each(function(d) {\n    const compStyle = window.getComputedStyle(this)\n    let style = ''\n    for (let i = 0; i < compStyle.length; i++) {\n      const key = compStyle[i]\n      const value = compStyle.getPropertyValue(key)\n      // Firefox mask hack\n      if (key === 'mask-image' && value !== defaultStyles.getPropertyValue(key)) {\n        style += 'mask-image: url(\\'#shape\\');'\n        continue\n      }\n      if (key === 'cursor') continue // cursor should be default\n      if (this.hasAttribute(key)) continue // don't add style if there is the same attribute\n      if (value === defaultStyles.getPropertyValue(key)) continue\n      style += key + ':' + value + ';'\n    }\n    if (style != '') this.setAttribute('style', style)\n  })\n  emptyG.remove()\n\n  // load fonts as dataURI so they will be available in downloaded svg/png\n  GFontToDataURI(fontsToLoad).then(cssRules => {\n    clone.select('defs').append('style').text(cssRules.join('\\n'))\n    const svg_xml = (new XMLSerializer()).serializeToString(clone.node())\n    clone.remove()\n    const blob = new Blob([svg_xml], {type: 'image/svg+xml;charset=utf-8'})\n    const url = window.URL.createObjectURL(blob)\n    const link = document.createElement('a')\n    link.target = '_blank'\n    if (type === 'png') {\n      const ratio = svgHeight / svgWidth\n      canvas.width = svgWidth * pngResolutionInput.value\n      canvas.height = svgHeight * pngResolutionInput.value\n      const img = new Image()\n      img.src = url\n      img.onload = function() {\n        window.URL.revokeObjectURL(url)\n        ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\n        link.download = 'fantasy_map_' + Date.now() + '.png'\n        canvas.toBlob(function(blob) {\n          link.href = window.URL.createObjectURL(blob)\n          document.body.appendChild(link)\n          link.click()\n          window.setTimeout(function() {window.URL.revokeObjectURL(link.href)}, 5000)\n        })\n        canvas.style.opacity = 0\n        canvas.width = svgWidth\n        canvas.height = svgHeight\n      }\n    } else {\n      link.download = 'fantasy_map_' + Date.now() + '.svg'\n      link.href = url\n      document.body.appendChild(link)\n      link.click()\n    }\n    console.timeEnd('saveAsImage')\n    window.setTimeout(function() {window.URL.revokeObjectURL(url)}, 5000)\n  })\n}\n\n// get user-friendly (real-world) height value from map data\nfunction getFriendlyHeight(h) {\n  let exponent = +heightExponent.value\n  let unit = heightUnit.value\n  let unitRatio = 1 // default calculations are in meters\n  if (unit === 'ft') unitRatio = 3.28 // if foot\n  if (unit === 'f') unitRatio = 0.5468 // if fathom\n  let height = -990\n  if (h >= 20) height = Math.pow(h - 18, exponent)\n  if (h < 20 && h > 0) height = (h - 20) / h * 50\n  return h + ' (' + Math.round(height * unitRatio) + ' ' + unit + ')'\n}\n\n// Get cell info on mouse move (useful for debugging)\nfunction moved() {\n  const point = d3.mouse(this)\n  const i = diagram.find(point[0], point[1]).index\n\n  // update cellInfo\n  if (i) {\n    const p = cells[i] // get cell\n    infoX.innerHTML = Math.round(point[0])\n    infoY.innerHTML = Math.round(point[1])\n    infoCell.innerHTML = i\n    infoArea.innerHTML = ifDefined(p.area, 'n/a', 2)\n    if (customization === 1) {\n      infoHeight.innerHTML = getFriendlyHeight(heights[i])\n    } else {infoHeight.innerHTML = getFriendlyHeight(p.height)}\n    infoFlux.innerHTML = ifDefined(p.flux, 'n/a', 2)\n    let country = p.region === undefined ? 'n/a' : p.region === 'neutral' ? 'neutral' :\n                                                   states[p.region].name + ' (' + p.region + ')'\n    infoCountry.innerHTML = country\n    let culture = ifDefined(p.culture) !== 'no' ?\n                  cultures[p.culture].name + ' (' + p.culture + ')' : 'n/a'\n    infoCulture.innerHTML = culture\n    infoPopulation.innerHTML = ifDefined(p.pop, 'n/a', 2)\n    infoBurg.innerHTML =\n      ifDefined(p.manor) !== 'no' ? manors[p.manor].name + ' (' + p.manor + ')' : 'no'\n    const feature = features[p.fn]\n    if (feature !== undefined) {\n      const fType = feature.land ? 'Island' : feature.border ? 'Ocean' : 'Lake'\n      infoFeature.innerHTML = fType + ' (' + p.fn + ')'\n    } else {\n      infoFeature.innerHTML = 'n/a'\n    }\n  }\n\n  // update tooltip\n  if (toggleTooltips.checked) {\n    tooltip.innerHTML = tooltip.getAttribute('data-main')\n    const tag = event.target.tagName\n    const path = event.composedPath()\n    const group = path[path.length - 7].id\n    const subgroup = path[path.length - 8].id\n    if (group === 'rivers') tip('Click to open River Editor')\n    if (group === 'routes') tip('Click to open Route Editor')\n    if (group === 'terrain') tip('Click to open Relief Icon Editor')\n    if (group === 'labels') tip('Click to open Label Editor')\n    if (group === 'icons') tip('Click to open Icon Editor')\n    if (group === 'markers') tip('Click to open Marker Editor')\n    if (group === 'ruler') {\n      if (tag === 'path' || tag === 'line') tip('Drag to move the measurer')\n      if (tag === 'text') tip('Click to remove the measurer')\n      if (tag === 'circle') tip('Drag to adjust the measurer')\n    }\n    if (subgroup === 'burgIcons') tip('Click to open Burg Editor')\n    if (subgroup === 'burgLabels') tip('Click to open Burg Editor')\n\n    // show legend on hover (if any)\n    let id = event.target.id\n    if (id === '') id = event.target.parentNode.id\n    if (subgroup === 'burgLabels') id = 'burg' + event.target.getAttribute('data-id')\n\n    let note = notes.find(note => note.id === id)\n    let legend = document.getElementById('legend')\n    let legendHeader = document.getElementById('legendHeader')\n    let legendBody = document.getElementById('legendBody')\n    if (note !== undefined && note.legend !== '') {\n      legend.style.display = 'block'\n      legendHeader.innerHTML = note.name\n      legendBody.innerHTML = note.legend\n    } else {\n      legend.style.display = 'none'\n      legendHeader.innerHTML = ''\n      legendBody.innerHTML = ''\n    }\n  }\n\n  // draw line for ranges placing for heightmap Customization\n  if (customization === 1) {\n    const line = debug.selectAll('.line')\n    if (debug.selectAll('.tag').size() === 1) {\n      const x = +debug.select('.tag').attr('cx')\n      const y = +debug.select('.tag').attr('cy')\n      if (line.size()) {\n        line.attr('x1', x).attr('y1', y).attr('x2', point[0]).attr('y2', point[1])\n      } else {\n        debug.insert('line', ':first-child').attr('class', 'line')\n             .attr('x1', x).attr('y1', y).attr('x2', point[0]).attr('y2', point[1])\n      }\n    } else {\n      line.remove()\n    }\n  }\n\n  // change radius circle for Customization\n  if (customization > 0) {\n    const brush = $('#brushesButtons > .pressed')\n    const brushId = brush.attr('id')\n    if (brushId === 'brushRange' || brushId === 'brushTrough') return\n    if (customization !== 5 && !brush.length && !$('div.selected').length) return\n    let radius = 0\n    if (customization === 1) {\n      radius = brushRadius.value\n      if (brushId === 'brushHill' || brushId === 'brushPit') {\n        radius = Math.pow(brushPower.value * 4, .5)\n      }\n    } else if (customization === 2) radius = countriesManuallyBrush.value\n    else if (customization === 4) radius = culturesManuallyBrush.value\n    else if (customization === 5) radius = reliefBulkRemoveRadius.value\n\n    const r = _.round(6 / graphSize * radius, 1)\n    let clr = '#373737'\n    if (customization === 2) {\n      const state = +$('div.selected').attr('id').slice(5)\n      clr = states[state].color === 'neutral' ? 'white' : states[state].color\n    }\n    if (customization === 4) {\n      const culture = +$('div.selected').attr('id').slice(7)\n      clr = cultures[culture].color\n    }\n    moveCircle(point[0], point[1], r, clr)\n  }\n}\n\nfunction updateLabelGroups() {\n  if ($('#styleElementSelect').value !== 'labels') return\n  const cont = d3.select('#styleLabelGroupItems')\n  cont.selectAll('button').remove()\n  labels.selectAll('g').each(function() {\n    const el = d3.select(this)\n    const id = el.attr('id')\n    const name = id.charAt(0).toUpperCase() + id.substr(1)\n    const state = el.classed('hidden')\n    if (id === 'burgLabels') return\n    cont.append('button').attr('id', id).text(name).classed('buttonoff', state)\n        .on('click', function() {\n          // toggle label group on click\n          if ($('#hideLabels').checked) $('#hideLabels').click()\n          const el = d3.select('#' + this.id)\n          const state = !el.classed('hidden')\n          el.classed('hidden', state)\n          d3.select(this).classed('buttonoff', state)\n        })\n  })\n}\n\nfunction applyDefaultStyle() {\n  viewbox.on('touchmove mousemove', moved)\n  landmass.attr('opacity', 1).attr('fill', '#eef6fb')\n  coastline.attr('opacity', .5).attr('stroke', '#1f3846').attr('stroke-width', .7)\n           .attr('filter', 'url(#dropShadow)')\n  regions.attr('opacity', .4)\n  stateBorders.attr('opacity', .8).attr('stroke', '#56566d').attr('stroke-width', .7)\n              .attr('stroke-dasharray', '1.2 1.5').attr('stroke-linecap', 'butt')\n  neutralBorders.attr('opacity', .8).attr('stroke', '#56566d').attr('stroke-width', .5)\n                .attr('stroke-dasharray', '1 1.5').attr('stroke-linecap', 'butt')\n  cults.attr('opacity', .6)\n  rivers.attr('opacity', 1).attr('fill', '#5d97bb')\n  lakes.attr('opacity', .5).attr('fill', '#a6c1fd').attr('stroke', '#5f799d')\n       .attr('stroke-width', .7)\n  icons.selectAll('g').attr('opacity', 1).attr('fill', '#ffffff').attr('stroke', '#3e3e4b')\n  roads.attr('opacity', .9).attr('stroke', '#d06324').attr('stroke-width', .35)\n       .attr('stroke-dasharray', '1.5').attr('stroke-linecap', 'butt')\n  trails.attr('opacity', .9).attr('stroke', '#d06324').attr('stroke-width', .15)\n        .attr('stroke-dasharray', '.8 1.6').attr('stroke-linecap', 'butt')\n  searoutes.attr('opacity', .8).attr('stroke', '#ffffff').attr('stroke-width', .35)\n           .attr('stroke-dasharray', '1 2').attr('stroke-linecap', 'round')\n  grid.attr('opacity', 1).attr('stroke', '#808080').attr('stroke-width', .1)\n  ruler.attr('opacity', 1).style('display', 'none').attr('filter', 'url(#dropShadow)')\n  overlay.attr('opacity', .8).attr('stroke', '#808080').attr('stroke-width', .5)\n  markers.attr('filter', 'url(#dropShadow01)')\n\n  // ocean style\n  svg.style('background-color', '#000000')\n  ocean.attr('opacity', 1)\n  oceanLayers.select('rect').attr('fill', '#53679f')\n  oceanLayers.attr('filter', '')\n  oceanPattern.attr('opacity', 1)\n  oceanLayers.selectAll('path').attr('display', null)\n  styleOceanPattern.checked = true\n  styleOceanLayers.checked = true\n\n  labels.attr('opacity', 1).attr('stroke', '#3a3a3a').attr('stroke-width', 0)\n  let size = Math.round(8 - regionsInput.value / 20)\n  if (size < 3) size = 3\n  burgLabels.select('#capitals').attr('fill', '#3e3e4b').attr('opacity', 1)\n            .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n            .attr('font-size', size).attr('data-size', size)\n  burgLabels.select('#towns').attr('fill', '#3e3e4b').attr('opacity', 1)\n            .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n            .attr('font-size', 3).attr('data-size', 4)\n  burgIcons.select('#capitals').attr('size', 1).attr('stroke-width', .24)\n           .attr('fill', '#ffffff').attr('stroke', '#3e3e4b').attr('fill-opacity', .7)\n           .attr('stroke-opacity', 1).attr('opacity', 1)\n  burgIcons.select('#towns').attr('size', .5).attr('stroke-width', .12).attr('fill', '#ffffff')\n           .attr('stroke', '#3e3e4b').attr('fill-opacity', .7).attr('stroke-opacity', 1)\n           .attr('opacity', 1)\n  size = Math.round(16 - regionsInput.value / 6)\n  if (size < 6) size = 6\n  labels.select('#countries').attr('fill', '#3e3e4b').attr('opacity', 1)\n        .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n        .attr('font-size', size).attr('data-size', size)\n  icons.select('#capital-anchors').attr('fill', '#ffffff').attr('stroke', '#3e3e4b')\n       .attr('stroke-width', 1.2).attr('size', 2)\n  icons.select('#town-anchors').attr('fill', '#ffffff').attr('stroke', '#3e3e4b')\n       .attr('stroke-width', 1.2).attr('size', 1)\n}\n\n// draw the heightmap\nfunction toggleHeight() {\n  const scheme = $('#styleSchemeInput').value\n  let hColor = color\n  if (scheme === 'light') hColor = d3.scaleSequential(d3chromatic.interpolateRdYlGn)\n  if (scheme === 'green') hColor = d3.scaleSequential(d3chromatic.interpolateGreens)\n  if (scheme === 'monochrome') hColor = d3.scaleSequential(d3chromatic.interpolateGreys)\n  if (!terrs.selectAll('path').size()) {\n    cells.map(function(i, d) {\n      let height = i.height\n      if (height < 20 && !i.lake) return\n      if (i.lake) {\n        const nHeights = i.neighbors.map(\n          function(e) {if (cells[e].height >= 20) return cells[e].height})\n        const mean = d3.mean(nHeights)\n        if (!mean) return\n        height = Math.trunc(mean)\n        if (height < 20 || isNaN(height)) height = 20\n      }\n      const clr = hColor((100 - height) / 100)\n      terrs.append('path')\n           .attr('d', 'M' + polygons[d].join('L') + 'Z')\n           .attr('fill', clr).attr('stroke', clr)\n    })\n  } else {\n    terrs.selectAll('path').remove()\n  }\n}\n\nfunction fantasyMap() {\n  const version = '0.60b'\n  document.title += ' v. ' + version\n\n  // Declare variables\n  svg = d3.select('svg')\n  defs = svg.select('#deftemp')\n  viewbox = svg.append('g').attr('id', 'viewbox')\n  ocean = viewbox.append('g').attr('id', 'ocean')\n  oceanLayers = ocean.append('g').attr('id', 'oceanLayers')\n  oceanPattern = ocean.append('g').attr('id', 'oceanPattern')\n  landmass = viewbox.append('g').attr('id', 'landmass')\n  terrs = viewbox.append('g').attr('id', 'terrs')\n  grid = viewbox.append('g').attr('id', 'grid')\n  overlay = viewbox.append('g').attr('id', 'overlay')\n  rivers = viewbox.append('g').attr('id', 'rivers')\n  terrain = viewbox.append('g').attr('id', 'terrain')\n  cults = viewbox.append('g').attr('id', 'cults')\n  regions = viewbox.append('g').attr('id', 'regions')\n  borders = viewbox.append('g').attr('id', 'borders')\n  stateBorders = borders.append('g').attr('id', 'stateBorders')\n  neutralBorders = borders.append('g').attr('id', 'neutralBorders')\n  lakes = viewbox.append('g').attr('id', 'lakes')\n  routes = viewbox.append('g').attr('id', 'routes')\n  roads = routes.append('g').attr('id', 'roads').attr('data-type', 'land')\n  trails = routes.append('g').attr('id', 'trails').attr('data-type', 'land')\n  searoutes = routes.append('g').attr('id', 'searoutes').attr('data-type', 'sea')\n  coastline = viewbox.append('g').attr('id', 'coastline')\n  labels = viewbox.append('g').attr('id', 'labels')\n  burgLabels = labels.append('g').attr('id', 'burgLabels')\n  icons = viewbox.append('g').attr('id', 'icons')\n  burgIcons = icons.append('g').attr('id', 'burgIcons')\n  markers = viewbox.append('g').attr('id', 'markers')\n  ruler = viewbox.append('g').attr('id', 'ruler')\n  debug = viewbox.append('g').attr('id', 'debug')\n\n  labels.append('g').attr('id', 'countries')\n  burgIcons.append('g').attr('id', 'capitals')\n  burgLabels.append('g').attr('id', 'capitals')\n  burgIcons.append('g').attr('id', 'towns')\n  burgLabels.append('g').attr('id', 'towns')\n  icons.append('g').attr('id', 'capital-anchors')\n  icons.append('g').attr('id', 'town-anchors')\n  terrain.append('g').attr('id', 'hills')\n  terrain.append('g').attr('id', 'mounts')\n  terrain.append('g').attr('id', 'swamps')\n  terrain.append('g').attr('id', 'forests')\n\n  // append ocean pattern\n  oceanPattern.append('rect').attr('fill', 'url(#oceanic)').attr('stroke', 'none')\n  oceanLayers.append('rect').attr('id', 'oceanBase')\n\n  // canvas element for raster images\n  const canvas = document.getElementById('canvas')\n  const ctx = canvas.getContext('2d')\n\n  // Color schemes\n  let color = d3.scaleSequential(d3chromatic.interpolateSpectral)\n  const colors8 = d3.scaleOrdinal(d3chromatic.schemeSet2)\n  const colors20 = d3.scaleOrdinal(d3.schemeCategory20)\n\n  // D3 drag and zoom behavior\n  let scale = 1, viewX = 0, viewY = 0\n  const zoom = d3.zoom().scaleExtent([1, 20]).on('zoom', zoomed)\n  svg.call(zoom)\n\n  // D3 Line generator variables\n  const lineGen = d3.line().x(function(d) {\n    return d.scX\n  }).y(function(d) {\n    return d.scY\n  }).curve(d3.curveCatmullRom)\n\n  applyStoredOptions()\n  graphWidth = +mapWidthInput.value // voronoi graph extention, should be stable for each map\n  graphHeight = +mapHeightInput.value\n  svgWidth = graphWidth\n  svgHeight = graphHeight  // svg canvas resolution, can vary for each map\n\n  // toggle off loading screen and on menus\n  $('#loading, #initial').remove()\n  svg.style('background-color', '#000000')\n  if (localStorage.getItem('disable_click_arrow_tooltip')) {\n    tooltip.innerHTML = ''\n    tooltip.setAttribute('data-main', '')\n    $('#optionsTrigger').removeClass('glow')\n  }\n\n  $('#mapLayers').sortable({items: 'li:not(.solid)', cancel: '.solid', update: moveLayer})\n  $('#templateBody').sortable({items: 'div:not(div[data-type=\\'Mountain\\'])'})\n  $('#mapLayers, #templateBody').disableSelection()\n\n  function zoomed() {\n    const scaleDiff = Math.abs(scale - d3.event.transform.k)\n    scale = d3.event.transform.k\n    viewX = d3.event.transform.x\n    viewY = d3.event.transform.y\n    viewbox.attr('transform', d3.event.transform)\n    // rescale only if zoom is significally changed\n    if (scaleDiff > 0.001) {\n      invokeActiveZooming()\n      drawScaleBar()\n    }\n  }\n\n  // Zoom to specific point (x,y - coods, z - scale, d - duration)\n  function zoomTo(x, y, z, d) {\n    const transform = d3.zoomIdentity.translate(x * -z + graphWidth / 2, y * -z + graphHeight / 2)\n                        .scale(z)\n    svg.transition().duration(d).call(zoom.transform, transform)\n  }\n\n  // Reset zoom to initial\n  function resetZoom(duration) {\n    zoom.transform(svg, d3.zoomIdentity)\n  }\n\n  // Active zooming\n  function invokeActiveZooming() {\n    // toggle shade/blur filter on zoom\n    let filter = scale > 2.6 ? 'url(#blurFilter)' : 'url(#dropShadow)'\n    if (scale > 1.5 && scale <= 2.6) filter = null\n    coastline.attr('filter', filter)\n    // rescale lables on zoom (active zooming)\n    labels.selectAll('g').each(function(d) {\n      const el = d3.select(this)\n      if (el.attr('id') === 'burgLabels') return\n      const desired = +el.attr('data-size')\n      let relative = _.round((desired + desired / scale) / 2, 2)\n      if (relative < 2) relative = 2\n      el.attr('font-size', relative)\n      if ($('#hideLabels').checked) {\n        el.classed('hidden', relative * scale < 6)\n        updateLabelGroups()\n      }\n    })\n\n    // rescale map markers\n    markers.selectAll('use').each(function(d) {\n      const el = d3.select(this)\n      let x = +el.attr('data-x'), y = +el.attr('data-y')\n      const desired = +el.attr('data-size')\n      let size = desired * 5 + 25 / scale\n      if (size < 1) size = 1\n      el.attr('x', x - size / 2).attr('y', y - size).attr('width', size).attr('height', size)\n    })\n\n    if (ruler.size()) {\n      if (ruler.style('display') !== 'none') {\n        if (ruler.selectAll('g').size() < 1) {return}\n        const factor = _.round(1 / Math.pow(scale, 0.3), 1)\n        ruler.selectAll('circle:not(.center)').attr('r', 2 * factor)\n             .attr('stroke-width', 0.5 * factor)\n        ruler.selectAll('circle.center').attr('r', 1.2 * factor)\n             .attr('stroke-width', 0.3 * factor)\n        ruler.selectAll('text').attr('font-size', 10 * factor)\n        ruler.selectAll('line, path').attr('stroke-width', factor)\n      }\n    }\n  }\n\n  addDragToUpload()\n\n  // Changelog dialog window\n  const storedVersion = localStorage.getItem('version') // show message on load\n  if (storedVersion != version) {\n    alertMessage.innerHTML = `<b>2018-29-23</b>:\n    The <i>Fantasy Map Generator</i> is updated up to version <b>${version}</b>.\n    Main changes:<br><br>\n    <li>Map Markers</li>\n    <li>Legend Editor (text notes)</li>\n    <li>Bug fixes</li>\n    <br>See a <a href='https://www.reddit.com/r/FantasyMapGenerator/comments/9iarje/update_new_version_is_published_v060b' target='_blank'>dedicated post</a> for the details.\n    <br><br>\n    <i>Join our <a href='https://www.reddit.com/r/FantasyMapGenerator/' target='_blank'>Reddit community</a>\n    to share created maps, discuss the Generator, report bugs, ask questions and propose new features.\n    You may also report bugs <a href='https://github.com/Azgaar/Fantasy-Map-Generator/issues' target='_blank'>here</a>.</i>`\n\n    $('#alert').dialog(\n      {\n        resizable: false, title: 'Fantasy Map Generator update', width: 320,\n        buttons: {\n          'Don\\'t show again': function() {\n            localStorage.setItem('version', version)\n            $(this).dialog('close')\n          },\n          Close: function() {$(this).dialog('close')}\n        },\n        position: {my: 'center', at: 'center', of: 'svg'}\n      })\n  }\n\n  getSeed() // get and set random generator seed\n  applyNamesData() // apply default namesbase on load\n  generate() // generate map on load\n  applyDefaultStyle() // apply style on load\n  focusOn() // based on searchParams focus on point, cell or burg from MFCG\n  invokeActiveZooming() // to hide what need to be hidden\n\n  function generate() {\n    console.group('Random map')\n    console.time('TOTAL')\n    applyMapSize()\n    randomizeOptions()\n    placePoints()\n    calculateVoronoi(points)\n    detectNeighbors()\n    drawScaleBar()\n    defineHeightmap()\n    markFeatures()\n    drawOcean()\n    elevateLakes()\n    resolveDepressionsPrimary()\n    reGraph()\n    resolveDepressionsSecondary()\n    flux()\n    addLakes()\n    drawCoastline()\n    drawRelief()\n    generateCultures()\n    manorsAndRegions()\n    cleanData()\n    console.timeEnd('TOTAL')\n    console.groupEnd('Random map')\n  }\n\n  // get or generate map seed\n  function getSeed() {\n    const url = new URL(window.location.href)\n    params = url.searchParams\n    seed = params.get('seed') || Math.floor(Math.random() * 1e9)\n    console.log(' seed: ' + seed)\n    $('#optionsSeed').value = seed\n    seedrandom(seed)\n  }\n\n  // generate new map seed\n  function changeSeed() {\n    seed = Math.floor(Math.random() * 1e9)\n    console.log(' seed: ' + seed)\n    $('#optionsSeed').value = seed\n    seedrandom(seed)\n  }\n\n  // load options from LocalStorage is any\n  function applyStoredOptions() {\n    if (localStorage.getItem('mapWidth') && localStorage.getItem('mapHeight')) {\n      mapWidthInput.value = localStorage.getItem('mapWidth')\n      mapHeightInput.value = localStorage.getItem('mapHeight')\n    } else {\n      mapWidthInput.value = window.innerWidth\n      mapHeightInput.value = window.innerHeight\n    }\n    if (localStorage.getItem('graphSize')) {\n      graphSize = localStorage.getItem('graphSize')\n      sizeInput.value = sizeOutput.value = graphSize\n    } else {\n      graphSize = +sizeInput.value\n    }\n    if (localStorage.getItem('template')) {\n      templateInput.value = localStorage.getItem('template')\n      lockTemplateInput.setAttribute('data-locked', 1)\n      lockTemplateInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('manors')) {\n      manorsInput.value = manorsOutput.value = localStorage.getItem('manors')\n      lockManorsInput.setAttribute('data-locked', 1)\n      lockManorsInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('regions')) {\n      regionsInput.value = regionsOutput.value = localStorage.getItem('regions')\n      lockRegionsInput.setAttribute('data-locked', 1)\n      lockRegionsInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('power')) {\n      powerInput.value = powerOutput.value = localStorage.getItem('power')\n      lockPowerInput.setAttribute('data-locked', 1)\n      lockPowerInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('neutral')) neutralInput.value =\n      neutralOutput.value = localStorage.getItem('neutral')\n    if (localStorage.getItem('names')) {\n      namesInput.value = localStorage.getItem('names')\n      lockNamesInput.setAttribute('data-locked', 1)\n      lockNamesInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('cultures')) {\n      culturesInput.value = culturesOutput.value = localStorage.getItem('cultures')\n      lockCulturesInput.setAttribute('data-locked', 1)\n      lockCulturesInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('prec')) {\n      precInput.value = precOutput.value = localStorage.getItem('prec')\n      lockPrecInput.setAttribute('data-locked', 1)\n      lockPrecInput.className = 'icon-lock'\n    }\n    if (localStorage.getItem('swampiness')) swampinessInput.value =\n      swampinessOutput.value = localStorage.getItem('swampiness')\n    if (localStorage.getItem('outlineLayers')) outlineLayersInput.value =\n      localStorage.getItem('outlineLayers')\n    if (localStorage.getItem('pngResolution')) {\n      pngResolutionInput.value = localStorage.getItem('pngResolution')\n      pngResolutionOutput.value = pngResolutionInput.value + 'x'\n    }\n    if (localStorage.getItem('transparency')) {\n      transparencyInput.value = transparencyOutput.value = localStorage.getItem('transparency')\n      changeDialogsTransparency(transparencyInput.value)\n    } else {changeDialogsTransparency(0)}\n  }\n\n  function restoreDefaultOptions() {\n    // remove ALL saved data from LocalStorage\n    localStorage.clear()\n    // set defaut values\n    mapWidthInput.value = window.innerWidth\n    mapHeightInput.value = window.innerHeight\n    changeMapSize()\n    graphSize = sizeInput.value = sizeOutput.value = 1\n    $('#options i[class^=\\'icon-lock\\']').each(function() {\n      this.setAttribute('data-locked', 0)\n      this.className = 'icon-lock-open'\n      if (this.id === 'lockNeutralInput' || this.id === 'lockSwampinessInput') {\n        this.setAttribute('data-locked', 1)\n        this.className = 'icon-lock'\n      }\n    })\n    neutralInput.value = neutralOutput.value = 200\n    swampinessInput.value = swampinessOutput.value = 10\n    outlineLayersInput.value = '-6,-3,-1'\n    transparencyInput.value = transparencyOutput.value = 0\n    changeDialogsTransparency(0)\n    pngResolutionInput.value = 5\n    pngResolutionOutput.value = '5x'\n    randomizeOptions()\n  }\n\n  // apply names data from localStorage if available\n  function applyNamesData() {\n    applyDefaultNamesData()\n    defaultCultures = [\n      {name: 'Shwazen', color: '#b3b3b3', base: 0},\n      {name: 'Angshire', color: '#fca463', base: 1},\n      {name: 'Luari', color: '#99acfb', base: 2},\n      {name: 'Tallian', color: '#a6d854', base: 3},\n      {name: 'Toledi', color: '#ffd92f', base: 4},\n      {name: 'Slovian', color: '#e5c494', base: 5},\n      {name: 'Norse', color: '#dca3e4', base: 6},\n      {name: 'Elladian', color: '#66c4a0', base: 7},\n      {name: 'Latian', color: '#ff7174', base: 8},\n      {name: 'Soomi', color: '#85c8fa', base: 9},\n      {name: 'Koryo', color: '#578880', base: 10},\n      {name: 'Hantzu', color: '#becb8d', base: 11},\n      {name: 'Yamoto', color: '#ffd9da', base: 12}\n    ]\n  }\n\n  // apply default names data\n  function applyDefaultNamesData() {\n    nameBases = [                                                                   // min; max; mean; common\n      {name: 'German', method: 'let-to-syl', min: 4, max: 11, d: 'lt', m: 0.1},     // real: 3; 17; 8.6; 8\n      {name: 'English', method: 'let-to-syl', min: 5, max: 10, d: '', m: 0.3},      // real: 4; 13; 7.9; 8\n      {name: 'French', method: 'let-to-syl', min: 4, max: 10, d: 'lns', m: 0.3},    // real: 3; 15; 7.6; 6\n      {name: 'Italian', method: 'let-to-syl', min: 4, max: 11, d: 'clrt', m: 0.2},  // real: 4; 14; 7.7; 7\n      {name: 'Castillian', method: 'let-to-syl', min: 4, max: 10, d: 'lr', m: 0},   // real: 2; 13; 7.5; 8\n      {name: 'Ruthenian', method: 'let-to-syl', min: 4, max: 9, d: '', m: 0},       // real: 3; 12; 7.1; 7\n      {name: 'Nordic', method: 'let-to-syl', min: 5, max: 9, d: 'kln', m: 0.1},     // real: 3; 12; 7.5; 6\n      {name: 'Greek', method: 'let-to-syl', min: 4, max: 10, d: 'ls', m: 0.2},      // real: 3; 14; 7.1; 6\n      {name: 'Roman', method: 'let-to-syl', min: 5, max: 10, d: '', m: 1},          // real: 3; 15; 8.0; 7\n      {name: 'Finnic', method: 'let-to-syl', min: 3, max: 10, d: 'aktu', m: 0},     // real: 3; 13; 7.5; 6\n      {name: 'Korean', method: 'let-to-syl', min: 5, max: 10, d: '', m: 0},         // real: 3; 13; 6.8; 7\n      {name: 'Chinese', method: 'let-to-syl', min: 5, max: 9, d: '', m: 0},         // real: 4; 11; 6.9; 6\n      {name: 'Japanese', method: 'let-to-syl', min: 3, max: 9, d: '', m: 0}         // real: 2; 15; 6.8; 6\n    ]\n    nameBase = [\n      ['Achern', 'Aichhalden', 'Aitern', 'Albbruck', 'Alpirsbach', 'Altensteig', 'Althengstett', 'Appenweier', 'Auggen', 'Wildbad', 'Badenen', 'Badenweiler', 'Baiersbronn', 'Ballrechten', 'Bellingen', 'Berghaupten', 'Bernau', 'Biberach', 'Biederbach', 'Binzen', 'Birkendorf', 'Birkenfeld', 'Bischweier', 'Blumberg', 'Bollen', 'Bollschweil', 'Bonndorf', 'Bosingen', 'Braunlingen', 'Breisach', 'Breisgau', 'Breitnau', 'Brigachtal', 'Buchenbach', 'Buggingen', 'Buhl', 'Buhlertal', 'Calw', 'Dachsberg', 'Dobel', 'Donaueschingen', 'Dornhan', 'Dornstetten', 'Dottingen', 'Dunningen', 'Durbach', 'Durrheim', 'Ebhausen', 'Ebringen', 'Efringen', 'Egenhausen', 'Ehrenkirchen', 'Ehrsberg', 'Eimeldingen', 'Eisenbach', 'Elzach', 'Elztal', 'Emmendingen', 'Endingen', 'Engelsbrand', 'Enz', 'Enzklosterle', 'Eschbronn', 'Ettenheim', 'Ettlingen', 'Feldberg', 'Fischerbach', 'Fischingen', 'Fluorn', 'Forbach', 'Freiamt', 'Freiburg', 'Freudenstadt', 'Friedenweiler', 'Friesenheim', 'Frohnd', 'Furtwangen', 'Gaggenau', 'Geisingen', 'Gengenbach', 'Gernsbach', 'Glatt', 'Glatten', 'Glottertal', 'Gorwihl', 'Gottenheim', 'Grafenhausen', 'Grenzach', 'Griesbach', 'Gutach', 'Gutenbach', 'Hag', 'Haiterbach', 'Hardt', 'Harmersbach', 'Hasel', 'Haslach', 'Hausach', 'Hausen', 'Hausern', 'Heitersheim', 'Herbolzheim', 'Herrenalb', 'Herrischried', 'Hinterzarten', 'Hochenschwand', 'Hofen', 'Hofstetten', 'Hohberg', 'Horb', 'Horben', 'Hornberg', 'Hufingen', 'Ibach', 'Ihringen', 'Inzlingen', 'Kandern', 'Kappel', 'Kappelrodeck', 'Karlsbad', 'Karlsruhe', 'Kehl', 'Keltern', 'Kippenheim', 'Kirchzarten', 'Konigsfeld', 'Krozingen', 'Kuppenheim', 'Kussaberg', 'Lahr', 'Lauchringen', 'Lauf', 'Laufenburg', 'Lautenbach', 'Lauterbach', 'Lenzkirch', 'Liebenzell', 'Loffenau', 'Loffingen', 'Lorrach', 'Lossburg', 'Mahlberg', 'Malsburg', 'Malsch', 'March', 'Marxzell', 'Marzell', 'Maulburg', 'Monchweiler', 'Muhlenbach', 'Mullheim', 'Munstertal', 'Murg', 'Nagold', 'Neubulach', 'Neuenburg', 'Neuhausen', 'Neuried', 'Neuweiler', 'Niedereschach', 'Nordrach', 'Oberharmersbach', 'Oberkirch', 'Oberndorf', 'Oberbach', 'Oberried', 'Oberwolfach', 'Offenburg', 'Ohlsbach', 'Oppenau', 'Ortenberg', 'otigheim', 'Ottenhofen', 'Ottersweier', 'Peterstal', 'Pfaffenweiler', 'Pfalzgrafenweiler', 'Pforzheim', 'Rastatt', 'Renchen', 'Rheinau', 'Rheinfelden', 'Rheinmunster', 'Rickenbach', 'Rippoldsau', 'Rohrdorf', 'Rottweil', 'Rummingen', 'Rust', 'Sackingen', 'Sasbach', 'Sasbachwalden', 'Schallbach', 'Schallstadt', 'Schapbach', 'Schenkenzell', 'Schiltach', 'Schliengen', 'Schluchsee', 'Schomberg', 'Schonach', 'Schonau', 'Schonenberg', 'Schonwald', 'Schopfheim', 'Schopfloch', 'Schramberg', 'Schuttertal', 'Schwenningen', 'Schworstadt', 'Seebach', 'Seelbach', 'Seewald', 'Sexau', 'Simmersfeld', 'Simonswald', 'Sinzheim', 'Solden', 'Staufen', 'Stegen', 'Steinach', 'Steinen', 'Steinmauern', 'Straubenhardt', 'Stuhlingen', 'Sulz', 'Sulzburg', 'Teinach', 'Tiefenbronn', 'Tiengen', 'Titisee', 'Todtmoos', 'Todtnau', 'Todtnauberg', 'Triberg', 'Tunau', 'Tuningen', 'uhlingen', 'Unterkirnach', 'Reichenbach', 'Utzenfeld', 'Villingen', 'Villingendorf', 'Vogtsburg', 'Vohrenbach', 'Waldachtal', 'Waldbronn', 'Waldkirch', 'Waldshut', 'Wehr', 'Weil', 'Weilheim', 'Weisenbach', 'Wembach', 'Wieden', 'Wiesental', 'Wildberg', 'Winzeln', 'Wittlingen', 'Wittnau', 'Wolfach', 'Wutach', 'Wutoschingen', 'Wyhlen', 'Zavelstein'],\n      ['Abingdon', 'Albrighton', 'Alcester', 'Almondbury', 'Altrincham', 'Amersham', 'Andover', 'Appleby', 'Ashboume', 'Atherstone', 'Aveton', 'Axbridge', 'Aylesbury', 'Baldock', 'Bamburgh', 'Barton', 'Basingstoke', 'Berden', 'Bere', 'Berkeley', 'Berwick', 'Betley', 'Bideford', 'Bingley', 'Birmingham', 'Blandford', 'Blechingley', 'Bodmin', 'Bolton', 'Bootham', 'Boroughbridge', 'Boscastle', 'Bossinney', 'Bramber', 'Brampton', 'Brasted', 'Bretford', 'Bridgetown', 'Bridlington', 'Bromyard', 'Bruton', 'Buckingham', 'Bungay', 'Burton', 'Calne', 'Cambridge', 'Canterbury', 'Carlisle', 'Castleton', 'Caus', 'Charmouth', 'Chawleigh', 'Chichester', 'Chillington', 'Chinnor', 'Chipping', 'Chisbury', 'Cleobury', 'Clifford', 'Clifton', 'Clitheroe', 'Cockermouth', 'Coleshill', 'Combe', 'Congleton', 'Crafthole', 'Crediton', 'Cuddenbeck', 'Dalton', 'Darlington', 'Dodbrooke', 'Drax', 'Dudley', 'Dunstable', 'Dunster', 'Dunwich', 'Durham', 'Dymock', 'Exeter', 'Exning', 'Faringdon', 'Felton', 'Fenny', 'Finedon', 'Flookburgh', 'Fowey', 'Frampton', 'Gateshead', 'Gatton', 'Godmanchester', 'Grampound', 'Grantham', 'Guildford', 'Halesowen', 'Halton', 'Harbottle', 'Harlow', 'Hatfield', 'Hatherleigh', 'Haydon', 'Helston', 'Henley', 'Hertford', 'Heytesbury', 'Hinckley', 'Hitchin', 'Holme', 'Hornby', 'Horsham', 'Kendal', 'Kenilworth', 'Kilkhampton', 'Kineton', 'Kington', 'Kinver', 'Kirby', 'Knaresborough', 'Knutsford', 'Launceston', 'Leighton', 'Lewes', 'Linton', 'Louth', 'Luton', 'Lyme', 'Lympstone', 'Macclesfield', 'Madeley', 'Malborough', 'Maldon', 'Manchester', 'Manningtree', 'Marazion', 'Marlborough', 'Marshfield', 'Mere', 'Merryfield', 'Middlewich', 'Midhurst', 'Milborne', 'Mitford', 'Modbury', 'Montacute', 'Mousehole', 'Newbiggin', 'Newborough', 'Newbury', 'Newenden', 'Newent', 'Norham', 'Northleach', 'Noss', 'Oakham', 'Olney', 'Orford', 'Ormskirk', 'Oswestry', 'Padstow', 'Paignton', 'Penkneth', 'Penrith', 'Penzance', 'Pershore', 'Petersfield', 'Pevensey', 'Pickering', 'Pilton', 'Pontefract', 'Portsmouth', 'Preston', 'Quatford', 'Reading', 'Redcliff', 'Retford', 'Rockingham', 'Romney', 'Rothbury', 'Rothwell', 'Salisbury', 'Saltash', 'Seaford', 'Seasalter', 'Sherston', 'Shifnal', 'Shoreham', 'Sidmouth', 'Skipsea', 'Skipton', 'Solihull', 'Somerton', 'Southam', 'Southwark', 'Standon', 'Stansted', 'Stapleton', 'Stottesdon', 'Sudbury', 'Swavesey', 'Tamerton', 'Tarporley', 'Tetbury', 'Thatcham', 'Thaxted', 'Thetford', 'Thornbury', 'Tintagel', 'Tiverton', 'Torksey', 'Totnes', 'Towcester', 'Tregoney', 'Trematon', 'Tutbury', 'Uxbridge', 'Wallingford', 'Wareham', 'Warenmouth', 'Wargrave', 'Warton', 'Watchet', 'Watford', 'Wendover', 'Westbury', 'Westcheap', 'Weymouth', 'Whitford', 'Wickwar', 'Wigan', 'Wigmore', 'Winchelsea', 'Winkleigh', 'Wiscombe', 'Witham', 'Witheridge', 'Wiveliscombe', 'Woodbury', 'Yeovil'],\n      ['Adon', 'Aillant', 'Amilly', 'Andonville', 'Ardon', 'Artenay', 'Ascheres', 'Ascoux', 'Attray', 'Aubin', 'Audeville', 'Aulnay', 'Autruy', 'Auvilliers', 'Auxy', 'Aveyron', 'Baccon', 'Bardon', 'Barville', 'Batilly', 'Baule', 'Bazoches', 'Beauchamps', 'Beaugency', 'Beaulieu', 'Beaune', 'Bellegarde', 'Boesses', 'Boigny', 'Boiscommun', 'Boismorand', 'Boisseaux', 'Bondaroy', 'Bonnee', 'Bonny', 'Bordes', 'Bou', 'Bougy', 'Bouilly', 'Boulay', 'Bouzonville', 'Bouzy', 'Boynes', 'Bray', 'Breteau', 'Briare', 'Briarres', 'Bricy', 'Bromeilles', 'Bucy', 'Cepoy', 'Cercottes', 'Cerdon', 'Cernoy', 'Cesarville', 'Chailly', 'Chaingy', 'Chalette', 'Chambon', 'Champoulet', 'Chanteau', 'Chantecoq', 'Chapell', 'Charme', 'Charmont', 'Charsonville', 'Chateau', 'Chateauneuf', 'Chatel', 'Chatenoy', 'Chatillon', 'Chaussy', 'Checy', 'Chevannes', 'Chevillon', 'Chevilly', 'Chevry', 'Chilleurs', 'Choux', 'Chuelles', 'Clery', 'Coinces', 'Coligny', 'Combleux', 'Combreux', 'Conflans', 'Corbeilles', 'Corquilleroy', 'Cortrat', 'Coudroy', 'Coullons', 'Coulmiers', 'Courcelles', 'Courcy', 'Courtemaux', 'Courtempierre', 'Courtenay', 'Cravant', 'Crottes', 'Dadonville', 'Dammarie', 'Dampierre', 'Darvoy', 'Desmonts', 'Dimancheville', 'Donnery', 'Dordives', 'Dossainville', 'Douchy', 'Dry', 'Echilleuses', 'Egry', 'Engenville', 'Epieds', 'Erceville', 'Ervauville', 'Escrennes', 'Escrignelles', 'Estouy', 'Faverelles', 'Fay', 'Feins', 'Ferolles', 'Ferrieres', 'Fleury', 'Fontenay', 'Foret', 'Foucherolles', 'Freville', 'Gatinais', 'Gaubertin', 'Gemigny', 'Germigny', 'Gidy', 'Gien', 'Girolles', 'Givraines', 'Gondreville', 'Grangermont', 'Greneville', 'Griselles', 'Guigneville', 'Guilly', 'Gyleslonains', 'Huetre', 'Huisseau', 'Ingrannes', 'Ingre', 'Intville', 'Isdes', 'Jargeau', 'Jouy', 'Juranville', 'Bussiere', 'Laas', 'Ladon', 'Lailly', 'Langesse', 'Leouville', 'Ligny', 'Lombreuil', 'Lorcy', 'Lorris', 'Loury', 'Louzouer', 'Malesherbois', 'Marcilly', 'Mardie', 'Mareau', 'Marigny', 'Marsainvilliers', 'Melleroy', 'Menestreau', 'Merinville', 'Messas', 'Meung', 'Mezieres', 'Migneres', 'Mignerette', 'Mirabeau', 'Montargis', 'Montbarrois', 'Montbouy', 'Montcresson', 'Montereau', 'Montigny', 'Montliard', 'Mormant', 'Morville', 'Moulinet', 'Moulon', 'Nancray', 'Nargis', 'Nesploy', 'Neuville', 'Neuvy', 'Nevoy', 'Nibelle', 'Nogent', 'Noyers', 'Ocre', 'Oison', 'Olivet', 'Ondreville', 'Onzerain', 'Orleans', 'Ormes', 'Orville', 'Oussoy', 'Outarville', 'Ouzouer', 'Pannecieres', 'Pannes', 'Patay', 'Paucourt', 'Pers', 'Pierrefitte', 'Pithiverais', 'Pithiviers', 'Poilly', 'Potier', 'Prefontaines', 'Presnoy', 'Pressigny', 'Puiseaux', 'Quiers', 'Ramoulu', 'Rebrechien', 'Rouvray', 'Rozieres', 'Rozoy', 'Ruan', 'Sandillon', 'Santeau', 'Saran', 'Sceaux', 'Seichebrieres', 'Semoy', 'Sennely', 'Sermaises', 'Sigloy', 'Solterre', 'Sougy', 'Sully', 'Sury', 'Tavers', 'Thignonville', 'Thimory', 'Thorailles', 'Thou', 'Tigy', 'Tivernon', 'Tournoisis', 'Trainou', 'Treilles', 'Trigueres', 'Trinay', 'Vannes', 'Varennes', 'Vennecy', 'Vieilles', 'Vienne', 'Viglain', 'Vignes', 'Villamblain', 'Villemandeur', 'Villemoutiers', 'Villemurlin', 'Villeneuve', 'Villereau', 'Villevoques', 'Villorceau', 'Vimory', 'Vitry', 'Vrigny', 'Ivre'],\n      ['Accumoli', 'Acquafondata', 'Acquapendente', 'Acuto', 'Affile', 'Agosta', 'Alatri', 'Albano', 'Allumiere', 'Alvito', 'Amaseno', 'Amatrice', 'Anagni', 'Anguillara', 'Anticoli', 'Antrodoco', 'Anzio', 'Aprilia', 'Aquino', 'Arce', 'Arcinazzo', 'Ardea', 'Ariccia', 'Arlena', 'Arnara', 'Arpino', 'Arsoli', 'Artena', 'Ascrea', 'Atina', 'Ausonia', 'Bagnoregio', 'Barbarano', 'Bassano', 'Bassiano', 'Bellegra', 'Belmonte', 'Blera', 'Bolsena', 'Bomarzo', 'Borbona', 'Borgo', 'Borgorose', 'Boville', 'Bracciano', 'Broccostella', 'Calcata', 'Camerata', 'Campagnano', 'Campodimele', 'Campoli', 'Canale', 'Canepina', 'Canino', 'Cantalice', 'Cantalupo', 'Canterano', 'Capena', 'Capodimonte', 'Capranica', 'Caprarola', 'Carbognano', 'Casalattico', 'Casalvieri', 'Casape', 'Casaprota', 'Casperia', 'Cassino', 'Castelforte', 'Castelliri', 'Castello', 'Castelnuovo', 'Castiglione', 'Castro', 'Castrocielo', 'Cave', 'Ceccano', 'Celleno', 'Cellere', 'Ceprano', 'Cerreto', 'Cervara', 'Cervaro', 'Cerveteri', 'Ciampino', 'Ciciliano', 'Cineto', 'Cisterna', 'Cittaducale', 'Cittareale', 'Civita', 'Civitavecchia', 'Civitella', 'Colfelice', 'Collalto', 'Colle', 'Colleferro', 'Collegiove', 'Collepardo', 'Collevecchio', 'Colli', 'Colonna', 'Concerviano', 'Configni', 'Contigliano', 'Corchiano', 'Coreno', 'Cori', 'Cottanello', 'Esperia', 'Fabrica', 'Faleria', 'Falvaterra', 'Fara', 'Farnese', 'Ferentino', 'Fiamignano', 'Fiano', 'Filacciano', 'Filettino', 'Fiuggi', 'Fiumicino', 'Fondi', 'Fontana', 'Fonte', 'Fontechiari', 'Forano', 'Formello', 'Formia', 'Frascati', 'Frasso', 'Frosinone', 'Fumone', 'Gaeta', 'Gallese', 'Gallicano', 'Gallinaro', 'Gavignano', 'Genazzano', 'Genzano', 'Gerano', 'Giuliano', 'Gorga', 'Gradoli', 'Graffignano', 'Greccio', 'Grottaferrata', 'Grotte', 'Guarcino', 'Guidonia', 'Ischia', 'Isola', 'Itri', 'Jenne', 'Labico', 'Labro', 'Ladispoli', 'Lanuvio', 'Lariano', 'Latera', 'Lenola', 'Leonessa', 'Licenza', 'Longone', 'Lubriano', 'Maenza', 'Magliano', 'Mandela', 'Manziana', 'Marano', 'Marcellina', 'Marcetelli', 'Marino', 'Marta', 'Mazzano', 'Mentana', 'Micigliano', 'Minturno', 'Mompeo', 'Montalto', 'Montasola', 'Monte', 'Montebuono', 'Montefiascone', 'Monteflavio', 'Montelanico', 'Monteleone', 'Montelibretti', 'Montenero', 'Monterosi', 'Monterotondo', 'Montopoli', 'Montorio', 'Moricone', 'Morlupo', 'Morolo', 'Morro', 'Nazzano', 'Nemi', 'Nepi', 'Nerola', 'Nespolo', 'Nettuno', 'Norma', 'Olevano', 'Onano', 'Oriolo', 'Orte', 'Orvinio', 'Paganico', 'Palestrina', 'Paliano', 'Palombara', 'Pastena', 'Patrica', 'Percile', 'Pescorocchiano', 'Pescosolido', 'Petrella', 'Piansano', 'Picinisco', 'Pico', 'Piedimonte', 'Piglio', 'Pignataro', 'Pisoniano', 'Pofi', 'Poggio', 'Poli', 'Pomezia', 'Pontecorvo', 'Pontinia', 'Ponza', 'Ponzano', 'Posta', 'Pozzaglia', 'Priverno', 'Proceno', 'Prossedi', 'Riano', 'Rieti', 'Rignano', 'Riofreddo', 'Ripi', 'Rivodutri', 'Rocca', 'Roccagiovine', 'Roccagorga', 'Roccantica', 'Roccasecca', 'Roiate', 'Ronciglione', 'Roviano', 'Sabaudia', 'Sacrofano', 'Salisano', 'Sambuci', 'Santa', 'Santi', 'Santopadre', 'Saracinesco', 'Scandriglia', 'Segni', 'Selci', 'Sermoneta', 'Serrone', 'Settefrati', 'Sezze', 'Sgurgola', 'Sonnino', 'Sora', 'Soriano', 'Sperlonga', 'Spigno', 'Stimigliano', 'Strangolagalli', 'Subiaco', 'Supino', 'Sutri', 'Tarano', 'Tarquinia', 'Terelle', 'Terracina', 'Tessennano', 'Tivoli', 'Toffia', 'Tolfa', 'Torre', 'Torri', 'Torrice', 'Torricella', 'Torrita', 'Trevi', 'Trevignano', 'Trivigliano', 'Turania', 'Tuscania', 'Vacone', 'Valentano', 'Vallecorsa', 'Vallemaio', 'Vallepietra', 'Vallerano', 'Vallerotonda', 'Vallinfreda', 'Valmontone', 'Varco', 'Vasanello', 'Vejano', 'Velletri', 'Ventotene', 'Veroli', 'Vetralla', 'Vicalvi', 'Vico', 'Vicovaro', 'Vignanello', 'Viterbo', 'Viticuso', 'Vitorchiano', 'Vivaro', 'Zagarolo'],\n      ['Abanades', 'Ablanque', 'Adobes', 'Ajofrin', 'Alameda', 'Alaminos', 'Alarilla', 'Albalate', 'Albares', 'Albarreal', 'Albendiego', 'Alcabon', 'Alcanizo', 'Alcaudete', 'Alcocer', 'Alcolea', 'Alcoroches', 'Aldea', 'Aldeanueva', 'Algar', 'Algora', 'Alhondiga', 'Alique', 'Almadrones', 'Almendral', 'Almoguera', 'Almonacid', 'Almorox', 'Alocen', 'Alovera', 'Alustante', 'Angon', 'Anguita', 'Anover', 'Anquela', 'Arbancon', 'Arbeteta', 'Arcicollar', 'Argecilla', 'Arges', 'Armallones', 'Armuna', 'Arroyo', 'Atanzon', 'Atienza', 'Aunon', 'Azuqueca', 'Azutan', 'Baides', 'Banos', 'Banuelos', 'Barcience', 'Bargas', 'Barriopedro', 'Belvis', 'Berninches', 'Borox', 'Brihuega', 'Budia', 'Buenaventura', 'Bujalaro', 'Burguillos', 'Burujon', 'Bustares', 'Cabanas', 'Cabanillas', 'Calera', 'Caleruela', 'Calzada', 'Camarena', 'Campillo', 'Camunas', 'Canizar', 'Canredondo', 'Cantalojas', 'Cardiel', 'Carmena', 'Carranque', 'Carriches', 'Casa', 'Casarrubios', 'Casas', 'Casasbuenas', 'Caspuenas', 'Castejon', 'Castellar', 'Castilforte', 'Castillo', 'Castilnuevo', 'Cazalegas', 'Cebolla', 'Cedillo', 'Cendejas', 'Centenera', 'Cervera', 'Checa', 'Chequilla', 'Chillaron', 'Chiloeches', 'Chozas', 'Chueca', 'Cifuentes', 'Cincovillas', 'Ciruelas', 'Ciruelos', 'Cobeja', 'Cobeta', 'Cobisa', 'Cogollor', 'Cogolludo', 'Condemios', 'Congostrina', 'Consuegra', 'Copernal', 'Corduente', 'Corral', 'Cuerva', 'Domingo', 'Dosbarrios', 'Driebes', 'Duron', 'El', 'Embid', 'Erustes', 'Escalona', 'Escalonilla', 'Escamilla', 'Escariche', 'Escopete', 'Espinosa', 'Espinoso', 'Esplegares', 'Esquivias', 'Estables', 'Estriegana', 'Fontanar', 'Fuembellida', 'Fuensalida', 'Fuentelsaz', 'Gajanejos', 'Galve', 'Galvez', 'Garciotum', 'Gascuena', 'Gerindote', 'Guadamur', 'Henche', 'Heras', 'Herreria', 'Herreruela', 'Hijes', 'Hinojosa', 'Hita', 'Hombrados', 'Hontanar', 'Hontoba', 'Horche', 'Hormigos', 'Huecas', 'Huermeces', 'Huerta', 'Hueva', 'Humanes', 'Illan', 'Illana', 'Illescas', 'Iniestola', 'Irueste', 'Jadraque', 'Jirueque', 'Lagartera', 'Las', 'Layos', 'Ledanca', 'Lillo', 'Lominchar', 'Loranca', 'Los', 'Lucillos', 'Lupiana', 'Luzaga', 'Luzon', 'Madridejos', 'Magan', 'Majaelrayo', 'Malaga', 'Malaguilla', 'Malpica', 'Mandayona', 'Mantiel', 'Manzaneque', 'Maqueda', 'Maranchon', 'Marchamalo', 'Marjaliza', 'Marrupe', 'Mascaraque', 'Masegoso', 'Matarrubia', 'Matillas', 'Mazarete', 'Mazuecos', 'Medranda', 'Megina', 'Mejorada', 'Mentrida', 'Mesegar', 'Miedes', 'Miguel', 'Millana', 'Milmarcos', 'Mirabueno', 'Miralrio', 'Mocejon', 'Mochales', 'Mohedas', 'Molina', 'Monasterio', 'Mondejar', 'Montarron', 'Mora', 'Moratilla', 'Morenilla', 'Muduex', 'Nambroca', 'Navalcan', 'Negredo', 'Noblejas', 'Noez', 'Nombela', 'Noves', 'Numancia', 'Nuno', 'Ocana', 'Ocentejo', 'Olias', 'Olmeda', 'Ontigola', 'Orea', 'Orgaz', 'Oropesa', 'Otero', 'Palmaces', 'Palomeque', 'Pantoja', 'Pardos', 'Paredes', 'Pareja', 'Parrillas', 'Pastrana', 'Pelahustan', 'Penalen', 'Penalver', 'Pepino', 'Peralejos', 'Peralveche', 'Pinilla', 'Pioz', 'Piqueras', 'Polan', 'Portillo', 'Poveda', 'Pozo', 'Pradena', 'Prados', 'Puebla', 'Puerto', 'Pulgar', 'Quer', 'Quero', 'Quintanar', 'Quismondo', 'Rebollosa', 'Recas', 'Renera', 'Retamoso', 'Retiendas', 'Riba', 'Rielves', 'Rillo', 'Riofrio', 'Robledillo', 'Robledo', 'Romanillos', 'Romanones', 'Rueda', 'Sacecorbo', 'Sacedon', 'Saelices', 'Salmeron', 'San', 'Santa', 'Santiuste', 'Santo', 'Sartajada', 'Sauca', 'Sayaton', 'Segurilla', 'Selas', 'Semillas', 'Sesena', 'Setiles', 'Sevilleja', 'Sienes', 'Siguenza', 'Solanillos', 'Somolinos', 'Sonseca', 'Sotillo', 'Sotodosos', 'Talavera', 'Tamajon', 'Taragudo', 'Taravilla', 'Tartanedo', 'Tembleque', 'Tendilla', 'Terzaga', 'Tierzo', 'Tordellego', 'Tordelrabano', 'Tordesilos', 'Torija', 'Torralba', 'Torre', 'Torrecilla', 'Torrecuadrada', 'Torrejon', 'Torremocha', 'Torrico', 'Torrijos', 'Torrubia', 'Tortola', 'Tortuera', 'Tortuero', 'Totanes', 'Traid', 'Trijueque', 'Trillo', 'Turleque', 'Uceda', 'Ugena', 'Ujados', 'Urda', 'Utande', 'Valdarachas', 'Valdesotos', 'Valhermoso', 'Valtablado', 'Valverde', 'Velada', 'Viana', 'Vinuelas', 'Yebes', 'Yebra', 'Yelamos', 'Yeles', 'Yepes', 'Yuncler', 'Yunclillos', 'Yuncos', 'Yunquera', 'Zaorejas', 'Zarzuela', 'Zorita'],\n      ['Belgorod', 'Beloberezhye', 'Belyi', 'Belz', 'Berestiy', 'Berezhets', 'Berezovets', 'Berezutsk', 'Bobruisk', 'Bolonets', 'Borisov', 'Borovsk', 'Bozhesk', 'Bratslav', 'Bryansk', 'Brynsk', 'Buryn', 'Byhov', 'Chechersk', 'Chemesov', 'Cheremosh', 'Cherlen', 'Chern', 'Chernigov', 'Chernitsa', 'Chernobyl', 'Chernogorod', 'Chertoryesk', 'Chetvertnia', 'Demyansk', 'Derevesk', 'Devyagoresk', 'Dichin', 'Dmitrov', 'Dorogobuch', 'Dorogobuzh', 'Drestvin', 'Drokov', 'Drutsk', 'Dubechin', 'Dubichi', 'Dubki', 'Dubkov', 'Dveren', 'Galich', 'Glebovo', 'Glinsk', 'Goloty', 'Gomiy', 'Gorodets', 'Gorodische', 'Gorodno', 'Gorohovets', 'Goroshin', 'Gorval', 'Goryshon', 'Holm', 'Horobor', 'Hoten', 'Hotin', 'Hotmyzhsk', 'Ilovech', 'Ivan', 'Izborsk', 'Izheslavl', 'Kamenets', 'Kanev', 'Karachev', 'Karna', 'Kavarna', 'Klechesk', 'Klyapech', 'Kolomyya', 'Kolyvan', 'Kopyl', 'Korec', 'Kornik', 'Korochunov', 'Korshev', 'Korsun', 'Koshkin', 'Kotelno', 'Kovyla', 'Kozelsk', 'Kozelsk', 'Kremenets', 'Krichev', 'Krylatsk', 'Ksniatin', 'Kulatsk', 'Kursk', 'Kursk', 'Lebedev', 'Lida', 'Logosko', 'Lomihvost', 'Loshesk', 'Loshichi', 'Lubech', 'Lubno', 'Lubutsk', 'Lutsk', 'Luchin', 'Luki', 'Lukoml', 'Luzha', 'Lvov', 'Mtsensk', 'Mdin', 'Medniki', 'Melecha', 'Merech', 'Meretsk', 'Mescherskoe', 'Meshkovsk', 'Metlitsk', 'Mezetsk', 'Mglin', 'Mihailov', 'Mikitin', 'Mikulino', 'Miloslavichi', 'Mogilev', 'Mologa', 'Moreva', 'Mosalsk', 'Moschiny', 'Mozyr', 'Mstislav', 'Mstislavets', 'Muravin', 'Nemech', 'Nemiza', 'Nerinsk', 'Nichan', 'Novgorod', 'Novogorodok', 'Obolichi', 'Obolensk', 'Obolensk', 'Oleshsk', 'Olgov', 'Omelnik', 'Opoka', 'Opoki', 'Oreshek', 'Orlets', 'Osechen', 'Oster', 'Ostrog', 'Ostrov', 'Perelai', 'Peremil', 'Peremyshl', 'Pererov', 'Peresechen', 'Perevitsk', 'Pereyaslav', 'Pinsk', 'Ples', 'Polotsk', 'Pronsk', 'Proposhesk', 'Punia', 'Putivl', 'Rechitsa', 'Rodno', 'Rogachev', 'Romanov', 'Romny', 'Roslavl', 'Rostislavl', 'Rostovets', 'Rsha', 'Ruza', 'Rybchesk', 'Rylsk', 'Rzhavesk', 'Rzhev', 'Rzhischev', 'Sambor', 'Serensk', 'Serensk', 'Serpeysk', 'Shilov', 'Shuya', 'Sinech', 'Sizhka', 'Skala', 'Slovensk', 'Slutsk', 'Smedin', 'Sneporod', 'Snitin', 'Snovsk', 'Sochevo', 'Sokolec', 'Starica', 'Starodub', 'Stepan', 'Sterzh', 'Streshin', 'Sutesk', 'Svinetsk', 'Svisloch', 'Terebovl', 'Ternov', 'Teshilov', 'Teterin', 'Tiversk', 'Torchevsk', 'Toropets', 'Torzhok', 'Tripolye', 'Trubchevsk', 'Tur', 'Turov', 'Usvyaty', 'Uteshkov', 'Vasilkov', 'Velil', 'Velye', 'Venev', 'Venicha', 'Verderev', 'Vereya', 'Veveresk', 'Viazma', 'Vidbesk', 'Vidychev', 'Voino', 'Volodimer', 'Volok', 'Volyn', 'Vorobesk', 'Voronich', 'Voronok', 'Vorotynsk', 'Vrev', 'Vruchiy', 'Vselug', 'Vyatichsk', 'Vyatka', 'Vyshegorod', 'Vyshgorod', 'Vysokoe', 'Yagniatin', 'Yaropolch', 'Yasenets', 'Yuryev', 'Yuryevets', 'Zaraysk', 'Zhitomel', 'Zholvazh', 'Zizhech', 'Zubkov', 'Zudechev', 'Zvenigorod'],\n      ['Akureyri', 'Aldra', 'Alftanes', 'Andenes', 'Austbo', 'Auvog', 'Bakkafjordur', 'Ballangen', 'Bardal', 'Beisfjord', 'Bifrost', 'Bildudalur', 'Bjerka', 'Bjerkvik', 'Bjorkosen', 'Bliksvaer', 'Blokken', 'Blonduos', 'Bolga', 'Bolungarvik', 'Borg', 'Borgarnes', 'Bosmoen', 'Bostad', 'Bostrand', 'Botsvika', 'Brautarholt', 'Breiddalsvik', 'Bringsli', 'Brunahlid', 'Budardalur', 'Byggdakjarni', 'Dalvik', 'Djupivogur', 'Donnes', 'Drageid', 'Drangsnes', 'Egilsstadir', 'Eiteroga', 'Elvenes', 'Engavogen', 'Ertenvog', 'Eskifjordur', 'Evenes', 'Eyrarbakki', 'Fagernes', 'Fallmoen', 'Fellabaer', 'Fenes', 'Finnoya', 'Fjaer', 'Fjelldal', 'Flakstad', 'Flateyri', 'Flostrand', 'Fludir', 'Gardabær', 'Gardur', 'Gimstad', 'Givaer', 'Gjeroy', 'Gladstad', 'Godoya', 'Godoynes', 'Granmoen', 'Gravdal', 'Grenivik', 'Grimsey', 'Grindavik', 'Grytting', 'Hafnir', 'Halsa', 'Hauganes', 'Haugland', 'Hauknes', 'Hella', 'Helland', 'Hellissandur', 'Hestad', 'Higrav', 'Hnifsdalur', 'Hofn', 'Hofsos', 'Holand', 'Holar', 'Holen', 'Holkestad', 'Holmavik', 'Hopen', 'Hovden', 'Hrafnagil', 'Hrisey', 'Husavik', 'Husvik', 'Hvammstangi', 'Hvanneyri', 'Hveragerdi', 'Hvolsvollur', 'Igeroy', 'Indre', 'Inndyr', 'Innhavet', 'Innes', 'Isafjordur', 'Jarklaustur', 'Jarnsreykir', 'Junkerdal', 'Kaldvog', 'Kanstad', 'Karlsoy', 'Kavosen', 'Keflavik', 'Kjelde', 'Kjerstad', 'Klakk', 'Kopasker', 'Kopavogur', 'Korgen', 'Kristnes', 'Krutoga', 'Krystad', 'Kvina', 'Lande', 'Laugar', 'Laugaras', 'Laugarbakki', 'Laugarvatn', 'Laupstad', 'Leines', 'Leira', 'Leiren', 'Leland', 'Lenvika', 'Loding', 'Lodingen', 'Lonsbakki', 'Lopsmarka', 'Lovund', 'Luroy', 'Maela', 'Melahverfi', 'Meloy', 'Mevik', 'Misvaer', 'Mornes', 'Mosfellsbær', 'Moskenes', 'Myken', 'Naurstad', 'Nesberg', 'Nesjahverfi', 'Nesset', 'Nevernes', 'Obygda', 'Ofoten', 'Ogskardet', 'Okervika', 'Oknes', 'Olafsfjordur', 'Oldervika', 'Olstad', 'Onstad', 'Oppeid', 'Oresvika', 'Orsnes', 'Orsvog', 'Osmyra', 'Overdal', 'Prestoya', 'Raudalaekur', 'Raufarhofn', 'Reipo', 'Reykholar', 'Reykholt', 'Reykjahlid', 'Rif', 'Rinoya', 'Rodoy', 'Rognan', 'Rosvika', 'Rovika', 'Salhus', 'Sanden', 'Sandgerdi', 'Sandoker', 'Sandset', 'Sandvika', 'Saudarkrokur', 'Selfoss', 'Selsoya', 'Sennesvik', 'Setso', 'Siglufjordur', 'Silvalen', 'Skagastrond', 'Skjerstad', 'Skonland', 'Skorvogen', 'Skrova', 'Sleneset', 'Snubba', 'Softing', 'Solheim', 'Solheimar', 'Sorarnoy', 'Sorfugloy', 'Sorland', 'Sormela', 'Sorvaer', 'Sovika', 'Stamsund', 'Stamsvika', 'Stave', 'Stokka', 'Stokkseyri', 'Storjord', 'Storo', 'Storvika', 'Strand', 'Straumen', 'Strendene', 'Sudavik', 'Sudureyri', 'Sundoya', 'Sydalen', 'Thingeyri', 'Thorlakshofn', 'Thorshofn', 'Tjarnabyggd', 'Tjotta', 'Tosbotn', 'Traelnes', 'Trofors', 'Trones', 'Tverro', 'Ulvsvog', 'Unnstad', 'Utskor', 'Valla', 'Vandved', 'Varmahlid', 'Vassos', 'Vevelstad', 'Vidrek', 'Vik', 'Vikholmen', 'Vogar', 'Vogehamn', 'Vopnafjordur'],\n      ['Abdera', 'Abila', 'Abydos', 'Acanthus', 'Acharnae', 'Actium', 'Adramyttium', 'Aegae', 'Aegina', 'Aegium', 'Aenus', 'Agrinion', 'Aigosthena', 'Akragas', 'Akrai', 'Akrillai', 'Akroinon', 'Akrotiri', 'Alalia', 'Alexandreia', 'Alexandretta', 'Alexandria', 'Alinda', 'Amarynthos', 'Amaseia', 'Ambracia', 'Amida', 'Amisos', 'Amnisos', 'Amphicaea', 'Amphigeneia', 'Amphipolis', 'Amphissa', 'Ankon', 'Antigona', 'Antipatrea', 'Antioch', 'Antioch', 'Antiochia', 'Andros', 'Apamea', 'Aphidnae', 'Apollonia', 'Argos', 'Arsuf', 'Artanes', 'Artemita', 'Argyroupoli', 'Asine', 'Asklepios', 'Aspendos', 'Assus', 'Astacus', 'Athenai', 'Athmonia', 'Aytos', 'Ancient', 'Baris', 'Bhrytos', 'Borysthenes', 'Berge', 'Boura', 'Bouthroton', 'Brauron', 'Byblos', 'Byllis', 'Byzantium', 'Bythinion', 'Callipolis', 'Cebrene', 'Chalcedon', 'Calydon', 'Carystus', 'Chamaizi', 'Chalcis', 'Chersonesos', 'Chios', 'Chytri', 'Clazomenae', 'Cleonae', 'Cnidus', 'Colosse', 'Corcyra', 'Croton', 'Cyme', 'Cyrene', 'Cythera', 'Decelea', 'Delos', 'Delphi', 'Demetrias', 'Dicaearchia', 'Dimale', 'Didyma', 'Dion', 'Dioscurias', 'Dodona', 'Dorylaion', 'Dyme', 'Edessa', 'Elateia', 'Eleusis', 'Eleutherna', 'Emporion', 'Ephesus', 'Ephyra', 'Epidamnos', 'Epidauros', 'Eresos', 'Eretria', 'Erythrae', 'Eubea', 'Gangra', 'Gaza', 'Gela', 'Golgi', 'Gonnos', 'Gorgippia', 'Gournia', 'Gortyn', 'Gythium', 'Hagios', 'Hagia', 'Halicarnassus', 'Halieis', 'Helike', 'Heliopolis', 'Hellespontos', 'Helorus', 'Hemeroskopeion', 'Heraclea', 'Hermione', 'Hermonassa', 'Hierapetra', 'Hierapolis', 'Himera', 'Histria', 'Hubla', 'Hyele', 'Ialysos', 'Iasus', 'Idalium', 'Imbros', 'Iolcus', 'Itanos', 'Ithaca', 'Juktas', 'Kallipolis', 'Kamares', 'Kameiros', 'Kannia', 'Kamarina', 'Kasmenai', 'Katane', 'Kerkinitida', 'Kepoi', 'Kimmerikon', 'Kios', 'Klazomenai', 'Knidos', 'Knossos', 'Korinthos', 'Kos', 'Kourion', 'Kume', 'Kydonia', 'Kynos', 'Kyrenia', 'Lamia', 'Lampsacus', 'Laodicea', 'Lapithos', 'Larissa', 'Lato', 'Laus', 'Lebena', 'Lefkada', 'Lekhaion', 'Leibethra', 'Leontinoi', 'Lepreum', 'Lessa', 'Lilaea', 'Lindus', 'Lissus', 'Epizephyrian', 'Madytos', 'Magnesia', 'Mallia', 'Mantineia', 'Marathon', 'Marmara', 'Maroneia', 'Masis', 'Massalia', 'Megalopolis', 'Megara', 'Mesembria', 'Messene', 'Metapontum', 'Methana', 'Methone', 'Methumna', 'Miletos', 'Misenum', 'Mochlos', 'Monastiraki', 'Morgantina', 'Mulai', 'Mukenai', 'Mylasa', 'Myndus', 'Myonia', 'Myra', 'Myrmekion', 'Mutilene', 'Myos', 'Nauplios', 'Naucratis', 'Naupactus', 'Naxos', 'Neapoli', 'Neapolis', 'Nemea', 'Nicaea', 'Nicopolis', 'Nirou', 'Nymphaion', 'Nysa', 'Oenoe', 'Oenus', 'Odessos', 'Olbia', 'Olous', 'Olympia', 'Olynthus', 'Opus', 'Orchomenus', 'Oricos', 'Orestias', 'Oreus', 'Oropus', 'Onchesmos', 'Pactye', 'Pagasae', 'Palaikastro', 'Pandosia', 'Panticapaeum', 'Paphos', 'Parium', 'Paros', 'Parthenope', 'Patrae', 'Pavlopetri', 'Pegai', 'Pelion', 'Peiraieús', 'Pella', 'Percote', 'Pergamum', 'Petsofa', 'Phaistos', 'Phaleron', 'Phanagoria', 'Pharae', 'Pharnacia', 'Pharos', 'Phaselis', 'Philippi', 'Pithekussa', 'Philippopolis', 'Platanos', 'Phlius', 'Pherae', 'Phocaea', 'Pinara', 'Pisa', 'Pitane', 'Pitiunt', 'Pixous', 'Plataea', 'Poseidonia', 'Potidaea', 'Priapus', 'Priene', 'Prousa', 'Pseira', 'Psychro', 'Pteleum', 'Pydna', 'Pylos', 'Pyrgos', 'Rhamnus', 'Rhegion', 'Rhithymna', 'Rhodes', 'Rhypes', 'Rizinia', 'Salamis', 'Same', 'Samos', 'Scyllaeum', 'Selinus', 'Seleucia', 'Semasus', 'Sestos', 'Scidrus', 'Sicyon', 'Side', 'Sidon', 'Siteia', 'Sinope', 'Siris', 'Sklavokampos', 'Smyrna', 'Soli', 'Sozopolis', 'Sparta', 'Stagirus', 'Stratos', 'Stymphalos', 'Sybaris', 'Surakousai', 'Taras', 'Tanagra', 'Tanais', 'Tauromenion', 'Tegea', 'Temnos', 'Tenedos', 'Tenea', 'Teos', 'Thapsos', 'Thassos', 'Thebai', 'Theodosia', 'Therma', 'Thespiae', 'Thronion', 'Thoricus', 'Thurii', 'Thyreum', 'Thyria', 'Tiruns', 'Tithoraea', 'Tomis', 'Tragurion', 'Trapeze', 'Trapezus', 'Tripolis', 'Troizen', 'Troliton', 'Troy', 'Tylissos', 'Tyras', 'Tyros', 'Tyritake', 'Vasiliki', 'Vathypetros', 'Zakynthos', 'Zakros', 'Zankle'],\n      ['Abila', 'Adflexum', 'Adnicrem', 'Aelia', 'Aelius', 'Aeminium', 'Aequum', 'Agrippina', 'Agrippinae', 'Ala', 'Albanianis', 'Ambianum', 'Andautonia', 'Apulum', 'Aquae', 'Aquaegranni', 'Aquensis', 'Aquileia', 'Aquincum', 'Arae', 'Argentoratum', 'Ariminum', 'Ascrivium', 'Atrebatum', 'Atuatuca', 'Augusta', 'Aurelia', 'Aurelianorum', 'Batavar', 'Batavorum', 'Belum', 'Biriciana', 'Blestium', 'Bonames', 'Bonna', 'Bononia', 'Borbetomagus', 'Bovium', 'Bracara', 'Brigantium', 'Burgodunum', 'Caesaraugusta', 'Caesarea', 'Caesaromagus', 'Calleva', 'Camulodunum', 'Cannstatt', 'Cantiacorum', 'Capitolina', 'Castellum', 'Castra', 'Castrum', 'Cibalae', 'Clausentum', 'Colonia', 'Concangis', 'Condate', 'Confluentes', 'Conimbriga', 'Corduba', 'Coria', 'Corieltauvorum', 'Corinium', 'Coriovallum', 'Cornoviorum', 'Danum', 'Deva', 'Divodurum', 'Dobunnorum', 'Drusi', 'Dubris', 'Dumnoniorum', 'Durnovaria', 'Durocobrivis', 'Durocornovium', 'Duroliponte', 'Durovernum', 'Durovigutum', 'Eboracum', 'Edetanorum', 'Emerita', 'Emona', 'Euracini', 'Faventia', 'Flaviae', 'Florentia', 'Forum', 'Gerulata', 'Gerunda', 'Glevensium', 'Hadriani', 'Herculanea', 'Isca', 'Italica', 'Iulia', 'Iuliobrigensium', 'Iuvavum', 'Lactodurum', 'Lagentium', 'Lauri', 'Legionis', 'Lemanis', 'Lentia', 'Lepidi', 'Letocetum', 'Lindinis', 'Lindum', 'Londinium', 'Lopodunum', 'Lousonna', 'Lucus', 'Lugdunum', 'Luguvalium', 'Lutetia', 'Mancunium', 'Marsonia', 'Martius', 'Massa', 'Matilo', 'Mattiacorum', 'Mediolanum', 'Mod', 'Mogontiacum', 'Moridunum', 'Mursa', 'Naissus', 'Nervia', 'Nida', 'Nigrum', 'Novaesium', 'Noviomagus', 'Olicana', 'Ovilava', 'Parisiorum', 'Partiscum', 'Paterna', 'Pistoria', 'Placentia', 'Pollentia', 'Pomaria', 'Pons', 'Portus', 'Praetoria', 'Praetorium', 'Pullum', 'Ragusium', 'Ratae', 'Raurica', 'Regina', 'Regium', 'Regulbium', 'Rigomagus', 'Roma', 'Romula', 'Rutupiae', 'Salassorum', 'Salernum', 'Salona', 'Scalabis', 'Segovia', 'Silurum', 'Sirmium', 'Siscia', 'Sorviodurum', 'Sumelocenna', 'Tarraco', 'Taurinorum', 'Theranda', 'Traiectum', 'Treverorum', 'Tungrorum', 'Turicum', 'Ulpia', 'Valentia', 'Venetiae', 'Venta', 'Verulamium', 'Vesontio', 'Vetera', 'Victoriae', 'Victrix', 'Villa', 'Viminacium', 'Vindelicorum', 'Vindobona', 'Vinovia', 'Viroconium'],\n      ['Aanekoski', 'Abjapaluoja', 'Ahlainen', 'Aholanvaara', 'Ahtari', 'Aijala', 'Aimala', 'Akaa', 'Alajarvi', 'Alatornio', 'Alavus', 'Antsla', 'Aspo', 'Bennas', 'Bjorkoby', 'Elva', 'Emasalo', 'Espoo', 'Esse', 'Evitskog', 'Forssa', 'Haapajarvi', 'Haapamaki', 'Haapavesi', 'Haapsalu', 'Haavisto', 'Hameenlinna', 'Hameenmaki', 'Hamina', 'Hanko', 'Harjavalta', 'Hattuvaara', 'Haukipudas', 'Hautajarvi', 'Havumaki', 'Heinola', 'Hetta', 'Hinkabole', 'Hirmula', 'Hossa', 'Huittinen', 'Husula', 'Hyryla', 'Hyvinkaa', 'Iisalmi', 'Ikaalinen', 'Ilmola', 'Imatra', 'Inari', 'Iskmo', 'Itakoski', 'Jamsa', 'Jarvenpaa', 'Jeppo', 'Jioesuu', 'Jiogeva', 'Joensuu', 'Jokela', 'Jokikyla', 'Jokisuu', 'Jormua', 'Juankoski', 'Jungsund', 'Jyvaskyla', 'Kaamasmukka', 'Kaarina', 'Kajaani', 'Kalajoki', 'Kallaste', 'Kankaanpaa', 'Kannus', 'Kardla', 'Karesuvanto', 'Karigasniemi', 'Karkkila', 'Karkku', 'Karksinuia', 'Karpankyla', 'Kaskinen', 'Kasnas', 'Kauhajoki', 'Kauhava', 'Kauniainen', 'Kauvatsa', 'Kehra', 'Keila', 'Kellokoski', 'Kelottijarvi', 'Kemi', 'Kemijarvi', 'Kerava', 'Keuruu', 'Kiikka', 'Kiipu', 'Kilinginiomme', 'Kiljava', 'Kilpisjarvi', 'Kitee', 'Kiuruvesi', 'Kivesjarvi', 'Kiviioli', 'Kivisuo', 'Klaukkala', 'Klovskog', 'Kohtlajarve', 'Kokemaki', 'Kokkola', 'Kolho', 'Koria', 'Koskue', 'Kotka', 'Kouva', 'Kouvola', 'Kristiina', 'Kaupunki', 'Kuhmo', 'Kunda', 'Kuopio', 'Kuressaare', 'Kurikka', 'Kusans', 'Kuusamo', 'Kylmalankyla', 'Lahti', 'Laitila', 'Lankipohja', 'Lansikyla', 'Lappeenranta', 'Lapua', 'Laurila', 'Lautiosaari', 'Lepsama', 'Liedakkala', 'Lieksa', 'Lihula', 'Littoinen', 'Lohja', 'Loimaa', 'Loksa', 'Loviisa', 'Luohuanylipaa', 'Lusi', 'Maardu', 'Maarianhamina', 'Malmi', 'Mantta', 'Masaby', 'Masala', 'Matasvaara', 'Maula', 'Miiluranta', 'Mikkeli', 'Mioisakula', 'Munapirtti', 'Mustvee', 'Muurahainen', 'Naantali', 'Nappa', 'Narpio', 'Nickby', 'Niinimaa', 'Niinisalo', 'Nikkila', 'Nilsia', 'Nivala', 'Nokia', 'Nummela', 'Nuorgam', 'Nurmes', 'Nuvvus', 'Obbnas', 'Oitti', 'Ojakkala', 'Ollola', 'onningeby', 'Orimattila', 'Orivesi', 'Otanmaki', 'Otava', 'Otepaa', 'Oulainen', 'Oulu', 'Outokumpu', 'Paavola', 'Paide', 'Paimio', 'Pakankyla', 'Paldiski', 'Parainen', 'Parkano', 'Parkumaki', 'Parola', 'Perttula', 'Pieksamaki', 'Pietarsaari', 'Pioltsamaa', 'Piolva', 'Pohjavaara', 'Porhola', 'Pori', 'Porrasa', 'Porvoo', 'Pudasjarvi', 'Purmo', 'Pussi', 'Pyhajarvi', 'Raahe', 'Raasepori', 'Raisio', 'Rajamaki', 'Rakvere', 'Rapina', 'Rapla', 'Rauma', 'Rautio', 'Reposaari', 'Riihimaki', 'Rovaniemi', 'Roykka', 'Ruonala', 'Ruottala', 'Rutalahti', 'Saarijarvi', 'Salo', 'Sastamala', 'Saue', 'Savonlinna', 'Seinajoki', 'Sillamae', 'Sindi', 'Siuntio', 'Somero', 'Sompujarvi', 'Suonenjoki', 'Suurejaani', 'Syrjantaka', 'Tampere', 'Tamsalu', 'Tapa', 'Temmes', 'Tiorva', 'Tormasenvaara', 'Tornio', 'Tottijarvi', 'Tulppio', 'Turenki', 'Turi', 'Tuukkala', 'Tuurala', 'Tuuri', 'Tuuski', 'Ulvila', 'Unari', 'Upinniemi', 'Utti', 'Uusikaarlepyy', 'Uusikaupunki', 'Vaaksy', 'Vaalimaa', 'Vaarinmaja', 'Vaasa', 'Vainikkala', 'Valga', 'Valkeakoski', 'Vantaa', 'Varkaus', 'Vehkapera', 'Vehmasmaki', 'Vieki', 'Vierumaki', 'Viitasaari', 'Viljandi', 'Vilppula', 'Viohma', 'Vioru', 'Virrat', 'Ylike', 'Ylivieska', 'Ylojarvi'],\n      ['Sabi', 'Wiryeseong', 'Hwando', 'Gungnae', 'Ungjin', 'Wanggeomseong', 'Ganggyeong', 'Jochiwon', 'Cheorwon', 'Beolgyo', 'Gangjin', 'Gampo', 'Yecheon', 'Geochang', 'Janghang', 'Hadong', 'Goseong', 'Yeongdong', 'Yesan', 'Sintaein', 'Geumsan', 'Boseong', 'Jangheung', 'Uiseong', 'Jumunjin', 'Janghowon', 'Hongseong', 'Gimhwa', 'Gwangcheon', 'Guryongpo', 'Jinyeong', 'Buan', 'Damyang', 'Jangseong', 'Wando', 'Angang', 'Okcheon', 'Jeungpyeong', 'Waegwan', 'Cheongdo', 'Gwangyang', 'Gochang', 'Haenam', 'Yeonggwang', 'Hanam', 'Eumseong', 'Daejeong', 'Hanrim', 'Samrye', 'Yongjin', 'Hamyang', 'Buyeo', 'Changnyeong', 'Yeongwol', 'Yeonmu', 'Gurye', 'Hwasun', 'Hampyeong', 'Namji', 'Samnangjin', 'Dogye', 'Hongcheon', 'Munsan', 'Gapyeong', 'Ganghwa', 'Geojin', 'Sangdong', 'Jeongseon', 'Sabuk', 'Seonghwan', 'Heunghae', 'Hapdeok', 'Sapgyo', 'Taean', 'Boeun', 'Geumwang', 'Jincheon', 'Bongdong', 'Doyang', 'Geoncheon', 'Pungsan', 'Punggi', 'Geumho', 'Wonju', 'Gaun', 'Hayang', 'Yeoju', 'Paengseong', 'Yeoncheon', 'Yangpyeong', 'Ganseong', 'Yanggu', 'Yangyang', 'Inje', 'Galmal', 'Pyeongchang', 'Hwacheon', 'Hoengseong', 'Seocheon', 'Cheongyang', 'Goesan', 'Danyang', 'Hamyeol', 'Muju', 'Sunchang', 'Imsil', 'Jangsu', 'Jinan', 'Goheung', 'Gokseong', 'Muan', 'Yeongam', 'Jindo', 'Seonsan', 'Daegaya', 'Gunwi', 'Bonghwa', 'Seongju', 'Yeongdeok', 'Yeongyang', 'Ulleung', 'Uljin', 'Cheongsong', 'wayang', 'Namhae', 'Sancheong', 'Uiryeong', 'Gaya', 'Hapcheon', 'Wabu', 'Dongsong', 'Sindong', 'Wondeok', 'Maepo', 'Anmyeon', 'Okgu', 'Sariwon', 'Dolsan', 'Daedeok', 'Gwansan', 'Geumil', 'Nohwa', 'Baeksu', 'Illo', 'Jido', 'Oedong', 'Ocheon', 'Yeonil', 'Hamchang', 'Pyeonghae', 'Gijang', 'Jeonggwan', 'Aewor', 'Gujwa', 'Seongsan', 'Jeongok', 'Seonggeo', 'Seungju', 'Hongnong', 'Jangan', 'Jocheon', 'Gohan', 'Jinjeop', 'Bubal', 'Beobwon', 'Yeomchi', 'Hwado', 'Daesan', 'Hwawon', 'Apo', 'Nampyeong', 'Munsan', 'Sinbuk', 'Munmak', 'Judeok', 'Bongyang', 'Ungcheon', 'Yugu', 'Unbong', 'Mangyeong', 'Dong', 'Naeseo', 'Sanyang', 'Soheul', 'Onsan', 'Eonyang', 'Nongong', 'Dasa', 'Goa', 'Jillyang', 'Bongdam', 'Naesu', 'Beomseo', 'Opo', 'Gongdo', 'Jingeon', 'Onam', 'Baekseok', 'Jiksan', 'Mokcheon', 'Jori', 'Anjung', 'Samho', 'Ujeong', 'Buksam', 'Tongjin', 'Chowol', 'Gonjiam', 'Pogok', 'Seokjeok', 'Poseung', 'Ochang', 'Hyangnam', 'Baebang', 'Gochon', 'Songak', 'Samhyang', 'Yangchon', 'Osong', 'Aphae', 'Ganam', 'Namyang', 'Chirwon', 'Andong', 'Ansan', 'Anseong', 'Anyang', 'Asan', 'Boryeong', 'Bucheon', 'Busan', 'Changwon', 'Cheonan', 'Cheongju', 'Chuncheon', 'Chungju', 'Daegu', 'Daejeon', 'Dangjin', 'Dongducheon', 'Donghae', 'Gangneung', 'Geoje', 'Gimcheon', 'Gimhae', 'Gimje', 'Gimpo', 'Gongju', 'Goyang', 'Gumi', 'Gunpo', 'Gunsan', 'Guri', 'Gwacheon', 'Gwangju', 'Gwangju', 'Gwangmyeong', 'Gyeongju', 'Gyeongsan', 'Gyeryong', 'Hwaseong', 'Icheon', 'Iksan', 'Incheon', 'Jecheon', 'Jeongeup', 'Jeonju', 'Jeju', 'Jinju', 'Naju', 'Namyangju', 'Namwon', 'Nonsan', 'Miryang', 'Mokpo', 'Mungyeong', 'Osan', 'Paju', 'Pocheon', 'Pohang', 'Pyeongtaek', 'Sacheon', 'Sangju', 'Samcheok', 'Sejong', 'Seogwipo', 'Seongnam', 'Seosan', 'Seoul', 'Siheung', 'Sokcho', 'Suncheon', 'Suwon', 'Taebaek', 'Tongyeong', 'Uijeongbu', 'Uiwang', 'Ulsan', 'Yangju', 'Yangsan', 'Yeongcheon', 'Yeongju', 'Yeosu', 'Yongin', 'Chungmu', 'Daecheon', 'Donggwangyang', 'Geumseong', 'Gyeongseong', 'Iri', 'Jangseungpo', 'Jeomchon', 'Jeongju', 'Migeum', 'Onyang', 'Samcheonpo', 'Busan', 'Busan', 'Cheongju', 'Chuncheon', 'Daegu', 'Daegu', 'Daejeon', 'Daejeon', 'Gunsan', 'Gwangju', 'Gwangju', 'Gyeongseong', 'Incheon', 'Incheon', 'Iri', 'Jeonju', 'Jinhae', 'Jinju', 'Masan', 'Masan', 'Mokpo', 'Songjeong', 'Songtan', 'Ulsan', 'Yeocheon', 'Cheongjin', 'Gaeseong', 'Haeju', 'Hamheung', 'Heungnam', 'Jinnampo', 'Najin', 'Pyeongyang', 'Seongjin', 'Sineuiju', 'Songnim', 'Wonsan'],\n      ['Anding', 'Anlu', 'Anqing', 'Anshun', 'Baan', 'Baixing', 'Banyang', 'Baoding', 'Baoqing', 'Binzhou', 'Caozhou', 'Changbai', 'Changchun', 'Changde', 'Changling', 'Changsha', 'Changtu', 'Changzhou', 'Chaozhou', 'Cheli', 'Chengde', 'Chengdu', 'Chenzhou', 'Chizhou', 'Chongqing', 'Chuxiong', 'Chuzhou', 'Dading', 'Dali', 'Daming', 'Datong', 'Daxing', 'Dean', 'Dengke', 'Dengzhou', 'Deqing', 'Dexing', 'Dihua', 'Dingli', 'Dongan', 'Dongchang', 'Dongchuan', 'Dongping', 'Duyun', 'Fengtian', 'Fengxiang', 'Fengyang', 'Fenzhou', 'Funing', 'Fuzhou', 'Ganzhou', 'Gaoyao', 'Gaozhou', 'Gongchang', 'Guangnan', 'Guangning', 'Guangping', 'Guangxin', 'Guangzhou', 'Guide', 'Guilin', 'Guiyang', 'Hailong', 'Hailun', 'Hangzhou', 'Hanyang', 'Hanzhong', 'Heihe', 'Hejian', 'Henan', 'Hengzhou', 'Hezhong', 'Huaian', 'Huaide', 'Huaiqing', 'Huanglong', 'Huangzhou', 'Huining', 'Huizhou', 'Hulan', 'Huzhou', 'Jiading', 'Jian', 'Jianchang', 'Jiande', 'Jiangning', 'Jiankang', 'Jianning', 'Jiaxing', 'Jiayang', 'Jilin', 'Jinan', 'Jingjiang', 'Jingzhao', 'Jingzhou', 'Jinhua', 'Jinzhou', 'Jiujiang', 'Kaifeng', 'Kaihua', 'Kangding', 'Kuizhou', 'Laizhou', 'Lanzhou', 'Leizhou', 'Liangzhou', 'Lianzhou', 'Liaoyang', 'Lijiang', 'Linan', 'Linhuang', 'Linjiang', 'Lintao', 'Liping', 'Liuzhou', 'Longan', 'Longjiang', 'Longqing', 'Longxing', 'Luan', 'Lubin', 'Lubin', 'Luzhou', 'Mishan', 'Nanan', 'Nanchang', 'Nandian', 'Nankang', 'Nanning', 'Nanyang', 'Nenjiang', 'Ningan', 'Ningbo', 'Ningguo', 'Ninguo', 'Ningwu', 'Ningxia', 'Ningyuan', 'Pingjiang', 'Pingle', 'Pingliang', 'Pingyang', 'Puer', 'Puzhou', 'Qianzhou', 'Qingyang', 'Qingyuan', 'Qingzhou', 'Qiongzhou', 'Qujing', 'Quzhou', 'Raozhou', 'Rende', 'Ruian', 'Ruizhou', 'Runing', 'Shafeng', 'Shajing', 'Shaoqing', 'Shaowu', 'Shaoxing', 'Shaozhou', 'Shinan', 'Shiqian', 'Shouchun', 'Shuangcheng', 'Shulei', 'Shunde', 'Shunqing', 'Shuntian', 'Shuoping', 'Sicheng', 'Sien', 'Sinan', 'Sizhou', 'Songjiang', 'Suiding', 'Suihua', 'Suining', 'Suzhou', 'Taian', 'Taibei', 'Tainan', 'Taiping', 'Taiwan', 'Taiyuan', 'Taizhou', 'Taonan', 'Tengchong', 'Tieli', 'Tingzhou', 'Tongchuan', 'Tongqing', 'Tongren', 'Tongzhou', 'Weihui', 'Wensu', 'Wenzhou', 'Wuchang', 'Wuding', 'Wuzhou', 'Xian', 'Xianchun', 'Xianping', 'Xijin', 'Xiliang', 'Xincheng', 'Xingan', 'Xingde', 'Xinghua', 'Xingjing', 'Xingqing', 'Xingyi', 'Xingyuan', 'Xingzhong', 'Xining', 'Xinmen', 'Xiping', 'Xuanhua', 'Xunzhou', 'Xuzhou', 'Yanan', 'Yangzhou', 'Yanji', 'Yanping', 'Yanqi', 'Yanzhou', 'Yazhou', 'Yichang', 'Yidu', 'Yilan', 'Yili', 'Yingchang', 'Yingde', 'Yingtian', 'Yingzhou', 'Yizhou', 'Yongchang', 'Yongping', 'Yongshun', 'Yongzhou', 'Yuanzhou', 'Yuezhou', 'Yulin', 'Yunnan', 'Yunyang', 'Zezhou', 'Zhangde', 'Zhangzhou', 'Zhaoqing', 'Zhaotong', 'Zhenan', 'Zhending', 'Zhengding', 'Zhenhai', 'Zhenjiang', 'Zhenxi', 'Zhenyun', 'Zhongshan', 'Zunyi'],\n      ['Nanporo', 'Naie', 'Kamisunagawa', 'Yuni', 'Naganuma', 'Kuriyama', 'Tsukigata', 'Urausu', 'Shintotsukawa', 'Moseushi', 'Chippubetsu', 'Uryu', 'Hokuryu', 'Numata', 'Tobetsu', 'Suttsu', 'Kuromatsunai', 'Rankoshi', 'Niseko', 'Kimobetsu', 'Kyogoku', 'Kutchan', 'Kyowa', 'Iwanai', 'Shakotan', 'Furubira', 'Niki', 'Yoichi', 'Toyoura', 'Toyako', 'Sobetsu', 'Shiraoi', 'Atsuma', 'Abira', 'Mukawa', 'Hidaka', 'Biratori', 'Niikappu', 'Urakawa', 'Samani', 'Erimo', 'Shinhidaka', 'Matsumae', 'Fukushima', 'Shiriuchi', 'Kikonai', 'Nanae', 'Shikabe', 'Mori', 'Yakumo', 'Oshamambe', 'Esashi', 'Kaminokuni', 'Assabu', 'Otobe', 'Okushiri', 'Imakane', 'Setana', 'Takasu', 'Higashikagura', 'Toma', 'Pippu', 'Aibetsu', 'Kamikawa', 'Higashikawa', 'Biei', 'Kamifurano', 'Nakafurano', 'Minamifurano', 'Horokanai', 'Wassamu', 'Kenbuchi', 'Shimokawa', 'Bifuka', 'Nakagawa', 'Mashike', 'Obira', 'Tomamae', 'Haboro', 'Enbetsu', 'Teshio', 'Hamatonbetsu', 'Nakatonbetsu', 'Esashi', 'Toyotomi', 'Horonobe', 'Rebun', 'Rishiri', 'Rishirifuji', 'Bihoro', 'Tsubetsu', 'Ozora', 'Shari', 'Kiyosato', 'Koshimizu', 'Kunneppu', 'Oketo', 'Saroma', 'Engaru', 'Yubetsu', 'Takinoue', 'Okoppe', 'Omu', 'Otofuke', 'Shihoro', 'Kamishihoro', 'Shikaoi', 'Shintoku', 'Shimizu', 'Memuro', 'Taiki', 'Hiroo', 'Makubetsu', 'Ikeda', 'Toyokoro', 'Honbetsu', 'Ashoro', 'Rikubetsu', 'Urahoro', 'Kushiro', 'Akkeshi', 'Hamanaka', 'Shibecha', 'Teshikaga', 'Shiranuka', 'Betsukai', 'Nakashibetsu', 'Shibetsu', 'Rausu', 'Hiranai', 'Imabetsu', 'Sotogahama', 'Ajigasawa', 'Fukaura', 'Fujisaki', 'Owani', 'Itayanagi', 'Tsuruta', 'Nakadomari', 'Noheji', 'Shichinohe', 'Rokunohe', 'Yokohama', 'Tohoku', 'Oirase', 'Oma', 'Sannohe', 'Gonohe', 'Takko', 'Nanbu', 'Hashikami', 'Shizukuishi', 'Kuzumaki', 'Iwate', 'Shiwa', 'Yahaba', 'Nishiwaga', 'Kanegasaki', 'Hiraizumi', 'Sumita', 'Otsuchi', 'Yamada', 'Iwaizumi', 'Karumai', 'Hirono', 'Ichinohe', 'Zao', 'Shichikashuku', 'Ogawara', 'Murata', 'Shibata', 'Kawasaki', 'Marumori', 'Watari', 'Yamamoto', 'Matsushima', 'Shichigahama', 'Rifu', 'Taiwa', 'Osato', 'Shikama', 'Kami', 'Wakuya', 'Misato', 'Onagawa', 'Minamisanriku', 'Kosaka', 'Fujisato', 'Mitane', 'Happo', 'Gojome', 'Hachirogata', 'Ikawa', 'Misato', 'Ugo', 'Yamanobe', 'Nakayama', 'Kahoku', 'Nishikawa', 'Asahi', 'Oe', 'Oishida', 'Kaneyama', 'Mogami', 'Funagata', 'Mamurogawa', 'Takahata', 'Kawanishi', 'Oguni', 'Shirataka', 'Iide', 'Mikawa', 'Shonai', 'Yuza', 'Koori', 'Kunimi', 'Kawamata', 'Kagamiishi', 'Shimogo', 'Tadami', 'Minamiaizu', 'Nishiaizu', 'Bandai', 'Inawashiro', 'Aizubange', 'Yanaizu', 'Mishima', 'Kaneyama', 'Aizumisato', 'Yabuki', 'Tanagura', 'Yamatsuri', 'Hanawa', 'Ishikawa', 'Asakawa', 'Furudono', 'Miharu', 'Ono', 'Hirono', 'Naraha', 'Tomioka', 'Okuma', 'Futaba', 'Namie', 'Shinchi', 'Ibaraki', 'Oarai', 'Shirosato', 'Daigo', 'Ami', 'Kawachi', 'Yachiyo', 'Goka', 'Sakai', 'Tone', 'Kaminokawa', 'Mashiko', 'Motegi', 'Ichikai', 'Haga', 'Mibu', 'Nogi', 'Shioya', 'Takanezawa', 'Nasu', 'Nakagawa', 'Yoshioka', 'Kanna', 'Shimonita', 'Kanra', 'Nakanojo', 'Naganohara', 'Kusatsu', 'Higashiagatsuma', 'Minakami', 'Tamamura', 'Itakura', 'Meiwa', 'Chiyoda', 'Oizumi', 'Ora', 'Ina', 'Miyoshi', 'Moroyama', 'Ogose', 'Namegawa', 'Ranzan', 'Ogawa', 'Kawajima', 'Yoshimi', 'Hatoyama', 'Tokigawa', 'Yokoze', 'Minano', 'Nagatoro', 'Ogano', 'Misato', 'Kamikawa', 'Kamisato', 'Yorii', 'Miyashiro', 'Sugito', 'Matsubushi', 'Shisui', 'Sakae', 'Kozaki', 'Tako', 'Tonosho', 'Kujukuri', 'Shibayama', 'Yokoshibahikari', 'Ichinomiya', 'Mutsuzawa', 'Shirako', 'Nagara', 'Chonan', 'Otaki', 'Onjuku', 'Kyonan', 'Mizuho', 'Hinode', 'Okutama', 'Oshima', 'Hachijo', 'Aikawa', 'Hayama', 'Samukawa', 'Oiso', 'Ninomiya', 'Nakai', 'Oi', 'Matsuda', 'Yamakita', 'Kaisei', 'Hakone', 'Manazuru', 'Yugawara', 'Seiro', 'Tagami', 'Aga', 'Izumozaki', 'Yuzawa', 'Tsunan', 'Kamiichi', 'Tateyama', 'Nyuzen', 'Asahi', 'Kawakita', 'Tsubata', 'Uchinada', 'Shika', 'Hodatsushimizu', 'Nakanoto', 'Anamizu', 'Noto', 'Eiheiji', 'Ikeda', 'Minamiechizen', 'Echizen', 'Mihama', 'Takahama', 'Oi', 'Wakasa', 'Ichikawamisato', 'Hayakawa', 'Minobu', 'Nanbu', 'Fujikawa', 'Showa', 'Nishikatsura', 'Fujikawaguchiko', 'Koumi', 'Sakuho', 'Karuizawa', 'Miyota', 'Tateshina', 'Nagawa', 'Shimosuwa', 'Fujimi', 'Tatsuno', 'Minowa', 'Iijima', 'Matsukawa', 'Takamori', 'Anan', 'Agematsu', 'Nagiso', 'Kiso', 'Ikeda', 'Sakaki', 'Obuse', 'Yamanouchi', 'Shinano', 'Iizuna', 'Ginan', 'Kasamatsu', 'Yoro', 'Tarui', 'Sekigahara', 'Godo', 'Wanouchi', 'Anpachi', 'Ibigawa', 'Ono', 'Ikeda', 'Kitagata', 'Sakahogi', 'Tomika', 'Kawabe', 'Hichiso', 'Yaotsu', 'Shirakawa', 'Mitake', 'Higashiizu', 'Kawazu', 'Minamiizu', 'Matsuzaki', 'Nishiizu', 'Kannami', 'Shimizu', 'Nagaizumi', 'Oyama', 'Yoshida', 'Kawanehon', 'Mori', 'Togo', 'Toyoyama', 'Oguchi', 'Fuso', 'Oharu', 'Kanie', 'Agui', 'Higashiura', 'Minamichita', 'Mihama', 'Taketoyo', 'Mihama', 'Kota', 'Shitara', 'Toei', 'Kisosaki', 'Toin', 'Komono', 'Asahi', 'Kawagoe', 'Taki', 'Meiwa', 'Odai', 'Tamaki', 'Watarai', 'Taiki', 'Minamiise', 'Kihoku', 'Mihama', 'Kiho', 'Hino', 'Ryuo', 'Aisho', 'Toyosato', 'Kora', 'Taga', 'Oyamazaki', 'Kumiyama', 'Ide', 'Ujitawara', 'Kasagi', 'Wazuka', 'Seika', 'Kyotamba', 'Ine', 'Yosano', 'Shimamoto', 'Toyono', 'Nose', 'Tadaoka', 'Kumatori', 'Tajiri', 'Misaki', 'Taishi', 'Kanan', 'Inagawa', 'Taka', 'Inami', 'Harima', 'Ichikawa', 'Fukusaki', 'Kamikawa', 'Taishi', 'Kamigori', 'Sayo', 'Kami', 'Shinonsen', 'Heguri', 'Sango', 'Ikaruga', 'Ando', 'Kawanishi', 'Miyake', 'Tawaramoto', 'Takatori', 'Kanmaki', 'Oji', 'Koryo', 'Kawai', 'Yoshino', 'Oyodo', 'Shimoichi', 'Kushimoto', 'Kimino', 'Katsuragi', 'Kudoyama', 'Koya', 'Yuasa', 'Hirogawa', 'Aridagawa', 'Mihama', 'Hidaka', 'Yura', 'Inami', 'Minabe', 'Hidakagawa', 'Shirahama', 'Kamitonda', 'Susami', 'Nachikatsuura', 'Taiji', 'Kozagawa', 'Iwami', 'Wakasa', 'Chizu', 'Yazu', 'Misasa', 'Yurihama', 'Kotoura', 'Hokuei', 'Daisen', 'Nanbu', 'Hoki', 'Nichinan', 'Hino', 'Kofu', 'Okuizumo', 'Iinan', 'Kawamoto', 'Misato', 'Onan', 'Tsuwano', 'Yoshika', 'Ama', 'Nishinoshima', 'Okinoshima', 'Wake', 'Hayashima', 'Satosho', 'Yakage', 'Kagamino', 'Shoo', 'Nagi', 'Kumenan', 'Misaki', 'Kibichuo', 'Fuchu', 'Kaita', 'Kumano', 'Saka', 'Kitahiroshima', 'Akiota', 'Osakikamijima', 'Sera', 'Jinsekikogen', 'Suooshima', 'Waki', 'Kaminoseki', 'Tabuse', 'Hirao', 'Abu', 'Katsuura', 'Kamikatsu', 'Ishii', 'Kamiyama', 'Naka', 'Mugi', 'Minami', 'Kaiyo', 'Matsushige', 'Kitajima', 'Aizumi', 'Itano', 'Kamiita', 'Tsurugi', 'Higashimiyoshi', 'Tonosho', 'Shodoshima', 'Miki', 'Naoshima', 'Utazu', 'Ayagawa', 'Kotohira', 'Tadotsu', 'Manno', 'Kamijima', 'Kumakogen', 'Masaki', 'Tobe', 'Uchiko', 'Ikata', 'Kihoku', 'Matsuno', 'Ainan', 'Toyo', 'Nahari', 'Tano', 'Yasuda', 'Motoyama', 'Otoyo', 'Tosa', 'Ino', 'Niyodogawa', 'Nakatosa', 'Sakawa', 'Ochi', 'Yusuhara', 'Tsuno', 'Shimanto', 'Otsuki', 'Kuroshio', 'Nakagawa', 'Umi', 'Sasaguri', 'Shime', 'Sue', 'Shingu', 'Hisayama', 'Kasuya', 'Ashiya', 'Mizumaki', 'Okagaki', 'Onga', 'Kotake', 'Kurate', 'Keisen', 'Chikuzen', 'Tachiarai', 'Oki', 'Hirokawa', 'Kawara', 'Soeda', 'Itoda', 'Kawasaki', 'Oto', 'Fukuchi', 'Kanda', 'Miyako', 'Yoshitomi', 'Koge', 'Chikujo', 'Yoshinogari', 'Kiyama', 'Kamimine', 'Miyaki', 'Genkai', 'Arita', 'Omachi', 'Kohoku', 'Shiroishi', 'Tara', 'Nagayo', 'Togitsu', 'Higashisonogi', 'Kawatana', 'Hasami', 'Ojika', 'Saza', 'Shinkamigoto', 'Misato', 'Gyokuto', 'Nankan', 'Nagasu', 'Nagomi', 'Ozu', 'Kikuyo', 'Minamioguni', 'Oguni', 'Takamori', 'Mifune', 'Kashima', 'Mashiki', 'Kosa', 'Yamato', 'Hikawa', 'Ashikita', 'Tsunagi', 'Nishiki', 'Taragi', 'Yunomae', 'Asagiri', 'Reihoku', 'Hiji', 'Kusu', 'Kokonoe', 'Mimata', 'Takaharu', 'Kunitomi', 'Aya', 'Takanabe', 'Shintomi', 'Kijo', 'Kawaminami', 'Tsuno', 'Kadogawa', 'Misato', 'Takachiho', 'Hinokage', 'Gokase', 'Satsuma', 'Nagashima', 'Yusui', 'Osaki', 'Higashikushira', 'Kinko', 'Minamiosumi', 'Kimotsuki', 'Nakatane', 'Minamitane', 'Yakushima', 'Setouchi', 'Tatsugo', 'Kikai', 'Tokunoshima', 'Amagi', 'Isen', 'Wadomari', 'China', 'Yoron', 'Motobu', 'Kin', 'Kadena', 'Chatan', 'Nishihara', 'Yonabaru', 'Haebaru', 'Kumejima', 'Yaese', 'Taketomi', 'Yonaguni']\n    ]\n  }\n\n  // randomize options if randomization is allowed in option\n  function randomizeOptions() {\n    const mod = _.round((graphWidth + graphHeight) / 1500, 2) // add mod for big screens\n    if (lockRegionsInput.getAttribute('data-locked') == 0) regionsInput.value =\n      regionsOutput.value = _.random(7, 17)\n    if (lockManorsInput.getAttribute('data-locked') == 0) {\n      const manors = regionsInput.value * 20 + _.random(180 * mod)\n      manorsInput.value = manorsOutput.innerHTML = manors\n    }\n    if (lockPowerInput.getAttribute('data-locked') == 0) powerInput.value =\n      powerOutput.value = _.random(2, 8)\n    if (lockNeutralInput.getAttribute('data-locked') == 0) neutralInput.value =\n      neutralOutput.value = _.random(100, 300)\n    if (lockNamesInput.getAttribute('data-locked') == 0) namesInput.value = _.random(0, 1)\n    if (lockCulturesInput.getAttribute('data-locked') == 0) culturesInput.value =\n      culturesOutput.value = _.random(5, 10)\n    if (lockPrecInput.getAttribute('data-locked') == 0) precInput.value =\n      precOutput.value = _.random(3, 12)\n    if (lockSwampinessInput.getAttribute('data-locked') == 0) swampinessInput.value =\n      swampinessOutput.value = _.random(100)\n  }\n\n  // Locate points to calculate Voronoi diagram\n  function placePoints() {\n    console.time('placePoints')\n    points = []\n    points = getJitteredGrid()\n    heights = new Uint8Array(points.length)\n    console.timeEnd('placePoints')\n  }\n\n  // Calculate Voronoi Diagram\n  function calculateVoronoi(points) {\n    console.time('calculateVoronoi')\n    diagram = voronoi(points)\n    // round edges to simplify future calculations\n    diagram.edges.forEach(function(e) {\n      e[0][0] = _.round(e[0][0], 2)\n      e[0][1] = _.round(e[0][1], 2)\n      e[1][0] = _.round(e[1][0], 2)\n      e[1][1] = _.round(e[1][1], 2)\n    })\n    polygons = diagram.polygons()\n    console.log(' cells: ' + points.length)\n    console.timeEnd('calculateVoronoi')\n  }\n\n  // move brush radius circle\n  function moveCircle(x, y, r, c) {\n    let circle = debug.selectAll('.circle')\n    if (!circle.size()) circle = debug.insert('circle', ':first-child').attr('class', 'circle')\n    circle.attr('cx', x).attr('cy', y)\n    if (r) circle.attr('r', r)\n    if (c) circle.attr('stroke', c)\n  }\n\n  // restore default drag (map panning) and cursor\n  function restoreDefaultEvents() {\n    viewbox.style('cursor', 'default').on('.drag', null).on('click', null)\n  }\n\n  // remove parent element (usually if child is clicked)\n  function removeParent() {\n    $(this.parentNode).remove()\n  }\n\n  // define selection based on radius\n  function defineBrushSelection(center, r) {\n    let radius = r\n    let selection = [center]\n    if (radius > 1) selection = selection.concat(cells[center].neighbors)\n    selection = $.grep(selection, function(e) {return cells[e].height >= 20})\n    if (radius === 2) return selection\n    let frontier = cells[center].neighbors\n    while (radius > 2) {\n      let cycle = frontier.slice()\n      frontier = []\n      cycle.map(function(s) {\n        cells[s].neighbors.forEach(function(e) {\n          if (selection.indexOf(e) !== -1) return\n          // if (cells[e].height < 20) return;\n          selection.push(e)\n          frontier.push(e)\n        })\n      })\n      radius--\n    }\n    selection = $.grep(selection, function(e) {return cells[e].height >= 20})\n    return selection\n  }\n\n  // Mouseclick events\n  function placeLinearFeature() {\n    const point = d3.mouse(this)\n    const index = getIndex(point)\n    let tag = debug.selectAll('.tag')\n    if (!tag.size()) {\n      tag = debug.append('circle').attr('data-cell', index).attr('class', 'tag')\n                 .attr('r', 3).attr('cx', point[0]).attr('cy', point[1])\n    } else {\n      const from = +tag.attr('data-cell')\n      debug.selectAll('.tag, .line').remove()\n      const power = +brushPower.value\n      const mod = $('#brushesButtons > .pressed').attr('id') === 'brushRange' ? 1 : -1\n      const selection = addRange(mod, power, from, index)\n      updateHeightmapSelection(selection)\n    }\n  }\n\n  // turn D3 polygons array into cell array, define neighbors for each cell\n  function detectNeighbors(withGrid) {\n    console.time('detectNeighbors')\n    let gridPath = '' // store grid as huge single path string\n    cells = []\n    polygons.map(function(i, d) {\n      const neighbors = []\n      let type // define cell type\n      if (withGrid) {gridPath += 'M' + i.join('L') + 'Z'} // grid path\n      diagram.cells[d].halfedges.forEach(function(e) {\n        const edge = diagram.edges[e]\n        if (edge.left && edge.right) {\n          const ea = edge.left.index === d ? edge.right.index : edge.left.index\n          neighbors.push(ea)\n        } else {\n          type = 'border' // polygon is on border if it has edge without opposite side polygon\n        }\n      })\n      cells.push({index: d, data: i.data, height: 0, type, neighbors})\n    })\n    if (withGrid) {grid.append('path').attr('d', round(gridPath, 1))}\n    console.timeEnd('detectNeighbors')\n  }\n\n  // Generate Heigtmap routine\n  function defineHeightmap() {\n    console.time('defineHeightmap')\n    if (lockTemplateInput.getAttribute('data-locked') == 0) {\n      const rnd = Math.random()\n      if (rnd > 0.95) {\n        templateInput.value = 'Volcano'\n      } else if (rnd > 0.75) {\n        templateInput.value = 'High Island'\n      } else if (rnd > 0.55) {\n        templateInput.value = 'Low Island'\n      } else if (rnd > 0.35) {\n        templateInput.value = 'Continents'\n      } else if (rnd > 0.15) {\n        templateInput.value = 'Archipelago'\n      } else if (rnd > 0.10) {\n        templateInput.value = 'Mainland'\n      } else if (rnd > 0.01) {templateInput.value = 'Peninsulas'} else {\n        templateInput.value = 'Atoll'\n      }\n    }\n    const mapTemplate = templateInput.value\n    if (mapTemplate === 'Volcano') templateVolcano()\n    if (mapTemplate === 'High Island') templateHighIsland()\n    if (mapTemplate === 'Low Island') templateLowIsland()\n    if (mapTemplate === 'Continents') templateContinents()\n    if (mapTemplate === 'Archipelago') templateArchipelago()\n    if (mapTemplate === 'Atoll') templateAtoll()\n    if (mapTemplate === 'Mainland') templateMainland()\n    if (mapTemplate === 'Peninsulas') templatePeninsulas()\n    console.log(' template: ' + mapTemplate)\n    console.timeEnd('defineHeightmap')\n  }\n\n  // Heighmap Template: Volcano\n  function templateVolcano(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(5, 0.35)\n    addRange(3)\n    addRange(-4)\n  }\n\n// Heighmap Template: High Island\n  function templateHighIsland(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addRange(6)\n    addHill(12, 0.25)\n    addRange(-3)\n    modifyHeights('land', 0, 0.75)\n    addPit(1)\n    addHill(3, 0.15)\n  }\n\n// Heighmap Template: Low Island\n  function templateLowIsland(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    smoothHeights(2)\n    addRange(2)\n    addHill(4, 0.4)\n    addHill(12, 0.2)\n    addRange(-8)\n    modifyHeights('land', 0, 0.35)\n  }\n\n  // Heighmap Template: Continents\n  function templateContinents(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(30, 0.25)\n    const count = Math.ceil(Math.random() * 4 + 4)\n    addStrait(count)\n    addPit(10)\n    addRange(-10)\n    modifyHeights('land', 0, 0.6)\n    smoothHeights(2)\n    addRange(3)\n  }\n\n  // Heighmap Template: Archipelago\n  function templateArchipelago(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(12, 0.15)\n    addRange(8)\n    const count = Math.ceil(Math.random() * 2 + 2)\n    addStrait(count)\n    addRange(-15)\n    addPit(10)\n    modifyHeights('land', -5, 0.7)\n    smoothHeights(3)\n  }\n\n  // Heighmap Template: Atoll\n  function templateAtoll(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(2, 0.35)\n    addRange(2)\n    smoothHeights(1)\n    modifyHeights('27-100', 0, 0.1)\n  }\n\n  // Heighmap Template: Mainland\n  function templateMainland(mod) {\n    addMountain()\n    modifyHeights('all', 10, 1)\n    addHill(30, 0.2)\n    addRange(10)\n    addPit(20)\n    addHill(10, 0.15)\n    addRange(-10)\n    modifyHeights('land', 0, 0.4)\n    addRange(10)\n    smoothHeights(3)\n  }\n\n  // Heighmap Template: Peninsulas\n  function templatePeninsulas(mod) {\n    addMountain()\n    modifyHeights('all', 15, 1)\n    addHill(30, 0)\n    addRange(5)\n    addPit(15)\n    const count = Math.ceil(Math.random() * 5 + 15)\n    addStrait(count)\n  }\n\n  function addMountain() {\n    const x = Math.floor(Math.random() * graphWidth / 3 + graphWidth / 3)\n    const y = Math.floor(Math.random() * graphHeight * 0.2 + graphHeight * 0.4)\n    const cell = diagram.find(x, y).index\n    const height = Math.random() * 10 + 90 // 90-99\n    add(cell, 'mountain', height)\n  }\n\n  // place with shift 0-0.5\n  function addHill(count, shift) {\n    for (let c = 0; c < count; c++) {\n      let limit = 0, cell, height\n      do {\n        height = Math.random() * 40 + 10 // 10-50\n        const x = Math.floor(Math.random() * graphWidth * (1 - shift * 2) + graphWidth * shift)\n        const y = Math.floor(Math.random() * graphHeight * (1 - shift * 2) + graphHeight * shift)\n        cell = diagram.find(x, y).index\n        limit++\n      } while (heights[cell] + height > 90 && limit < 100)\n      add(cell, 'hill', height)\n    }\n  }\n\n  function add(start, type, height) {\n    const session = Math.ceil(Math.random() * 1e5)\n    let radius\n    let hRadius\n    let mRadius\n    switch (+graphSize) {\n      case 1:\n        hRadius = 0.991\n        mRadius = 0.91\n        break\n      case 2:\n        hRadius = 0.9967\n        mRadius = 0.951\n        break\n      case 3:\n        hRadius = 0.999\n        mRadius = 0.975\n        break\n      case 4:\n        hRadius = 0.9994\n        mRadius = 0.98\n        break\n    }\n    radius = type === 'mountain' ? mRadius : hRadius\n    const queue = [start]\n    if (type === 'mountain') heights[start] = height\n    for (let i = 0; i < queue.length && height >= 1; i++) {\n      if (type === 'mountain') {\n        height = heights[queue[i]] * radius - height / 100\n      } else {height *= radius}\n      cells[queue[i]].neighbors.forEach(function(e) {\n        if (cells[e].used === session) return\n        const mod = Math.random() * 0.2 + 0.9 // 0.9-1.1 random factor\n        heights[e] += height * mod\n        if (heights[e] > 100) heights[e] = 100\n        cells[e].used = session\n        queue.push(e)\n      })\n    }\n  }\n\n  function addRange(mod, height, from, to) {\n    const session = Math.ceil(Math.random() * 100000)\n    const count = Math.abs(mod)\n    let range = []\n    for (let c = 0; c < count; c++) {\n      range = []\n      let diff = 0, start = from, end = to\n      if (!start || !end) {\n        do {\n          const xf = Math.floor(Math.random() * (graphWidth * 0.7)) + graphWidth * 0.15\n          const yf = Math.floor(Math.random() * (graphHeight * 0.6)) + graphHeight * 0.2\n          start = diagram.find(xf, yf).index\n          const xt = Math.floor(Math.random() * (graphWidth * 0.7)) + graphWidth * 0.15\n          const yt = Math.floor(Math.random() * (graphHeight * 0.6)) + graphHeight * 0.2\n          end = diagram.find(xt, yt).index\n          diff = Math.hypot(xt - xf, yt - yf)\n        } while (diff < 150 / graphSize || diff > 300 / graphSize)\n      }\n      if (start && end) {\n        for (let l = 0; start != end && l < 10000; l++) {\n          let min = 10000\n          cells[start].neighbors.forEach(function(e) {\n            diff = Math.hypot(cells[end].data[0] - cells[e].data[0],\n              cells[end].data[1] - cells[e].data[1])\n            if (Math.random() > 0.8) diff = diff / 2\n            if (diff < min) {min = diff, start = e}\n          })\n          range.push(start)\n        }\n      }\n      const change = height ? height : Math.random() * 10 + 10\n      range.map(function(r) {\n        let rnd = Math.random() * 0.4 + 0.8\n        if (mod > 0) heights[r] += change * rnd\n        else if (heights[r] >= 10) {heights[r] -= change * rnd}\n        cells[r].neighbors.forEach(function(e) {\n          if (cells[e].used === session) return\n          cells[e].used = session\n          rnd = Math.random() * 0.4 + 0.8\n          const ch = change / 2 * rnd\n          if (mod > 0) {heights[e] += ch} else if (heights[e] >= 10) {heights[e] -= ch}\n          if (heights[e] > 100) heights[e] = mod > 0 ? 100 : 5\n        })\n        if (heights[r] > 100) heights[r] = mod > 0 ? 100 : 5\n      })\n    }\n    return range\n  }\n\n  function addStrait(width) {\n    const session = Math.ceil(Math.random() * 100000)\n    const top = Math.floor(Math.random() * graphWidth * 0.35 + graphWidth * 0.3)\n    const bottom = Math.floor(\n      (graphWidth - top) - (graphWidth * 0.1) + (Math.random() * graphWidth * 0.2))\n    let start = diagram.find(top, graphHeight * 0.1).index\n    const end = diagram.find(bottom, graphHeight * 0.9).index\n    let range = []\n    for (let l = 0; start !== end && l < 1000; l++) {\n      let min = 10000 // dummy value\n      cells[start].neighbors.forEach(function(e) {\n        let diff = Math.hypot(cells[end].data[0] - cells[e].data[0],\n          cells[end].data[1] - cells[e].data[1])\n        if (Math.random() > 0.8) {diff = diff / 2}\n        if (diff < min) {\n          min = diff\n          start = e\n        }\n      })\n      range.push(start)\n    }\n    const query = []\n    for (; width > 0; width--) {\n      range.map(function(r) {\n        cells[r].neighbors.forEach(function(e) {\n          if (cells[e].used === session) {return}\n          cells[e].used = session\n          query.push(e)\n          heights[e] *= 0.23\n          if (heights[e] > 100 || heights[e] < 5) heights[e] = 5\n        })\n        range = query.slice()\n      })\n    }\n  }\n\n  function addPit(count, height, cell) {\n    const session = Math.ceil(Math.random() * 1e5)\n    for (let c = 0; c < count; c++) {\n      let change = height ? height + 10 : Math.random() * 10 + 20\n      let start = cell\n      if (!start) {\n        const lowlands = $.grep(cells, function(e) {return (heights[e.index] >= 20)})\n        if (!lowlands.length) return\n        const rnd = Math.floor(Math.random() * lowlands.length)\n        start = lowlands[rnd].index\n      }\n      let query = [start], newQuery = []\n      // depress pit center\n      heights[start] -= change\n      if (heights[start] < 5 || heights[start] > 100) heights[start] = 5\n      cells[start].used = session\n      for (let i = 1; i < 10000; i++) {\n        const rnd = Math.random() * 0.4 + 0.8\n        change -= i / 0.6 * rnd\n        if (change < 1) break\n        query.map(function(p) {\n          cells[p].neighbors.forEach(function(e) {\n            if (cells[e].used === session) return\n            cells[e].used = session\n            if (Math.random() > 0.8) return\n            newQuery.push(e)\n            heights[e] -= change\n            if (heights[e] < 5 || heights[e] > 100) heights[e] = 5\n          })\n        })\n        query = newQuery.slice()\n        newQuery = []\n      }\n    }\n  }\n\n  // Modify heights adding or multiplying by value\n  function modifyHeights(range, add, mult) {\n    function modify(v) {\n      if (add) v += add\n      if (mult !== 1) {\n        if (mult === '^2') mult = (v - 20) / 100\n        if (mult === '^3') mult = ((v - 20) * (v - 20)) / 100\n        if (range === 'land') {v = 20 + (v - 20) * mult} else {v *= mult}\n      }\n      if (v < 0) v = 0\n      if (v > 100) v = 100\n      return v\n    }\n\n    const limMin = range === 'land' ? 20 : range === 'all' ? 0 : +range.split('-')[0]\n    const limMax = range === 'land' || range === 'all' ? 100 : +range.split('-')[1]\n\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] < limMin || heights[i] > limMax) continue\n      heights[i] = modify(heights[i])\n    }\n  }\n\n  // Smooth heights using mean of neighbors\n  function smoothHeights(fraction) {\n    const fr = fraction || 2\n    for (let i = 0; i < heights.length; i++) {\n      const nHeights = [heights[i]]\n      cells[i].neighbors.forEach(function(e) {nHeights.push(heights[e])})\n      heights[i] = (heights[i] * (fr - 1) + d3.mean(nHeights)) / fr\n    }\n  }\n\n  // Randomize heights a bit\n  function disruptHeights() {\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] < 18) continue\n      if (Math.random() < 0.5) continue\n      heights[i] += 2 - Math.random() * 4\n    }\n  }\n\n  // Mark features (ocean, lakes, islands)\n  function markFeatures() {\n    console.time('markFeatures')\n    seedrandom(seed) // reset seed to get the same result on heightmap edit\n    for (let i = 0, queue = [0]; queue.length > 0; i++) {\n      const cell = cells[queue[0]]\n      cell.fn = i // feature number\n      const land = heights[queue[0]] >= 20\n      let border = cell.type === 'border'\n      if (border && land) cell.ctype = 2\n\n      while (queue.length) {\n        const q = queue.pop()\n        if (cells[q].type === 'border') {\n          border = true\n          if (land) cells[q].ctype = 2\n        }\n\n        cells[q].neighbors.forEach(function(e) {\n          const eLand = heights[e] >= 20\n          if (land === eLand && cells[e].fn === undefined) {\n            cells[e].fn = i\n            queue.push(e)\n          }\n          if (land && !eLand) {\n            cells[q].ctype = 2\n            cells[e].ctype = -1\n            cells[q].harbor = cells[q].harbor ? cells[q].harbor + 1 : 1\n          }\n        })\n      }\n      features.push({i, land, border})\n\n      // find unmarked cell\n      for (let c = 0; c < cells.length; c++) {\n        if (cells[c].fn === undefined) {\n          queue[0] = c\n          break\n        }\n      }\n    }\n    console.timeEnd('markFeatures')\n  }\n\n  function drawOcean() {\n    console.time('drawOcean')\n    let limits = []\n    let odd = 0.8 // initial odd for ocean layer is 80%\n    // Define type of ocean cells based on cell distance form land\n    let frontier = $.grep(cells, function(e) {return e.ctype === -1})\n    if (Math.random() < odd) {\n      limits.push(-1)\n      odd = 0.2\n    }\n    for (let c = -2; frontier.length > 0 && c > -10; c--) {\n      if (Math.random() < odd) {\n        limits.unshift(c)\n        odd = 0.2\n      } else {odd += 0.2}\n      frontier.map(function(i) {\n        i.neighbors.forEach(function(e) {\n          if (!cells[e].ctype) cells[e].ctype = c\n        })\n      })\n      frontier = $.grep(cells, function(e) {return e.ctype === c})\n    }\n    if (outlineLayersInput.value === 'none') return\n    if (outlineLayersInput.value !== 'random') limits = outlineLayersInput.value.split(',')\n    // Define area edges\n    const opacity = _.round(0.4 / limits.length, 2)\n    for (let l = 0; l < limits.length; l++) {\n      const edges = []\n      const lim = +limits[l]\n      for (let i = 0; i < cells.length; i++) {\n        if (cells[i].ctype < lim || cells[i].ctype === undefined) continue\n        if (cells[i].ctype > lim && cells[i].type !== 'border') continue\n        const cell = diagram.cells[i]\n        cell.halfedges.forEach(function(e) {\n          const edge = diagram.edges[e]\n          const start = edge[0].join(' ')\n          const end = edge[1].join(' ')\n          if (edge.left && edge.right) {\n            const ea = edge.left.index === i ? edge.right.index : edge.left.index\n            if (cells[ea].ctype < lim) edges.push({start, end})\n          } else {\n            edges.push({start, end})\n          }\n        })\n      }\n      lineGen.curve(d3.curveBasis)\n      let relax = 0.8 - l / 10\n      if (relax < 0.2) relax = 0.2\n      const line = getContinuousLine(edges, 0, relax)\n      oceanLayers.append('path').attr('d', line).attr('fill', '#ecf2f9')\n                 .style('opacity', opacity)\n    }\n    console.timeEnd('drawOcean')\n  }\n\n  // recalculate Voronoi Graph to pack cells\n  function reGraph() {\n    console.time('reGraph')\n    const tempCells = [], newPoints = [] // to store new data\n    // get average precipitation based on graph size\n    const avPrec = precInput.value / 5000\n    const smallLakesMax = 500\n    let smallLakes = 0\n    const evaporation = 2\n    cells.map(function(i, d) {\n      let height = i.height || heights[d]\n      if (height > 100) height = 100\n      const pit = i.pit\n      const ctype = i.ctype\n      if (ctype !== -1 && ctype !== -2 && height < 20) return // exclude all deep ocean points\n      const x = _.round(i.data[0], 1), y = _.round(i.data[1], 1)\n      const fn = i.fn\n      const harbor = i.harbor\n      let lake = i.lake\n      // mark potential cells for small lakes to add additional point there\n      if (smallLakes < smallLakesMax && !lake && pit > evaporation && ctype !== 2) {\n        lake = 2\n        smallLakes++\n      }\n      const region = i.region // handle value for edit heightmap mode only\n      const culture = i.culture // handle value for edit heightmap mode only\n      let copy = $.grep(newPoints, function(e) {return (e[0] == x && e[1] == y)})\n      if (!copy.length) {\n        newPoints.push([x, y])\n        tempCells.push({\n          index: tempCells.length,\n          data: [x, y],\n          height,\n          pit,\n          ctype,\n          fn,\n          harbor,\n          lake,\n          region,\n          culture\n        })\n      }\n      // add additional points for cells along coast\n      if (ctype === 2 || ctype === -1) {\n        if (i.type === 'border') return\n        if (!features[fn].land && !features[fn].border) return\n        i.neighbors.forEach(function(e) {\n          if (cells[e].ctype === ctype) {\n            let x1 = (x * 2 + cells[e].data[0]) / 3\n            let y1 = (y * 2 + cells[e].data[1]) / 3\n            x1 = _.round(x1, 1), y1 = _.round(y1, 1)\n            copy = $.grep(newPoints, function(e) {return e[0] === x1 && e[1] === y1})\n            if (copy.length) return\n            newPoints.push([x1, y1])\n            tempCells.push({\n              index: tempCells.length,\n              data: [x1, y1],\n              height,\n              pit,\n              ctype,\n              fn,\n              harbor,\n              lake,\n              region,\n              culture\n            })\n          }\n        })\n      }\n      if (lake === 2) { // add potential small lakes\n        polygons[i.index].forEach(function(e) {\n          if (Math.random() > 0.8) return\n          let rnd = Math.random() * 0.6 + 0.8\n          const x1 = _.round((e[0] * rnd + i.data[0]) / (1 + rnd), 2)\n          rnd = Math.random() * 0.6 + 0.8\n          const y1 = _.round((e[1] * rnd + i.data[1]) / (1 + rnd), 2)\n          copy = $.grep(newPoints, function(c) {return x1 === c[0] && y1 === c[1]})\n          if (copy.length) return\n          newPoints.push([x1, y1])\n          tempCells.push(\n            {index: tempCells.length, data: [x1, y1], height, pit, ctype, fn, region, culture})\n        })\n      }\n    })\n    console.log('small lakes candidates: ' + smallLakes)\n    cells = tempCells // use tempCells as the only cells array\n    calculateVoronoi(newPoints) // recalculate Voronoi diagram using new points\n    let gridPath = '' // store grid as huge single path string\n    cells.map(function(i, d) {\n      if (i.height >= 20) {\n        // calc cell area\n        i.area = _.round(Math.abs(d3.polygonArea(polygons[d])), 2)\n        const prec = _.round(avPrec * i.area, 2)\n        i.flux = i.lake ? prec * 10 : prec\n      }\n      const neighbors = [] // re-detect neighbors\n      diagram.cells[d].halfedges.forEach(function(e) {\n        const edge = diagram.edges[e]\n        if (edge.left === undefined || edge.right === undefined) {\n          if (i.height >= 20) i.ctype = 99 // border cell\n          return\n        }\n        const ea = edge.left.index === d ? edge.right.index : edge.left.index\n        neighbors.push(ea)\n        if (d < ea && i.height >= 20 && i.lake !== 1 && cells[ea].height >= 20 && cells[ea].lake !== 1) {\n          gridPath += 'M' + edge[0][0] + ',' + edge[0][1] + 'L' + edge[1][0] + ',' + edge[1][1]\n        }\n      })\n      i.neighbors = neighbors\n      if (i.region === undefined) delete i.region\n      if (i.culture === undefined) delete i.culture\n    })\n    grid.append('path').attr('d', gridPath)\n    console.timeEnd('reGraph')\n  }\n\n  // redraw all cells for Customization 1 mode\n  function mockHeightmap() {\n    let landCells = 0\n    $('#landmass').empty()\n    const limit = renderOcean.checked ? 1 : 20\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] < limit) continue\n      if (heights[i] > 100) heights[i] = 100\n      const clr = color(1 - heights[i] / 100)\n      landmass.append('path').attr('id', 'cell' + i)\n              .attr('d', 'M' + polygons[i].join('L') + 'Z')\n              .attr('fill', clr).attr('stroke', clr)\n    }\n  }\n\n  $('#renderOcean').click(mockHeightmap)\n\n  // draw or update all cells\n  function updateHeightmap() {\n    const limit = renderOcean.checked ? 1 : 20\n    for (let i = 0; i < heights.length; i++) {\n      if (heights[i] > 100) heights[i] = 100\n      let cell = landmass.select('#cell' + i)\n      const clr = color(1 - heights[i] / 100)\n      if (cell.size()) {\n        if (heights[i] < limit) {cell.remove()} else {\n          cell.attr('fill', clr).attr('stroke', clr)\n        }\n      } else if (heights[i] >= limit) {\n        cell = landmass.append('path').attr('id', 'cell' + i)\n                       .attr('d', 'M' + polygons[i].join('L') + 'Z')\n                       .attr('fill', clr).attr('stroke', clr)\n      }\n    }\n  }\n\n  // draw or update cells from the selection\n  function updateHeightmapSelection(selection) {\n    if (selection === undefined) return\n    const limit = renderOcean.checked ? 1 : 20\n    selection.map(function(s) {\n      if (heights[s] > 100) heights[s] = 100\n      let cell = landmass.select('#cell' + s)\n      const clr = color(1 - heights[s] / 100)\n      if (cell.size()) {\n        if (heights[s] < limit) {cell.remove()} else {\n          cell.attr('fill', clr).attr('stroke', clr)\n        }\n      } else if (heights[s] >= limit) {\n        cell = landmass.append('path').attr('id', 'cell' + s)\n                       .attr('d', 'M' + polygons[s].join('L') + 'Z')\n                       .attr('fill', clr).attr('stroke', clr)\n      }\n    })\n  }\n\n  function updateHistory() {\n    let landCells = 0 // count number of land cells\n    if (renderOcean.checked) {\n      landCells =\n        heights.reduce(function(s, v) {if (v >= 20) {return s + 1} else {return s}}, 0)\n    } else {\n      landCells = landmass.selectAll('*').size()\n    }\n    history = history.slice(0, historyStage)\n    history[historyStage] = heights.slice()\n    historyStage++\n    undo.disabled = templateUndo.disabled = historyStage <= 1\n    redo.disabled = templateRedo.disabled = true\n    const landMean = Math.trunc(d3.mean(heights))\n    const landRatio = _.round(landCells / heights.length * 100)\n    landmassCounter.innerHTML = landCells\n    landmassRatio.innerHTML = landRatio\n    landmassAverage.innerHTML = landMean\n    // if perspective view dialog is opened, update it\n    if ($('#perspectivePanel').is(':visible')) drawPerspective()\n  }\n\n  // restoreHistory\n  function restoreHistory(step) {\n    historyStage = step\n    redo.disabled = templateRedo.disabled = historyStage >= history.length\n    undo.disabled = templateUndo.disabled = historyStage <= 1\n    if (history[historyStage - 1] === undefined) return\n    heights = history[historyStage - 1].slice()\n    updateHeightmap()\n  }\n\n  // restart history from 1st step\n  function restartHistory() {\n    history = []\n    historyStage = 0\n    redo.disabled = templateRedo.disabled = true\n    undo.disabled = templateUndo.disabled = true\n    updateHistory()\n  }\n\n  // Detect and draw the coasline\n  function drawCoastline() {\n    console.time('drawCoastline')\n    seedrandom(seed) // reset seed to get the same result on heightmap edit\n    const shape = defs.append('mask').attr('id', 'shape').attr('fill', 'black').attr('x', 0)\n                      .attr('y', 0).attr('width', '100%').attr('height', '100%')\n    $('#landmass').empty()\n    let minX = graphWidth, maxX = 0 // extreme points\n    let minXedge, maxXedge // extreme edges\n    const oceanEdges = [], lakeEdges = []\n    for (let i = 0; i < land.length; i++) {\n      const id = land[i].index, cell = diagram.cells[id]\n      const f = land[i].fn\n      land[i].height = Math.trunc(land[i].height)\n      if (!oceanEdges[f]) {\n        oceanEdges[f] = []\n        lakeEdges[f] = []\n      }\n      cell.halfedges.forEach(function(e) {\n        const edge = diagram.edges[e]\n        const start = edge[0].join(' ')\n        const end = edge[1].join(' ')\n        if (edge.left && edge.right) {\n          const ea = edge.left.index === id ? edge.right.index : edge.left.index\n          cells[ea].height = Math.trunc(cells[ea].height)\n          if (cells[ea].height < 20) {\n            cells[ea].ctype = -1\n            if (land[i].ctype !== 1) {\n              land[i].ctype = 1 // mark coastal land cells\n              // move cell point closer to coast\n              const x = (land[i].data[0] + cells[ea].data[0]) / 2\n              const y = (land[i].data[1] + cells[ea].data[1]) / 2\n              land[i].haven = ea // harbor haven (oposite water cell)\n              land[i].coastX = _.round(x + (land[i].data[0] - x) * 0.1, 1)\n              land[i].coastY = _.round(y + (land[i].data[1] - y) * 0.1, 1)\n              land[i].data[0] = _.round(x + (land[i].data[0] - x) * 0.5, 1)\n              land[i].data[1] = _.round(y + (land[i].data[1] - y) * 0.5, 1)\n            }\n            if (features[cells[ea].fn].border) {\n              oceanEdges[f].push({start, end})\n              // island extreme points\n              if (edge[0][0] < minX) {\n                minX = edge[0][0]\n                minXedge = edge[0]\n              }\n              if (edge[1][0] < minX) {\n                minX = edge[1][0]\n                minXedge = edge[1]\n              }\n              if (edge[0][0] > maxX) {\n                maxX = edge[0][0]\n                maxXedge = edge[0]\n              }\n              if (edge[1][0] > maxX) {\n                maxX = edge[1][0]\n                maxXedge = edge[1]\n              }\n            } else {\n              const l = cells[ea].fn\n              if (!lakeEdges[f][l]) lakeEdges[f][l] = []\n              lakeEdges[f][l].push({start, end})\n            }\n          }\n        } else {\n          oceanEdges[f].push({start, end})\n        }\n      })\n    }\n\n    for (let f = 0; f < features.length; f++) {\n      if (!oceanEdges[f]) continue\n      if (!oceanEdges[f].length && lakeEdges[f].length) {\n        const m = lakeEdges[f].indexOf(d3.max(lakeEdges[f]))\n        oceanEdges[f] = lakeEdges[f][m]\n        lakeEdges[f][m] = []\n      }\n      lineGen.curve(d3.curveCatmullRomClosed.alpha(0.1))\n      const oceanCoastline = getContinuousLine(oceanEdges[f], 3, 0)\n      if (oceanCoastline) {\n        shape.append('path').attr('d', oceanCoastline).attr('fill', 'white') // draw the mask\n        coastline.append('path').attr('d', oceanCoastline) // draw the coastline\n      }\n      lineGen.curve(d3.curveBasisClosed)\n      lakeEdges[f].forEach(function(l) {\n        const lakeCoastline = getContinuousLine(l, 3, 0)\n        if (lakeCoastline) {\n          shape.append('path').attr('d', lakeCoastline).attr('fill', 'black') // draw the mask\n          lakes.append('path').attr('d', lakeCoastline) // draw the lakes\n        }\n      })\n    }\n    landmass.append('rect').attr('x', 0).attr('y', 0).attr('width', graphWidth)\n            .attr('height', graphHeight) // draw the landmass\n    drawDefaultRuler(minXedge, maxXedge)\n    console.timeEnd('drawCoastline')\n  }\n\n  // draw default scale bar\n  function drawScaleBar() {\n    if ($('#scaleBar').hasClass('hidden')) return // no need to re-draw hidden element\n    svg.select('#scaleBar').remove() // fully redraw every time\n    // get size\n    const size = +barSize.value\n    const dScale = distanceScale.value\n    const unit = distanceUnit.value\n    const scaleBar = svg.append('g').attr('id', 'scaleBar')\n                        .on('click', editScale)\n                        .on('mousemove', function() {\n                          tip('Click to open Scale Editor, drag to move')\n                        })\n                        .call(d3.drag().on('start', elementDrag))\n    const init = 100 // actual length in pixels if scale, dScale and size = 1;\n    let val = init * size * dScale / scale // bar length in distance unit\n    if (val > 900) {val = _.round(val, -3)} // round to 1000\n    else if (val > 90) {val = _.round(val, -2)} // round to 100\n    else if (val > 9) {val = _.round(val, -1)} // round to 10\n    else {val = Math.round(val)} // round to 1\n    const l = val * scale / dScale // actual length in pixels on this scale\n    const x = 0, y = 0 // initial position\n    scaleBar.append('line').attr('x1', x + 0.5).attr('y1', y).attr('x2', x + l + size - 0.5)\n            .attr('y2', y).attr('stroke-width', size).attr('stroke', 'white')\n    scaleBar.append('line').attr('x1', x).attr('y1', y + size).attr('x2', x + l + size)\n            .attr('y2', y + size).attr('stroke-width', size).attr('stroke', '#3d3d3d')\n    const dash = size + ' ' + _.round(l / 5 - size, 2)\n    scaleBar.append('line').attr('x1', x).attr('y1', y).attr('x2', x + l + size).attr('y2', y)\n            .attr('stroke-width', _.round(size * 3, 2)).attr('stroke-dasharray', dash)\n            .attr('stroke', '#3d3d3d')\n    // big scale\n    for (let b = 0; b < 6; b++) {\n      const value = _.round(b * l / 5, 2)\n      const label = _.round(value * dScale / scale)\n      if (b === 5) {\n        scaleBar.append('text').attr('x', x + value).attr('y', y - 2 * size)\n                .attr('font-size', _.round(5 * size, 1)).text(label + ' ' + unit)\n      } else {\n        scaleBar.append('text').attr('x', x + value).attr('y', y - 2 * size)\n                .attr('font-size', _.round(5 * size, 1)).text(label)\n      }\n    }\n    if (barLabel.value !== '') {\n      scaleBar.append('text').attr('x', x + (l + 1) / 2).attr('y', y + 2 * size)\n              .attr('dominant-baseline', 'text-before-edge')\n              .attr('font-size', _.round(5 * size, 1)).text(barLabel.value)\n    }\n    const bbox = scaleBar.node().getBBox()\n    // append backbround rectangle\n    scaleBar.insert('rect', ':first-child').attr('x', -10).attr('y', -20)\n            .attr('width', bbox.width + 10).attr('height', bbox.height + 15)\n            .attr('stroke-width', size).attr('stroke', 'none').attr('filter', 'url(#blur5)')\n            .attr('fill', barBackColor.value).attr('opacity', +barBackOpacity.value)\n    fitScaleBar()\n  }\n\n  // draw default ruler measiring land x-axis edges\n  function drawDefaultRuler(minXedge, maxXedge) {\n    const rulerNew = ruler.append('g').attr('class', 'linear')\n                          .call(d3.drag().on('start', elementDrag))\n    if (!minXedge) minXedge = [0, 0]\n    if (!maxXedge) maxXedge = [svgWidth, svgHeight]\n    const x1 = _.round(minXedge[0], 2), y1 = _.round(minXedge[1], 2), x2 = _.round(maxXedge[0], 2),\n      y2 = _.round(maxXedge[1], 2)\n    rulerNew.append('line').attr('x1', x1).attr('y1', y1).attr('x2', x2).attr('y2', y2)\n            .attr('class', 'white')\n    rulerNew.append('line').attr('x1', x1).attr('y1', y1).attr('x2', x2).attr('y2', y2)\n            .attr('class', 'gray').attr('stroke-dasharray', 10)\n    rulerNew.append('circle').attr('r', 2).attr('cx', x1).attr('cy', y1).attr('stroke-width', 0.5)\n            .attr('data-edge', 'left').call(d3.drag().on('drag', rulerEdgeDrag))\n    rulerNew.append('circle').attr('r', 2).attr('cx', x2).attr('cy', y2).attr('stroke-width', 0.5)\n            .attr('data-edge', 'rigth').call(d3.drag().on('drag', rulerEdgeDrag))\n    const x0 = _.round((x1 + x2) / 2, 2)\n    const y0 = _.round((y1 + y2) / 2, 2)\n    rulerNew.append('circle').attr('r', 1.2).attr('cx', x0).attr('cy', y0)\n            .attr('stroke-width', 0.3).attr('class', 'center')\n            .call(d3.drag().on('start', rulerCenterDrag))\n    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI\n    const tr = 'rotate(' + angle + ' ' + x0 + ' ' + y0 + ')'\n    const dist = Math.round(Math.hypot(x1 - x2, y1 - y2))\n    const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n    rulerNew.append('text').attr('x', x0).attr('y', y0).attr('dy', -1).attr('transform', tr)\n            .attr('data-dist', dist).text(label).on('click', removeParent).attr('font-size', 10)\n  }\n\n  // drag any element changing transform\n  function elementDrag() {\n    const el = d3.select(this)\n    const tr = parseTransform(el.attr('transform'))\n    const dx = +tr[0] - d3.event.x\n    const dy = +tr[1] - d3.event.y\n\n    d3.event.on('drag', function() {\n      const x = d3.event.x\n      const y = d3.event.y\n      const transform = `translate(${(dx + x)},${(dy + y)}) rotate(${tr[2]} ${tr[3]} ${tr[4]})`\n      el.attr('transform', transform)\n      const pp = this.parentNode.parentNode.id\n      if (pp === 'burgIcons' || pp === 'burgLabels') {\n        tip('Use dragging for fine-tuning only, to move burg to a different cell use \"Relocate\" button')\n      }\n      if (pp === 'labels') {\n        // also transform curve control circle\n        debug.select('circle').attr('transform', transform)\n      }\n    })\n\n    d3.event.on('end', function() {\n      // remember scaleBar bottom-right position\n      if (el.attr('id') === 'scaleBar') {\n        const xEnd = d3.event.x, yEnd = d3.event.y\n        const diff = Math.abs(dx - xEnd) + Math.abs(dy - yEnd)\n        if (diff > 5) {\n          const bbox = el.node().getBoundingClientRect()\n          sessionStorage.setItem('scaleBar', [bbox.right, bbox.bottom])\n        }\n      }\n    })\n  }\n\n  // draw ruler circles and update label\n  function rulerEdgeDrag() {\n    const group = d3.select(this.parentNode)\n    const edge = d3.select(this).attr('data-edge')\n    const x = d3.event.x, y = d3.event.y\n    let x0, y0\n    d3.select(this).attr('cx', x).attr('cy', y)\n    const line = group.selectAll('line')\n    if (edge === 'left') {\n      line.attr('x1', x).attr('y1', y)\n      x0 = +line.attr('x2')\n      y0 = +line.attr('y2')\n    } else {\n      line.attr('x2', x).attr('y2', y)\n      x0 = +line.attr('x1')\n      y0 = +line.attr('y1')\n    }\n    const xc = _.round((x + x0) / 2, 2)\n    const yc = _.round((y + y0) / 2, 2)\n    group.select('.center').attr('cx', xc).attr('cy', yc)\n    const dist = Math.round(Math.hypot(x0 - x, y0 - y))\n    const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n    const atan = x0 > x ? Math.atan2(y0 - y, x0 - x) : Math.atan2(y - y0, x - x0)\n    const angle = _.round(atan * 180 / Math.PI, 3)\n    const tr = 'rotate(' + angle + ' ' + xc + ' ' + yc + ')'\n    group.select('text').attr('x', xc).attr('y', yc).attr('transform', tr).attr('data-dist', dist)\n         .text(label)\n  }\n\n  // draw ruler center point to split ruler into 2 parts\n  function rulerCenterDrag() {\n    let xc1, yc1, xc2, yc2\n    const group = d3.select(this.parentNode) // current ruler group\n    let x = d3.event.x, y = d3.event.y // current coords\n    const line = group.selectAll('line') // current lines\n    const x1 = +line.attr('x1'), y1 = +line.attr('y1'), x2 = +line.attr('x2'),\n      y2 = +line.attr('y2') // initial line edge points\n    const rulerNew = ruler.insert('g', ':first-child')\n    rulerNew.attr('transform', group.attr('transform')).call(d3.drag().on('start', elementDrag))\n    const factor = _.round(1 / Math.pow(scale, 0.3), 1)\n    rulerNew.append('line').attr('class', 'white').attr('stroke-width', factor)\n    const dash = +group.select('.gray').attr('stroke-dasharray')\n    rulerNew.append('line').attr('class', 'gray').attr('stroke-dasharray', dash)\n            .attr('stroke-width', factor)\n    rulerNew.append('text').attr('dy', -1).on('click', removeParent)\n            .attr('font-size', 10 * factor).attr('stroke-width', factor)\n\n    d3.event.on('drag', function() {\n      x = d3.event.x, y = d3.event.y\n      d3.select(this).attr('cx', x).attr('cy', y)\n      // change first part\n      line.attr('x1', x1).attr('y1', y1).attr('x2', x).attr('y2', y)\n      let dist = Math.round(Math.hypot(x1 - x, y1 - y))\n      let label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      let atan = x1 > x ? Math.atan2(y1 - y, x1 - x) : Math.atan2(y - y1, x - x1)\n      xc1 = _.round((x + x1) / 2, 2)\n      yc1 = _.round((y + y1) / 2, 2)\n      let tr = 'rotate(' + _.round(atan * 180 / Math.PI, 3) + ' ' + xc1 + ' ' + yc1 + ')'\n      group.select('text').attr('x', xc1).attr('y', yc1).attr('transform', tr)\n           .attr('data-dist', dist).text(label)\n      // change second (new) part\n      dist = Math.round(Math.hypot(x2 - x, y2 - y))\n      label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      atan = x2 > x ? Math.atan2(y2 - y, x2 - x) : Math.atan2(y - y2, x - x2)\n      xc2 = _.round((x + x2) / 2, 2)\n      yc2 = _.round((y + y2) / 2, 2)\n      tr = 'rotate(' + _.round(atan * 180 / Math.PI, 3) + ' ' + xc2 + ' ' + yc2 + ')'\n      rulerNew.selectAll('line').attr('x1', x).attr('y1', y).attr('x2', x2).attr('y2', y2)\n      rulerNew.select('text').attr('x', xc2).attr('y', yc2).attr('transform', tr)\n              .attr('data-dist', dist).text(label)\n    })\n\n    d3.event.on('end', function() {\n      // circles for 1st part\n      group.selectAll('circle').remove()\n      group.append('circle').attr('cx', x1).attr('cy', y1).attr('r', 2 * factor)\n           .attr('stroke-width', 0.5 * factor).attr('data-edge', 'left')\n           .call(d3.drag().on('drag', rulerEdgeDrag))\n      group.append('circle').attr('cx', x).attr('cy', y).attr('r', 2 * factor)\n           .attr('stroke-width', 0.5 * factor).attr('data-edge', 'rigth')\n           .call(d3.drag().on('drag', rulerEdgeDrag))\n      group.append('circle').attr('cx', xc1).attr('cy', yc1).attr('r', 1.2 * factor)\n           .attr('stroke-width', 0.3 * factor).attr('class', 'center')\n           .call(d3.drag().on('start', rulerCenterDrag))\n      // circles for 2nd part\n      rulerNew.append('circle').attr('cx', x).attr('cy', y).attr('r', 2 * factor)\n              .attr('stroke-width', 0.5 * factor).attr('data-edge', 'left')\n              .call(d3.drag().on('drag', rulerEdgeDrag))\n      rulerNew.append('circle').attr('cx', x2).attr('cy', y2).attr('r', 2 * factor)\n              .attr('stroke-width', 0.5 * factor).attr('data-edge', 'rigth')\n              .call(d3.drag().on('drag', rulerEdgeDrag))\n      rulerNew.append('circle').attr('cx', xc2).attr('cy', yc2).attr('r', 1.2 * factor)\n              .attr('stroke-width', 0.3 * factor).attr('class', 'center')\n              .call(d3.drag().on('start', rulerCenterDrag))\n    })\n  }\n\n  function opisometerEdgeDrag() {\n    const el = d3.select(this)\n    const x0 = +el.attr('cx'), y0 = +el.attr('cy')\n    const group = d3.select(this.parentNode)\n    const curve = group.select('.white')\n    const curveGray = group.select('.gray')\n    const text = group.select('text')\n    const points = JSON.parse(text.attr('data-points'))\n    if (x0 === points[0].scX && y0 === points[0].scY) {points.reverse()}\n\n    d3.event.on('drag', function() {\n      const x = d3.event.x, y = d3.event.y\n      el.attr('cx', x).attr('cy', y)\n      const l = points[points.length - 1]\n      const diff = Math.hypot(l.scX - x, l.scY - y)\n      if (diff > 5) {points.push({scX: x, scY: y})} else {return}\n      lineGen.curve(d3.curveBasis)\n      const d = round(lineGen(points))\n      curve.attr('d', d)\n      curveGray.attr('d', d)\n      const dist = Math.round(curve.node().getTotalLength())\n      const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      text.attr('x', x).attr('y', y).text(label)\n    })\n\n    d3.event.on('end', function() {\n      const dist = Math.round(curve.node().getTotalLength())\n      const c = curve.node().getPointAtLength(dist / 2)\n      const p = curve.node().getPointAtLength((dist / 2) - 1)\n      const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      const atan = p.x > c.x ? Math.atan2(p.y - c.y, p.x - c.x) :\n                   Math.atan2(c.y - p.y, c.x - p.x)\n      const angle = Math.round(atan * 180 / Math.PI, 3)\n      const tr = 'rotate(' + angle + ' ' + c.x + ' ' + c.y + ')'\n      text.attr('data-points', JSON.stringify(points)).attr('data-dist', dist).attr('x', c.x)\n          .attr('y', c.y).attr('transform', tr).text(label)\n    })\n  }\n\n  function getContinuousLine(edges, indention, relax) {\n    let line = ''\n    if (edges.length < 3) return ''\n    while (edges.length > 2) {\n      let edgesOrdered = [] // to store points in a correct order\n      let start = edges[0].start\n      let end = edges[0].end\n      edges.shift()\n      let spl = start.split(' ')\n      edgesOrdered.push({scX: +spl[0], scY: +spl[1]})\n      spl = end.split(' ')\n      edgesOrdered.push({scX: +spl[0], scY: +spl[1]})\n      let x0 = +spl[0], y0 = +spl[1]\n      for (let i = 0; end !== start && i < 100000; i++) {\n        let next = null, index = null\n        for (let e = 0; e < edges.length; e++) {\n          const edge = edges[e]\n          if (edge.start == end || edge.end == end) {\n            next = edge\n            end = next.start == end ? next.end : next.start\n            index = e\n            break\n          }\n        }\n        if (!next) {\n          console.error('Next edge is not found')\n          return ''\n        }\n        spl = end.split(' ')\n        if (indention || relax) {\n          const dist = Math.hypot(+spl[0] - x0, +spl[1] - y0)\n          if (dist >= indention && Math.random() > relax) {\n            edgesOrdered.push({scX: +spl[0], scY: +spl[1]})\n            x0 = +spl[0], y0 = +spl[1]\n          }\n        } else {\n          edgesOrdered.push({scX: +spl[0], scY: +spl[1]})\n        }\n        edges.splice(index, 1)\n        if (i === 100000 - 1) {\n          console.error('Line not ended, limit reached')\n          break\n        }\n      }\n      line += lineGen(edgesOrdered)\n    }\n    return round(line, 1)\n  }\n\n  // temporary elevate lakes to min neighbors heights to correctly flux the water\n  function elevateLakes() {\n    console.time('elevateLakes')\n    const lakes = $.grep(cells,\n      function(e, d) {return heights[d] < 20 && !features[e.fn].border})\n    lakes.sort(function(a, b) {return heights[b.index] - heights[a.index]})\n    for (let i = 0; i < lakes.length; i++) {\n      const hs = [], id = lakes[i].index\n      cells[id].height = heights[id] // use height on object level\n      lakes[i].neighbors.forEach(function(n) {\n        const nHeight = cells[n].height || heights[n]\n        if (nHeight >= 20) hs.push(nHeight)\n      })\n      if (hs.length) cells[id].height = d3.min(hs) - 1\n      if (cells[id].height < 20) cells[id].height = 20\n      lakes[i].lake = 1\n    }\n    console.timeEnd('elevateLakes')\n  }\n\n  // Depression filling algorithm (for a correct water flux modeling; phase1)\n  function resolveDepressionsPrimary() {\n    console.time('resolveDepressionsPrimary')\n    land = $.grep(cells, function(e, d) {\n      if (!e.height) e.height = heights[d] // use height on object level\n      return e.height >= 20\n    })\n    land.sort(function(a, b) {return b.height - a.height})\n    const limit = 10\n    for (let l = 0, depression = 1; depression > 0 && l < limit; l++) {\n      depression = 0\n      for (let i = 0; i < land.length; i++) {\n        const id = land[i].index\n        if (land[i].type === 'border') continue\n        const hs = land[i].neighbors.map(function(n) {return cells[n].height})\n        const minHigh = d3.min(hs)\n        if (cells[id].height <= minHigh) {\n          depression++\n          land[i].pit = land[i].pit ? land[i].pit + 1 : 1\n          cells[id].height = minHigh + 2\n        }\n      }\n      if (l === 0) console.log(' depressions init: ' + depression)\n    }\n    console.timeEnd('resolveDepressionsPrimary')\n  }\n\n  // Depression filling algorithm (for a correct water flux modeling; phase2)\n  function resolveDepressionsSecondary() {\n    console.time('resolveDepressionsSecondary')\n    land = $.grep(cells, function(e) {return e.height >= 20})\n    land.sort(function(a, b) {return b.height - a.height})\n    const limit = 100\n    for (let l = 0, depression = 1; depression > 0 && l < limit; l++) {\n      depression = 0\n      for (let i = 0; i < land.length; i++) {\n        if (land[i].ctype === 99) continue\n        const nHeights = land[i].neighbors.map(function(n) {return cells[n].height})\n        const minHigh = d3.min(nHeights)\n        if (land[i].height <= minHigh) {\n          depression++\n          land[i].pit = land[i].pit ? land[i].pit + 1 : 1\n          land[i].height = Math.trunc(minHigh + 2)\n        }\n      }\n      if (l === 0) console.log(' depressions reGraphed: ' + depression)\n      if (l === limit - 1) console.error('Error: resolveDepressions iteration limit')\n    }\n    console.timeEnd('resolveDepressionsSecondary')\n  }\n\n  // restore initial heights if user don't want system to change heightmap\n  function restoreCustomHeights() {\n    land.forEach(function(l) {\n      if (!l.pit) return\n      l.height = Math.trunc(l.height - l.pit * 2)\n      if (l.height < 20) l.height = 20\n    })\n  }\n\n  function flux() {\n    console.time('flux')\n    riversData = []\n    let riverNext = 0\n    land.sort(function(a, b) {return b.height - a.height})\n    for (let i = 0; i < land.length; i++) {\n      const id = land[i].index\n      const sx = land[i].data[0]\n      const sy = land[i].data[1]\n      let fn = land[i].fn\n      if (land[i].ctype === 99) {\n        if (land[i].river !== undefined) {\n          let x, y\n          const min = Math.min(sy, graphHeight - sy, sx, graphWidth - sx)\n          if (min === sy) {\n            x = sx\n            y = 0\n          }\n          if (min === graphHeight - sy) {\n            x = sx\n            y = graphHeight\n          }\n          if (min === sx) {\n            x = 0\n            y = sy\n          }\n          if (min === graphWidth - sx) {\n            x = graphWidth\n            y = sy\n          }\n          riversData.push({river: land[i].river, cell: id, x, y})\n        }\n        continue\n      }\n      if (features[fn].river !== undefined) {\n        if (land[i].river !== features[fn].river) {\n          land[i].river = undefined\n          land[i].flux = 0\n        }\n      }\n      let minHeight = 1000, min\n      land[i].neighbors.forEach(function(e) {\n        if (cells[e].height < minHeight) {\n          minHeight = cells[e].height\n          min = e\n        }\n      })\n      // Define river number\n      if (min !== undefined && land[i].flux > 1) {\n        if (land[i].river === undefined) {\n          // State new River\n          land[i].river = riverNext\n          riversData.push({river: riverNext, cell: id, x: sx, y: sy})\n          riverNext += 1\n        }\n        // Assing existing River to the downhill cell\n        if (cells[min].river == undefined) {\n          cells[min].river = land[i].river\n        } else {\n          const riverTo = cells[min].river\n          const iRiver = $.grep(riversData, function(e) {\n            return (e.river == land[i].river)\n          })\n          const minRiver = $.grep(riversData, function(e) {\n            return (e.river == riverTo)\n          })\n          let iRiverL = iRiver.length\n          let minRiverL = minRiver.length\n          // re-assing river nunber if new part is greater\n          if (iRiverL >= minRiverL) {\n            cells[min].river = land[i].river\n            iRiverL += 1\n            minRiverL -= 1\n          }\n          // mark confluences\n          if (cells[min].height >= 20 && iRiverL > 1 && minRiverL > 1) {\n            if (!cells[min].confluence) {\n              cells[min].confluence = minRiverL - 1\n            } else {\n              cells[min].confluence += minRiverL - 1\n            }\n          }\n        }\n      }\n      if (cells[min].flux) cells[min].flux += land[i].flux\n      if (land[i].river !== undefined) {\n        const px = cells[min].data[0]\n        const py = cells[min].data[1]\n        if (cells[min].height < 20) {\n          // pour water to the sea\n          const x = (px + sx) / 2 + (px - sx) / 10\n          const y = (py + sy) / 2 + (py - sy) / 10\n          riversData.push({river: land[i].river, cell: id, x, y})\n        } else {\n          if (cells[min].lake === 1) {\n            fn = cells[min].fn\n            if (features[fn].river === undefined) features[fn].river = land[i].river\n          }\n          // add next River segment\n          riversData.push({river: land[i].river, cell: min, x: px, y: py})\n        }\n      }\n    }\n    console.timeEnd('flux')\n    drawRiverLines(riverNext)\n  }\n\n  function drawRiverLines(riverNext) {\n    console.time('drawRiverLines')\n    for (let i = 0; i < riverNext; i++) {\n      const dataRiver = $.grep(riversData, function(e) {\n        return e.river === i\n      })\n      if (dataRiver.length > 1) {\n        const riverAmended = amendRiver(dataRiver, 1)\n        const width = _.round(0.8 + Math.random() * 0.4, 1)\n        const increment = _.round(0.8 + Math.random() * 0.4, 1)\n        const d = drawRiver(riverAmended, width, increment)\n        rivers.append('path').attr('d', d).attr('id', 'river' + i).attr('data-width', width)\n              .attr('data-increment', increment)\n      }\n    }\n    rivers.selectAll('path').on('click', editRiver)\n    console.timeEnd('drawRiverLines')\n  }\n\n  // add more river points on 1/3 and 2/3 of length\n  function amendRiver(dataRiver, rndFactor) {\n    const riverAmended = []\n    let side = 1\n    for (let r = 0; r < dataRiver.length; r++) {\n      const dX = dataRiver[r].x\n      const dY = dataRiver[r].y\n      const cell = dataRiver[r].cell\n      const c = cells[cell].confluence || 0\n      riverAmended.push([dX, dY, c])\n      if (r + 1 < dataRiver.length) {\n        const eX = dataRiver[r + 1].x\n        const eY = dataRiver[r + 1].y\n        const angle = Math.atan2(eY - dY, eX - dX)\n        const serpentine = 1 / (r + 1)\n        const meandr = serpentine + 0.3 + Math.random() * 0.3 * rndFactor\n        if (Math.random() > 0.5) {\n          side *= -1\n        }\n        const dist = Math.hypot(eX - dX, eY - dY)\n        // if dist is big or river is small add 2 extra points\n        if (dist > 8 || (dist > 4 && dataRiver.length < 6)) {\n          let stX = (dX * 2 + eX) / 3\n          let stY = (dY * 2 + eY) / 3\n          let enX = (dX + eX * 2) / 3\n          let enY = (dY + eY * 2) / 3\n          stX += -Math.sin(angle) * meandr * side\n          stY += Math.cos(angle) * meandr * side\n          if (Math.random() > 0.8) {\n            side *= -1\n          }\n          enX += Math.sin(angle) * meandr * side\n          enY += -Math.cos(angle) * meandr * side\n          riverAmended.push([stX, stY], [enX, enY])\n          // if dist is medium or river is small add 1 extra point\n        } else if (dist > 4 || dataRiver.length < 6) {\n          let scX = (dX + eX) / 2\n          let scY = (dY + eY) / 2\n          scX += -Math.sin(angle) * meandr * side\n          scY += Math.cos(angle) * meandr * side\n          riverAmended.push([scX, scY])\n        }\n      }\n    }\n    return riverAmended\n  }\n\n  // draw river polygon using arrpoximation\n  function drawRiver(points, width, increment) {\n    lineGen.curve(d3.curveCatmullRom.alpha(0.1))\n    let extraOffset = 0.03 // start offset to make river source visible\n    width = width || 1 // river width modifier\n    increment = increment || 1 // river bed widening modifier\n    let riverLength = 0\n    points.map(function(p, i) {\n      if (i === 0) {return 0}\n      riverLength += Math.hypot(p[0] - points[i - 1][0], p[1] - points[i - 1][1])\n    })\n    const widening = Math.round((1000 + (riverLength * 30)) * increment)\n    const riverPointsLeft = [], riverPointsRight = []\n    const last = points.length - 1\n    const factor = riverLength / points.length\n\n    // first point\n    let x = points[0][0], y = points[0][1], c\n    let angle = Math.atan2(y - points[1][1], x - points[1][0])\n    let xLeft = x + -Math.sin(angle) * extraOffset, yLeft = y + Math.cos(angle) * extraOffset\n    riverPointsLeft.push({scX: xLeft, scY: yLeft})\n    let xRight = x + Math.sin(angle) * extraOffset, yRight = y + -Math.cos(angle) * extraOffset\n    riverPointsRight.unshift({scX: xRight, scY: yRight})\n\n    // middle points\n    for (let p = 1; p < last; p++) {\n      x = points[p][0], y = points[p][1], c = points[p][2]\n      if (c) {extraOffset += Math.atan(c * 10 / widening)} // confluence\n      const xPrev = points[p - 1][0], yPrev = points[p - 1][1]\n      const xNext = points[p + 1][0], yNext = points[p + 1][1]\n      angle = Math.atan2(yPrev - yNext, xPrev - xNext)\n      var offset = (Math.atan(Math.pow(p * factor, 2) / widening) / 2 * width) + extraOffset\n      xLeft = x + -Math.sin(angle) * offset, yLeft = y + Math.cos(angle) * offset\n      riverPointsLeft.push({scX: xLeft, scY: yLeft})\n      xRight = x + Math.sin(angle) * offset, yRight = y + -Math.cos(angle) * offset\n      riverPointsRight.unshift({scX: xRight, scY: yRight})\n    }\n\n    // end point\n    x = points[last][0], y = points[last][1], c = points[last][2]\n    if (c) {extraOffset += Math.atan(c * 10 / widening)} // confluence\n    angle = Math.atan2(points[last - 1][1] - y, points[last - 1][0] - x)\n    xLeft = x + -Math.sin(angle) * offset, yLeft = y + Math.cos(angle) * offset\n    riverPointsLeft.push({scX: xLeft, scY: yLeft})\n    xRight = x + Math.sin(angle) * offset, yRight = y + -Math.cos(angle) * offset\n    riverPointsRight.unshift({scX: xRight, scY: yRight})\n\n    // generate path and return\n    const right = lineGen(riverPointsRight)\n    let left = lineGen(riverPointsLeft)\n    left = left.substring(left.indexOf('C'))\n    return round(right + left, 2)\n  }\n\n  // draw river polygon with best quality\n  function drawRiverSlow(points, width, increment) {\n    lineGen.curve(d3.curveCatmullRom.alpha(0.1))\n    width = width || 1\n    const extraOffset = 0.02 * width\n    increment = increment || 1\n    const riverPoints = points.map(function(p) {\n      return {scX: p[0], scY: p[1]}\n    })\n    const river = defs.append('path').attr('d', lineGen(riverPoints))\n    const riverLength = river.node().getTotalLength()\n    const widening = Math.round((1000 + (riverLength * 30)) * increment)\n    const riverPointsLeft = [], riverPointsRight = []\n\n    for (let l = 0; l < riverLength; l++) {\n      var point = river.node().getPointAtLength(l)\n      var from = river.node().getPointAtLength(l - 0.1)\n      const to = river.node().getPointAtLength(l + 0.1)\n      var angle = Math.atan2(from.y - to.y, from.x - to.x)\n      var offset = (Math.atan(Math.pow(l, 2) / widening) / 2 * width) + extraOffset\n      var xLeft = point.x + -Math.sin(angle) * offset\n      var yLeft = point.y + Math.cos(angle) * offset\n      riverPointsLeft.push({scX: xLeft, scY: yLeft})\n      var xRight = point.x + Math.sin(angle) * offset\n      var yRight = point.y + -Math.cos(angle) * offset\n      riverPointsRight.unshift({scX: xRight, scY: yRight})\n    }\n\n    var point = river.node().getPointAtLength(riverLength)\n    var from = river.node().getPointAtLength(riverLength - 0.1)\n    var angle = Math.atan2(from.y - point.y, from.x - point.x)\n    var offset = (Math.atan(Math.pow(riverLength, 2) / widening) / 2 * width) + extraOffset\n    var xLeft = point.x + -Math.sin(angle) * offset\n    var yLeft = point.y + Math.cos(angle) * offset\n    riverPointsLeft.push({scX: xLeft, scY: yLeft})\n    var xRight = point.x + Math.sin(angle) * offset\n    var yRight = point.y + -Math.cos(angle) * offset\n    riverPointsRight.unshift({scX: xRight, scY: yRight})\n\n    river.remove()\n    // generate path and return\n    const right = lineGen(riverPointsRight)\n    let left = lineGen(riverPointsLeft)\n    left = left.substring(left.indexOf('C'))\n    return round(right + left, 2)\n  }\n\n  // add lakes on depressed points on river course\n  function addLakes() {\n    console.time('addLakes')\n    let smallLakes = 0\n    for (let i = 0; i < land.length; i++) {\n      // elavate all big lakes\n      if (land[i].lake === 1) {\n        land[i].height = 19\n        land[i].ctype = -1\n      }\n      // define eligible small lakes\n      if (land[i].lake === 2 && smallLakes < 100) {\n        if (land[i].river !== undefined) {\n          land[i].height = 19\n          land[i].ctype = -1\n          land[i].fn = -1\n          smallLakes++\n        } else {\n          land[i].lake = undefined\n          land[i].neighbors.forEach(function(n) {\n            if (cells[n].lake !== 1 && cells[n].river !== undefined) {\n              cells[n].lake = 2\n              cells[n].height = 19\n              cells[n].ctype = -1\n              cells[n].fn = -1\n              smallLakes++\n            } else if (cells[n].lake === 2) {\n              cells[n].lake = undefined\n            }\n          })\n        }\n      }\n    }\n    console.log('small lakes: ' + smallLakes)\n\n    // mark small lakes\n    let unmarked = $.grep(land, function(e) {return e.fn === -1})\n    while (unmarked.length) {\n      let fn = -1, queue = [unmarked[0].index], lakeCells = []\n      unmarked[0].session = 'addLakes'\n      while (queue.length) {\n        const q = queue.pop()\n        lakeCells.push(q)\n        if (cells[q].fn !== -1) fn = cells[q].fn\n        cells[q].neighbors.forEach(function(e) {\n          if (cells[e].lake && cells[e].session !== 'addLakes') {\n            cells[e].session = 'addLakes'\n            queue.push(e)\n          }\n        })\n      }\n      if (fn === -1) {\n        fn = features.length\n        features.push({i: fn, land: false, border: false})\n      }\n      lakeCells.forEach(function(c) {cells[c].fn = fn})\n      unmarked = $.grep(land, function(e) {return e.fn === -1})\n    }\n\n    land = $.grep(cells, function(e) {return e.height >= 20})\n    console.timeEnd('addLakes')\n  }\n\n  function editLabel() {\n    if (customization) return\n\n    unselect()\n    closeDialogs('#labelEditor, .stable')\n    elSelected =\n      d3.select(this).call(d3.drag().on('start', elementDrag)).classed('draggable', true)\n\n    // update group parameters\n    let group = d3.select(this.parentNode)\n    updateGroupOptions()\n    labelGroupSelect.value = group.attr('id')\n    labelFontSelect.value = FONTS.indexOf(group.attr('data-font'))\n    labelSize.value = group.attr('data-size')\n    labelColor.value = toHEX(group.attr('fill'))\n    labelOpacity.value = group.attr('opacity')\n    labelText.value = elSelected.text()\n    const tr = parseTransform(elSelected.attr('transform'))\n    labelAngle.value = tr[2]\n    labelAngleValue.innerHTML = Math.abs(+tr[2]) + '°'\n\n    $('#labelEditor').dialog({\n      title: 'Edit Label: ' + labelText.value,\n      minHeight: 30, width: 'auto', maxWidth: 275, resizable: false,\n      position: {my: 'center top+10', at: 'bottom', of: this},\n      close: unselect\n    })\n\n    if (modules.editLabel) return\n    modules.editLabel = true\n\n    loadDefaultFonts()\n\n    function updateGroupOptions() {\n      labelGroupSelect.innerHTML = ''\n      labels.selectAll('g:not(#burgLabels)').each(function(d) {\n        if (this.parentNode.id === 'burgLabels') return\n        let id = d3.select(this).attr('id')\n        let opt = document.createElement('option')\n        opt.value = opt.innerHTML = id\n        labelGroupSelect.add(opt)\n      })\n    }\n\n    $('#labelGroupButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelGroupButtons').toggle()\n    })\n\n    // on group change\n    document.getElementById('labelGroupSelect').addEventListener('change', function() {\n      document.getElementById(this.value).appendChild(elSelected.remove().node())\n    })\n\n    // toggle inputs to declare a new group\n    document.getElementById('labelGroupNew').addEventListener('click', function() {\n      if ($('#labelGroupInput').css('display') === 'none') {\n        $('#labelGroupInput').css('display', 'inline-block')\n        $('#labelGroupSelect').css('display', 'none')\n        labelGroupInput.focus()\n      } else {\n        $('#labelGroupSelect').css('display', 'inline-block')\n        $('#labelGroupInput').css('display', 'none')\n      }\n    })\n\n    // toggle inputs to select a group\n    document.getElementById('labelExternalFont').addEventListener('click', function() {\n      if ($('#labelFontInput').css('display') === 'none') {\n        $('#labelFontInput').css('display', 'inline-block')\n        $('#labelFontSelect').css('display', 'none')\n        labelFontInput.focus()\n      } else {\n        $('#labelFontSelect').css('display', 'inline-block')\n        $('#labelFontInput').css('display', 'none')\n      }\n    })\n\n    // on new group creation\n    document.getElementById('labelGroupInput').addEventListener('change', function() {\n      if (!this.value) {\n        tip('Please provide a valid group name')\n        return\n      }\n      let group = this.value.toLowerCase().replace(/ /g, '_').replace(/[^\\w\\s]/gi, '')\n      if (Number.isFinite(+group.charAt(0))) group = 'g' + group\n      // if el with this id exists, add size to id\n      while (labels.selectAll('#' + group).size()) {group += '_new'}\n      createNewLabelGroup(group)\n    })\n\n    function createNewLabelGroup(g) {\n      let group = elSelected.node().parentNode.cloneNode(false)\n      let groupNew = labels.append(f => group).attr('id', g)\n      groupNew.append(f => elSelected.remove().node())\n      updateGroupOptions()\n      $('#labelGroupSelect, #labelGroupInput').toggle()\n      labelGroupInput.value = ''\n      labelGroupSelect.value = g\n      updateLabelGroups()\n    }\n\n    // remove label group on click\n    document.getElementById('labelGroupRemove').addEventListener('click', function() {\n      let group = d3.select(elSelected.node().parentNode)\n      let id = group.attr('id')\n      let count = group.selectAll('text').size()\n      // remove group with < 2 label without ask\n      if (count < 2) {\n        removeAllLabelsInGroup(id)\n        $('#labelEditor').dialog('close')\n        return\n      }\n      alertMessage.innerHTML =\n        'Are you sure you want to remove all labels (' + count + ') of that group?'\n      $('#alert').dialog({\n        resizable: false, title: 'Remove label group',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            removeAllLabelsInGroup(id)\n            $('#labelEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    $('#labelTextButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelTextButtons').toggle()\n    })\n\n    // on label text change\n    document.getElementById('labelText').addEventListener('input', function() {\n      if (!this.value) {\n        tip(\n          'Name should not be blank, set opacity to 0 to hide label or click remove button to delete')\n        return\n      }\n      // change Label text\n      if (elSelected.select('textPath').size()) elSelected.select('textPath').text(this.value)\n      else elSelected.text(this.value)\n      $('div[aria-describedby=\\'labelEditor\\'] .ui-dialog-title').text('Edit Label: ' + this.value)\n      // check if label is a country name\n      let id = elSelected.attr('id') || ''\n      if (id.includes('regionLabel')) {\n        let state = +elSelected.attr('id').slice(11)\n        states[state].name = this.value\n      }\n    })\n\n    // generate a random country name\n    document.getElementById('labelTextRandom').addEventListener('click', function() {\n      let name = elSelected.text()\n      let id = elSelected.attr('id') || ''\n      if (id.includes('regionLabel')) {\n        // label is a country name\n        let state = +elSelected.attr('id').slice(11)\n        name = generateStateName(state.i)\n        states[state].name = name\n      } else {\n        // label is not a country name, use random culture\n        let c = elSelected.node().getBBox()\n        let closest = cultureTree.find((c.x + c.width / 2), (c.y + c.height / 2))\n        let culture = Math.floor(Math.random() * cultures.length)\n        name = generateName(culture)\n      }\n      labelText.value = name\n      $('div[aria-describedby=\\'labelEditor\\'] .ui-dialog-title').text('Edit Label: ' + name)\n      // change Label text\n      if (elSelected.select('textPath').size()) elSelected.select('textPath').text(name)\n      else elSelected.text(name)\n    })\n\n    $('#labelFontButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelFontButtons').toggle()\n    })\n\n    // on label font change\n    document.getElementById('labelFontSelect').addEventListener('change', function() {\n      let group = elSelected.node().parentNode\n      let font = FONTS[this.value].split(':')[0].replace(/\\+/g, ' ')\n      group.setAttribute('font-family', font)\n      group.setAttribute('data-font', FONTS[this.value])\n    })\n\n    // on adding custom font\n    document.getElementById('labelFontInput').addEventListener('change', function() {\n      fetchFonts(this.value).then(fetched => {\n        if (!fetched) return\n        labelExternalFont.click()\n        labelFontInput.value = ''\n        if (fetched === 1) $('#labelFontSelect').val(FONTS.length - 1).change()\n      })\n    })\n\n    // on label size input\n    document.getElementById('labelSize').addEventListener('input', function() {\n      let group = elSelected.node().parentNode\n      let size = +this.value\n      group.setAttribute('data-size', size)\n      group.setAttribute('font-size', _.round((size + (size / scale)) / 2, 2))\n    })\n\n    $('#labelStyleButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelStyleButtons').toggle()\n    })\n\n    // on label fill color input\n    document.getElementById('labelColor').addEventListener('input', function() {\n      let group = elSelected.node().parentNode\n      group.setAttribute('fill', this.value)\n    })\n\n    // on label opacity input\n    document.getElementById('labelOpacity').addEventListener('input', function() {\n      let group = elSelected.node().parentNode\n      group.setAttribute('opacity', this.value)\n    })\n\n    $('#labelAngleButton').click(function() {\n      $('#labelEditor > button').not(this).toggle()\n      $('#labelAngleButtons').toggle()\n    })\n\n    // on label angle input\n    document.getElementById('labelAngle').addEventListener('input', function() {\n      const tr = parseTransform(elSelected.attr('transform'))\n      labelAngleValue.innerHTML = Math.abs(+this.value) + '°'\n      const c = elSelected.node().getBBox()\n      const angle = +this.value\n      const transform = `translate(${tr[0]},${tr[1]}) rotate(${angle} ${(c.x + c.width / 2)} ${(c.y + c.height / 2)})`\n      elSelected.attr('transform', transform)\n    })\n\n    // display control points to curve label (place on path)\n    document.getElementById('labelCurve').addEventListener('click', function() {\n      let c = elSelected.node().getBBox()\n      let cx = c.x + c.width / 2, cy = c.y + c.height / 2\n\n      if (!elSelected.select('textPath').size()) {\n        let id = elSelected.attr('id')\n        let pathId = '#textPath_' + id\n        let path = `M${cx - c.width},${cy} q${c.width},0 ${c.width * 2},0`\n        let text = elSelected.text(), x = elSelected.attr('x'), y = elSelected.attr('y')\n        elSelected.text(null).attr('data-x', x).attr('data-y', y).attr('x', null).attr('y', null)\n        defs.append('path').attr('id', 'textPath_' + id).attr('d', path)\n        elSelected.append('textPath').attr('href', pathId).attr('startOffset', '50%').text(text)\n      }\n\n      if (!debug.select('circle').size()) {\n        debug.append('circle').attr('id', 'textPathControl').attr('r', 1.6)\n             .attr('cx', cx).attr('cy', cy)\n             .attr('transform', elSelected.attr('transform') || null)\n             .call(d3.drag().on('start', textPathControlDrag))\n      }\n    })\n\n    // drag textPath controle point to curve the label\n    function textPathControlDrag() {\n      let textPath = defs.select('#textPath_' + elSelected.attr('id'))\n      let path = textPath.attr('d').split(' ')\n      let M = path[0].split(',')\n      let q = path[1].split(',') // +q[1] to get qy - the only changeble value\n      let y = d3.event.y\n\n      d3.event.on('drag', function() {\n        let dy = d3.event.y - y\n        let total = +q[1] + dy * 8\n        d3.select(this).attr('cy', d3.event.y)\n        textPath.attr('d', `${M[0]},${+M[1] - dy} ${q[0]},${total} ${path[2]}`)\n      })\n    }\n\n    // cancel label curvature\n    document.getElementById('labelCurveCancel').addEventListener('click', function() {\n      if (!elSelected.select('textPath').size()) return\n      let text = elSelected.text(), x = elSelected.attr('data-x'), y = elSelected.attr('data-y')\n      elSelected.text()\n      elSelected.attr('x', x).attr('y', y).attr('data-x', null).attr('data-y', null).text(text)\n      defs.select('#textPath_' + elSelected.attr('id')).remove()\n      debug.select('circle').remove()\n    })\n\n    // open legendsEditor\n    document.getElementById('labelLegend').addEventListener('click', function() {\n      let id = elSelected.attr('id')\n      let name = elSelected.text()\n      editLegends(id, name)\n    })\n\n    // copy label on click\n    document.getElementById('labelCopy').addEventListener('click', function() {\n      let group = d3.select(elSelected.node().parentNode)\n      copy = group.append(f => elSelected.node().cloneNode(true))\n      let id = 'label' + Date.now().toString().slice(7)\n      copy.attr('id', id).attr('class', null).on('click', editLabel)\n      let shift = +group.attr('font-size') + 1\n      if (copy.select('textPath').size()) {\n        let path = defs.select('#textPath_' + elSelected.attr('id')).attr('d')\n        let textPath = defs.append('path').attr('id', 'textPath_' + id)\n        copy.select('textPath').attr('href', '#textPath_' + id)\n        let pathArray = path.split(' ')\n        let x = +pathArray[0].split(',')[0].slice(1)\n        let y = +pathArray[0].split(',')[1]\n        textPath.attr('d', `M${x - shift},${y - shift} ${pathArray[1]} ${pathArray[2]}`)\n        shift\n      } else {\n        let x = +elSelected.attr('x') - shift\n        let y = +elSelected.attr('y') - shift\n        while (group.selectAll('text[x=\\'' + x + '\\']').size()) {\n          x -= shift\n          y -= shift\n        }\n        copy.attr('x', x).attr('y', y)\n      }\n    })\n\n    // remove label on click\n    document.getElementById('labelRemoveSingle').addEventListener('click', function() {\n      alertMessage.innerHTML = 'Are you sure you want to remove the label?'\n      $('#alert').dialog({\n        resizable: false, title: 'Remove label',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            defs.select('#textPath_' + elSelected.attr('id')).remove()\n            $('#labelEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editRiver() {\n    if (customization) return\n    if (elSelected) {\n      const self = d3.select(this).attr('id') === elSelected.attr('id')\n      const point = d3.mouse(this)\n      if (elSelected.attr('data-river') === 'new') {\n        addRiverPoint([point[0], point[1]])\n        completeNewRiver()\n        return\n      } else if (self) {\n        riverAddControlPoint(point)\n        return\n      }\n    }\n\n    unselect()\n    closeDialogs('#riverEditor, .stable')\n    elSelected = d3.select(this)\n    elSelected.call(d3.drag().on('start', riverDrag))\n\n    const tr = parseTransform(elSelected.attr('transform'))\n    riverAngle.value = tr[2]\n    riverAngleValue.innerHTML = Math.abs(+tr[2]) + '°'\n    riverScale.value = tr[5]\n    riverWidthInput.value = +elSelected.attr('data-width')\n    riverIncrement.value = +elSelected.attr('data-increment')\n\n    $('#riverEditor').dialog({\n      title: 'Edit River',\n      minHeight: 30, width: 'auto', resizable: false,\n      position: {my: 'center top+20', at: 'top', of: d3.event},\n      close: function() {\n        if ($('#riverNew').hasClass('pressed')) completeNewRiver()\n        unselect()\n      }\n    })\n\n    if (!debug.select('.controlPoints').size()) debug.append('g').attr('class', 'controlPoints')\n    riverDrawPoints()\n\n    if (modules.editRiver) {return}\n    modules.editRiver = true\n\n    function riverAddControlPoint(point) {\n      let dists = []\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const x = +d3.select(this).attr('cx')\n        const y = +d3.select(this).attr('cy')\n        dists.push(Math.hypot(point[0] - x, point[1] - y))\n      })\n      let index = dists.length\n      if (dists.length > 1) {\n        const sorted = dists.slice(0).sort(function(a, b) {return a - b})\n        const closest = dists.indexOf(sorted[0])\n        const next = dists.indexOf(sorted[1])\n        if (closest <= next) {index = closest + 1} else {index = next + 1}\n      }\n      const before = ':nth-child(' + (index + 1) + ')'\n      debug.select('.controlPoints').insert('circle', before)\n           .attr('cx', point[0]).attr('cy', point[1]).attr('r', 0.35)\n           .call(d3.drag().on('drag', riverPointDrag))\n           .on('click', function(d) {\n             $(this).remove()\n             redrawRiver()\n           })\n      redrawRiver()\n    }\n\n    function riverDrawPoints() {\n      const node = elSelected.node()\n      // river is a polygon, so divide length by 2 to get course length\n      const l = node.getTotalLength() / 2\n      const parts = (l / 5) >> 0 // number of points\n      let inc = l / parts // increment\n      if (inc === Infinity) {inc = l} // 2 control points for short rivers\n      // draw control points\n      for (let i = l, c = l; i > 0; i -= inc, c += inc) {\n        const p1 = node.getPointAtLength(i)\n        const p2 = node.getPointAtLength(c)\n        const p = [(p1.x + p2.x) / 2, (p1.y + p2.y) / 2]\n        addRiverPoint(p)\n      }\n      // last point should be accurate\n      const lp1 = node.getPointAtLength(0)\n      const lp2 = node.getPointAtLength(l * 2)\n      const p = [(lp1.x + lp2.x) / 2, (lp1.y + lp2.y) / 2]\n      addRiverPoint(p)\n    }\n\n    function addRiverPoint(point) {\n      debug.select('.controlPoints').append('circle')\n           .attr('cx', point[0]).attr('cy', point[1]).attr('r', 0.35)\n           .call(d3.drag().on('drag', riverPointDrag))\n           .on('click', function(d) {\n             $(this).remove()\n             redrawRiver()\n           })\n    }\n\n    function riverPointDrag() {\n      d3.select(this).attr('cx', d3.event.x).attr('cy', d3.event.y)\n      redrawRiver()\n    }\n\n    function riverDrag() {\n      const x = d3.event.x, y = d3.event.y\n      const tr = parseTransform(elSelected.attr('transform'))\n      d3.event.on('drag', function() {\n        let xc = d3.event.x, yc = d3.event.y\n        let transform = `translate(${(+tr[0] + xc - x)},${(+tr[1] + yc - y)}) rotate(${tr[2]} ${tr[3]} ${tr[4]}) scale(${tr[5]})`\n        elSelected.attr('transform', transform)\n        debug.select('.controlPoints').attr('transform', transform)\n      })\n    }\n\n    function redrawRiver() {\n      let points = []\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const el = d3.select(this)\n        points.push([+el.attr('cx'), +el.attr('cy')])\n      })\n      const width = +riverWidthInput.value\n      const increment = +riverIncrement.value\n      const d = drawRiverSlow(points, width, increment)\n      elSelected.attr('d', d)\n    }\n\n    $('#riverWidthInput, #riverIncrement').change(function() {\n      const width = +riverWidthInput.value\n      const increment = +riverIncrement.value\n      elSelected.attr('data-width', width).attr('data-increment', increment)\n      redrawRiver()\n    })\n\n    $('#riverRegenerate').click(function() {\n      let points = [], amended = [], x, y, p1, p2\n      const node = elSelected.node()\n      const l = node.getTotalLength() / 2\n      const parts = (l / 8) >> 0 // number of points\n      let inc = l / parts // increment\n      if (inc === Infinity) {inc = l} // 2 control points for short rivers\n      for (let i = l, e = l; i > 0; i -= inc, e += inc) {\n        p1 = node.getPointAtLength(i)\n        p2 = node.getPointAtLength(e)\n        x = (p1.x + p2.x) / 2, y = (p1.y + p2.y) / 2\n        points.push([x, y])\n      }\n      // last point should be accurate\n      p1 = node.getPointAtLength(0)\n      p2 = node.getPointAtLength(l * 2)\n      x = (p1.x + p2.x) / 2, y = (p1.y + p2.y) / 2\n      points.push([x, y])\n      // amend points\n      const rndFactor = 0.3 + Math.random() * 1.4 // random factor in range 0.2-1.8\n      for (let i = 0; i < points.length; i++) {\n        x = points[i][0], y = points[i][1]\n        amended.push([x, y])\n        // add additional semi-random point\n        if (i + 1 < points.length) {\n          const x2 = points[i + 1][0], y2 = points[i + 1][1]\n          let side = Math.random() > 0.5 ? 1 : -1\n          const angle = Math.atan2(y2 - y, x2 - x)\n          const serpentine = 2 / (i + 1)\n          const meandr = serpentine + 0.3 + Math.random() * rndFactor\n          x = (x + x2) / 2, y = (y + y2) / 2\n          x += -Math.sin(angle) * meandr * side\n          y += Math.cos(angle) * meandr * side\n          amended.push([x, y])\n        }\n      }\n      const width = +riverWidthInput.value * 0.6 + Math.random()\n      const increment = +riverIncrement.value * 0.9 + Math.random() * 0.2\n      riverWidthInput.value = width\n      riverIncrement.value = increment\n      elSelected.attr('data-width', width).attr('data-increment', increment)\n      const d = drawRiverSlow(amended, width, increment)\n      elSelected.attr('d', d).attr('data-width', width).attr('data-increment', increment)\n      debug.select('.controlPoints').selectAll('*').remove()\n      amended.map(function(p) {addRiverPoint(p)})\n    })\n\n    $('#riverAngle').on('input', function() {\n      const tr = parseTransform(elSelected.attr('transform'))\n      riverAngleValue.innerHTML = Math.abs(+this.value) + '°'\n      const c = elSelected.node().getBBox()\n      const angle = +this.value, scale = +tr[5]\n      const transform = `translate(${tr[0]},${tr[1]}) rotate(${angle} ${(c.x + c.width / 2) * scale} ${(c.y + c.height / 2) * scale}) scale(${scale})`\n      elSelected.attr('transform', transform)\n      debug.select('.controlPoints').attr('transform', transform)\n    })\n\n    $('#riverReset').click(function() {\n      elSelected.attr('transform', '')\n      debug.select('.controlPoints').attr('transform', '')\n      riverAngle.value = 0\n      riverAngleValue.innerHTML = '0°'\n      riverScale.value = 1\n    })\n\n    $('#riverScale').change(function() {\n      const tr = parseTransform(elSelected.attr('transform'))\n      const scaleOld = +tr[5], scale = +this.value\n      const c = elSelected.node().getBBox()\n      const cx = c.x + c.width / 2, cy = c.y + c.height / 2\n      const trX = +tr[0] + cx * (scaleOld - scale)\n      const trY = +tr[1] + cy * (scaleOld - scale)\n      const scX = +tr[3] * scale / scaleOld\n      const scY = +tr[4] * scale / scaleOld\n      const transform = `translate(${trX},${trY}) rotate(${tr[2]} ${scX} ${scY}) scale(${scale})`\n      elSelected.attr('transform', transform)\n      debug.select('.controlPoints').attr('transform', transform)\n    })\n\n    $('#riverNew').click(function() {\n      if ($(this).hasClass('pressed')) {\n        completeNewRiver()\n      } else {\n        // enter creation mode\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        if (elSelected) elSelected.call(d3.drag().on('drag', null))\n        debug.select('.controlPoints').selectAll('*').remove()\n        viewbox.style('cursor', 'crosshair').on('click', newRiverAddPoint)\n      }\n    })\n\n    function newRiverAddPoint() {\n      const point = d3.mouse(this)\n      addRiverPoint([point[0], point[1]])\n      if (!elSelected || elSelected.attr('data-river') !== 'new') {\n        const id = +$('#rivers > path').last().attr('id').slice(5) + 1\n        elSelected = rivers.append('path').attr('data-river', 'new').attr('id', 'river' + id)\n                           .attr('data-width', 2).attr('data-increment', 1)\n                           .on('click', completeNewRiver)\n      } else {\n        redrawRiver()\n        let cell = diagram.find(point[0], point[1]).index\n        let f = cells[cell].fn\n        let ocean = !features[f].land && features[f].border\n        if (ocean && debug.select('.controlPoints').selectAll('circle')\n                          .size() > 5) completeNewRiver()\n      }\n    }\n\n    function completeNewRiver() {\n      $('#riverNew').removeClass('pressed')\n      restoreDefaultEvents()\n      if (!elSelected || elSelected.attr('data-river') !== 'new') return\n      redrawRiver()\n      elSelected.attr('data-river', '')\n      elSelected.call(d3.drag().on('start', riverDrag)).on('click', editRiver)\n      const r = +elSelected.attr('id').slice(5)\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const x = +d3.select(this).attr('cx')\n        const y = +d3.select(this).attr('cy')\n        const cell = diagram.find(x, y, 3)\n        if (!cell) return\n        if (cells[cell.index].river === undefined) cells[cell.index].river = r\n      })\n      unselect()\n      debug.append('g').attr('class', 'controlPoints')\n    }\n\n    $('#riverCopy').click(function() {\n      const tr = parseTransform(elSelected.attr('transform'))\n      const d = elSelected.attr('d')\n      let x = 2, y = 2\n      let transform = `translate(${tr[0] - x},${tr[1] - y}) rotate(${tr[2]} ${tr[3]} ${tr[4]}) scale(${tr[5]})`\n      while (rivers.selectAll('[transform=\\'' + transform + '\\'][d=\\'' + d + '\\']').size() > 0) {\n        x += 2\n        y += 2\n        transform =\n          `translate(${tr[0] - x},${tr[1] - y}) rotate(${tr[2]} ${tr[3]} ${tr[4]}) scale(${tr[5]})`\n      }\n      const river = +$('#rivers > path').last().attr('id').slice(5) + 1\n      rivers.append('path').attr('d', d)\n            .attr('transform', transform)\n            .attr('id', 'river' + river).on('click', editRiver)\n            .attr('data-width', elSelected.attr('data-width'))\n            .attr('data-increment', elSelected.attr('data-increment'))\n      unselect()\n    })\n\n    // open legendsEditor\n    document.getElementById('riverLegend').addEventListener('click', function() {\n      let id = elSelected.attr('id')\n      editLegends(id, id)\n    })\n\n    $('#riverRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the river?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove river',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            const river = +elSelected.attr('id').slice(5)\n            const avPrec = _.round(precInput.value / Math.sqrt(cells.length), 2)\n            land.map(function(l) {\n              if (l.river === river) {\n                l.river = undefined\n                l.flux = avPrec\n              }\n            })\n            elSelected.remove()\n            unselect()\n            $('#riverEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n  }\n\n  function editRoute() {\n    if (customization) {return}\n    if (elSelected) {\n      const self = d3.select(this).attr('id') === elSelected.attr('id')\n      const point = d3.mouse(this)\n      if (elSelected.attr('data-route') === 'new') {\n        addRoutePoint({x: point[0], y: point[1]})\n        completeNewRoute()\n        return\n      } else if (self) {\n        routeAddControlPoint(point)\n        return\n      }\n    }\n\n    unselect()\n    closeDialogs('#routeEditor, .stable')\n\n    if (this && this !== window) {\n      elSelected = d3.select(this)\n      if (!debug.select('.controlPoints').size()) debug.append('g')\n                                                       .attr('class', 'controlPoints')\n      routeDrawPoints()\n      routeUpdateGroups()\n      let routeType = d3.select(this.parentNode).attr('id')\n      routeGroup.value = routeType\n\n      $('#routeEditor').dialog({\n        title: 'Edit Route',\n        minHeight: 30, width: 'auto', resizable: false,\n        position: {my: 'center top+20', at: 'top', of: d3.event},\n        close: function() {\n          if ($('#addRoute').hasClass('pressed')) completeNewRoute()\n          if ($('#routeSplit').hasClass('pressed')) $('#routeSplit').removeClass('pressed')\n          unselect()\n        }\n      })\n    } else {elSelected = null}\n\n    if (modules.editRoute) {return}\n    modules.editRoute = true\n\n    function routeAddControlPoint(point) {\n      let dists = []\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const x = +d3.select(this).attr('cx')\n        const y = +d3.select(this).attr('cy')\n        dists.push(Math.hypot(point[0] - x, point[1] - y))\n      })\n      let index = dists.length\n      if (dists.length > 1) {\n        const sorted = dists.slice(0).sort(function(a, b) {return a - b})\n        const closest = dists.indexOf(sorted[0])\n        const next = dists.indexOf(sorted[1])\n        if (closest <= next) {index = closest + 1} else {index = next + 1}\n      }\n      const before = ':nth-child(' + (index + 1) + ')'\n      debug.select('.controlPoints').insert('circle', before)\n           .attr('cx', point[0]).attr('cy', point[1]).attr('r', 0.35)\n           .call(d3.drag().on('drag', routePointDrag))\n           .on('click', function(d) {\n             $(this).remove()\n             routeRedraw()\n           })\n      routeRedraw()\n    }\n\n    function routeDrawPoints() {\n      if (!elSelected.size()) return\n      const node = elSelected.node()\n      const l = node.getTotalLength()\n      const parts = (l / 5) >> 0 // number of points\n      let inc = l / parts // increment\n      if (inc === Infinity) inc = l // 2 control points for short routes\n      // draw control points\n      for (let i = 0; i <= l; i += inc) {\n        const p = node.getPointAtLength(i)\n        addRoutePoint(p)\n      }\n      // convert length to distance\n      routeLength.innerHTML = Math.round(l * distanceScale.value) + ' ' + distanceUnit.value\n    }\n\n    function addRoutePoint(point) {\n      const controlPoints = debug.select('.controlPoints').size()\n                            ? debug.select('.controlPoints')\n                            : debug.append('g').attr('class', 'controlPoints')\n      controlPoints.append('circle')\n                   .attr('cx', point.x).attr('cy', point.y).attr('r', 0.35)\n                   .call(d3.drag().on('drag', routePointDrag))\n                   .on('click', function(d) {\n                     if ($('#routeSplit').hasClass('pressed')) {\n                       routeSplitInPoint(this)\n                     } else {\n                       $(this).remove()\n                       routeRedraw()\n                     }\n                   })\n    }\n\n    function routePointDrag() {\n      d3.select(this).attr('cx', d3.event.x).attr('cy', d3.event.y)\n      routeRedraw()\n    }\n\n    function routeRedraw() {\n      let points = []\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const el = d3.select(this)\n        points.push({scX: +el.attr('cx'), scY: +el.attr('cy')})\n      })\n      lineGen.curve(d3.curveCatmullRom.alpha(0.1))\n      elSelected.attr('d', lineGen(points))\n      // get route distance\n      const l = elSelected.node().getTotalLength()\n      routeLength.innerHTML = Math.round(l * distanceScale.value) + ' ' + distanceUnit.value\n    }\n\n    function addNewRoute() {\n      let routeType = elSelected && elSelected.node() ? elSelected.node().parentNode.id :\n                      'searoutes'\n      const group = routes.select('#' + routeType)\n      const id = routeType + '' + group.selectAll('*').size()\n      elSelected =\n        group.append('path').attr('data-route', 'new').attr('id', id).on('click', editRoute)\n      routeUpdateGroups()\n      $('#routeEditor').dialog({\n        title: 'Edit Route', minHeight: 30, width: 'auto', resizable: false,\n        close: function() {\n          if ($('#addRoute').hasClass('pressed')) completeNewRoute()\n          if ($('#routeSplit').hasClass('pressed')) $('#routeSplit').removeClass('pressed')\n          unselect()\n        }\n      })\n    }\n\n    function newRouteAddPoint() {\n      const point = d3.mouse(this)\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n      addRoutePoint({x, y})\n      routeRedraw()\n    }\n\n    function completeNewRoute() {\n      $('#routeNew, #addRoute').removeClass('pressed')\n      restoreDefaultEvents()\n      if (!elSelected.size()) return\n      if (elSelected.attr('data-route') === 'new') {\n        routeRedraw()\n        elSelected.attr('data-route', '')\n        const node = elSelected.node()\n        const l = node.getTotalLength()\n        let pathCells = []\n        for (let i = 0; i <= l; i++) {\n          const p = node.getPointAtLength(i)\n          const cell = diagram.find(p.x, p.y)\n          if (!cell) {return}\n          pathCells.push(cell.index)\n        }\n        const uniqueCells = [...new Set(pathCells)]\n        uniqueCells.map(function(c) {\n          if (cells[c].path !== undefined) {cells[c].path += 1} else {cells[c].path = 1}\n        })\n      }\n      tip('', true)\n    }\n\n    function routeUpdateGroups() {\n      routeGroup.innerHTML = ''\n      routes.selectAll('g').each(function() {\n        const opt = document.createElement('option')\n        opt.value = opt.innerHTML = this.id\n        routeGroup.add(opt)\n      })\n    }\n\n    function routeSplitInPoint(clicked) {\n      const group = d3.select(elSelected.node().parentNode)\n      $('#routeSplit').removeClass('pressed')\n      const points1 = [], points2 = []\n      let points = points1\n      debug.select('.controlPoints').selectAll('circle').each(function() {\n        const el = d3.select(this)\n        points.push({scX: +el.attr('cx'), scY: +el.attr('cy')})\n        if (this === clicked) {\n          points = points2\n          points.push({scX: +el.attr('cx'), scY: +el.attr('cy')})\n        }\n        el.remove()\n      })\n      lineGen.curve(d3.curveCatmullRom.alpha(0.1))\n      elSelected.attr('d', lineGen(points1))\n      const id = routeGroup.value + '' + group.selectAll('*').size()\n      group.append('path').attr('id', id).attr('d', lineGen(points2)).on('click', editRoute)\n      routeDrawPoints()\n    }\n\n    $('#routeGroup').change(function() {\n      $(elSelected.node()).detach().appendTo($('#' + this.value))\n    })\n\n    // open legendsEditor\n    document.getElementById('routeLegend').addEventListener('click', function() {\n      let id = elSelected.attr('id')\n      editLegends(id, id)\n    })\n\n    $('#routeNew').click(function() {\n      if ($(this).hasClass('pressed')) {\n        completeNewRoute()\n      } else {\n        // enter creation mode\n        $('.pressed').removeClass('pressed')\n        $('#routeNew, #addRoute').addClass('pressed')\n        debug.select('.controlPoints').selectAll('*').remove()\n        addNewRoute()\n        viewbox.style('cursor', 'crosshair').on('click', newRouteAddPoint)\n        tip('Click on map to add route point', true)\n      }\n    })\n\n    $('#routeRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the route?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove route',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            $('#routeEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editIcon() {\n    if (customization) return\n    if (elSelected) if (this.isSameNode(elSelected.node())) return\n\n    unselect()\n    closeDialogs('#iconEditor, .stable')\n    elSelected =\n      d3.select(this).call(d3.drag().on('start', elementDrag)).classed('draggable', true)\n\n    // update group parameters\n    const group = d3.select(this.parentNode)\n    iconUpdateGroups()\n    iconGroup.value = group.attr('id')\n    iconFillColor.value = group.attr('fill')\n    iconStrokeColor.value = group.attr('stroke')\n    iconSize.value = group.attr('size')\n    iconStrokeWidth.value = group.attr('stroke-width')\n\n    $('#iconEditor').dialog({\n      title: 'Edit icon: ' + group.attr('id'),\n      minHeight: 30, width: 'auto', resizable: false,\n      position: {my: 'center top+20', at: 'top', of: d3.event},\n      close: unselect\n    })\n\n    if (modules.editIcon) {return}\n    modules.editIcon = true\n\n    $('#iconGroups').click(function() {\n      $('#iconEditor > button').not(this).toggle()\n      $('#iconGroupsSelection').toggle()\n    })\n\n    function iconUpdateGroups() {\n      iconGroup.innerHTML = ''\n      const anchor = group.attr('id').includes('anchor')\n      icons.selectAll('g').each(function(d) {\n        const id = d3.select(this).attr('id')\n        if (id === 'burgs') return\n        if (!anchor && id.includes('anchor')) return\n        if (anchor && !id.includes('anchor')) return\n        const opt = document.createElement('option')\n        opt.value = opt.innerHTML = id\n        iconGroup.add(opt)\n      })\n    }\n\n    $('#iconGroup').change(function() {\n      const newGroup = this.value\n      const to = $('#icons > #' + newGroup)\n      $(elSelected.node()).detach().appendTo(to)\n    })\n\n    $('#iconCopy').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const copy = elSelected.node().cloneNode()\n      copy.removeAttribute('data-id') // remove assignment to burg if any\n      const tr = parseTransform(copy.getAttribute('transform'))\n      const shift = 10 / Math.sqrt(scale)\n      let transform = 'translate(' + _.round(tr[0] - shift, 1) + ',' + _.round(tr[1] - shift, 1) + ')'\n      for (let i = 2; group.selectAll(\"[transform='\" + transform + \"']\").size() > 0; i++) {\n        transform =\n          'translate(' + _.round(tr[0] - shift * i, 1) + ',' + _.round(tr[1] - shift * i, 1) + ')'\n      }\n      copy.setAttribute('transform', transform)\n      group.node().insertBefore(copy, null)\n      copy.addEventListener('click', editIcon)\n    })\n\n    $('#iconRemoveGroup').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const count = group.selectAll('*').size()\n      if (count < 2) {\n        group.remove()\n        $('#labelEditor').dialog('close')\n        return\n      }\n      const message = 'Are you sure you want to remove all \\'' + iconGroup.value + '\\' icons (' + count + ')?'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Remove icon group',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            group.remove()\n            $('#iconEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    $('#iconColors').click(function() {\n      $('#iconEditor > button').not(this).toggle()\n      $('#iconColorsSection').toggle()\n    })\n\n    $('#iconFillColor').change(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      group.attr('fill', this.value)\n    })\n\n    $('#iconStrokeColor').change(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      group.attr('stroke', this.value)\n    })\n\n    $('#iconSetSize').click(function() {\n      $('#iconEditor > button').not(this).toggle()\n      $('#iconSizeSection').toggle()\n    })\n\n    $('#iconSize').change(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const size = +this.value\n      group.attr('size', size)\n      group.selectAll('*')\n           .each(function() {d3.select(this).attr('width', size).attr('height', size)})\n    })\n\n    $('#iconStrokeWidth').change(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      group.attr('stroke-width', this.value)\n    })\n\n    $('#iconRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the icon?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove icon',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            $('#iconEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editReliefIcon() {\n    if (customization) return\n    if (elSelected) if (this.isSameNode(elSelected.node())) return\n\n    unselect()\n    closeDialogs('#reliefEditor, .stable')\n    elSelected =\n      d3.select(this).raise().call(d3.drag().on('start', elementDrag)).classed('draggable', true)\n    const group = elSelected.node().parentNode.id\n    reliefGroup.value = group\n\n    let bulkRemoveSection = document.getElementById('reliefBulkRemoveSection')\n    if (bulkRemoveSection.style.display != 'none') reliefBulkRemove.click()\n\n    $('#reliefEditor').dialog({\n      title: 'Edit relief icon',\n      minHeight: 30, width: 'auto', resizable: false,\n      position: {my: 'center top+40', at: 'top', of: d3.event},\n      close: unselect\n    })\n\n    if (modules.editReliefIcon) {return}\n    modules.editReliefIcon = true\n\n    $('#reliefGroups').click(function() {\n      $('#reliefEditor > button').not(this).toggle()\n      $('#reliefGroupsSelection').toggle()\n    })\n\n    $('#reliefGroup').change(function() {\n      const type = this.value\n      const bbox = elSelected.node().getBBox()\n      const cx = bbox.x\n      const cy = bbox.y + bbox.height / 2\n      const cell = diagram.find(cx, cy).index\n      const height = cell !== undefined ? cells[cell].height : 50\n      elSelected.remove()\n      elSelected = addReliefIcon(height / 100, type, cx, cy, cell)\n      elSelected.call(d3.drag().on('start', elementDrag))\n    })\n\n    $('#reliefCopy').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const copy = elSelected.node().cloneNode(true)\n      const tr = parseTransform(copy.getAttribute('transform'))\n      const shift = 10 / Math.sqrt(scale)\n      let transform = 'translate(' + _.round(tr[0] - shift, 1) + ',' + _.round(tr[1] - shift, 1) + ')'\n      for (let i = 2; group.selectAll(\"[transform='\" + transform + \"']\").size() > 0; i++) {\n        transform =\n          'translate(' + _.round(tr[0] - shift * i, 1) + ',' + _.round(tr[1] - shift * i, 1) + ')'\n      }\n      copy.setAttribute('transform', transform)\n      group.node().insertBefore(copy, null)\n      copy.addEventListener('click', editReliefIcon)\n    })\n\n    $('#reliefAddfromEditor').click(function() {\n      clickToAdd() // to load on click event function\n      $('#addRelief').click()\n    })\n\n    $('#reliefRemoveGroup').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const count = group.selectAll('*').size()\n      if (count < 2) {\n        group.selectAll('*').remove()\n        $('#labelEditor').dialog('close')\n        return\n      }\n      const message = 'Are you sure you want to remove all \\'' + reliefGroup.value + '\\' icons (' + count + ')?'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Remove all icons within group',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            group.selectAll('*').remove()\n            $('#reliefEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    $('#reliefBulkRemove').click(function() {\n      $('#reliefEditor > button').not(this).toggle()\n      let section = document.getElementById('reliefBulkRemoveSection')\n      if (section.style.display === 'none') {\n        section.style.display = 'inline-block'\n        tip('Drag to remove relief icons in radius', true)\n        viewbox.style('cursor', 'crosshair').call(d3.drag().on('drag', dragToRemoveReliefIcons))\n        customization = 5\n      } else {\n        section.style.display = 'none'\n        restoreDefaultEvents()\n        customization = 0\n      }\n    })\n\n    function dragToRemoveReliefIcons() {\n      let point = d3.mouse(this)\n      let cell = diagram.find(point[0], point[1]).index\n      let radius = +reliefBulkRemoveRadius.value\n      let r = Math.round(6 / graphSize * radius, 1)\n      moveCircle(point[0], point[1], r)\n      let selection = defineBrushSelection(cell, radius)\n      if (selection) removeReliefIcons(selection)\n    }\n\n    function removeReliefIcons(selection) {\n      if (selection.length === 0) return\n      selection.map(function(index) {\n        const selected = terrain.selectAll('g').selectAll('g[data-cell=\\'' + index + '\\']')\n        selected.remove()\n      })\n    }\n\n    $('#reliefRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the icon?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove relief icon',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            $('#reliefEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editBurg() {\n    if (customization) return\n    unselect()\n    closeDialogs('#burgEditor, .stable')\n    elSelected = d3.select(this)\n    const id = +elSelected.attr('data-id')\n    if (id === undefined) return\n    d3.selectAll('[data-id=\\'' + id + '\\']').call(d3.drag().on('start', elementDrag))\n      .classed('draggable', true)\n\n    // update Burg details\n    const type = elSelected.node().parentNode.id\n    const labelGroup = burgLabels.select('#' + type)\n    const iconGroup = burgIcons.select('#' + type)\n    burgNameInput.value = manors[id].name\n    updateBurgsGroupOptions()\n    burgSelectGroup.value = labelGroup.attr('id')\n    burgSelectDefaultFont.value = FONTS.indexOf(labelGroup.attr('data-font'))\n    burgSetLabelSize.value = labelGroup.attr('data-size')\n    burgLabelColorInput.value = toHEX(labelGroup.attr('fill'))\n    burgLabelOpacity.value =\n      labelGroup.attr('opacity') === undefined ? 1 : +labelGroup.attr('opacity')\n    const tr = parseTransform(elSelected.attr('transform'))\n    burgLabelAngle.value = tr[2]\n    burgLabelAngleOutput.innerHTML = Math.abs(+tr[2]) + '°'\n    burgIconSize.value = iconGroup.attr('size')\n    burgIconFillOpacity.value =\n      iconGroup.attr('fill-opacity') === undefined ? 1 : +iconGroup.attr('fill-opacity')\n    burgIconFillColor.value = iconGroup.attr('fill')\n    burgIconStrokeWidth.value = iconGroup.attr('stroke-width')\n    burgIconStrokeOpacity.value =\n      iconGroup.attr('stroke-opacity') === undefined ? 1 : +iconGroup.attr('stroke-opacity')\n    burgIconStrokeColor.value = iconGroup.attr('stroke')\n    const cell = cells[manors[id].cell]\n    if (cell.region !== 'neutral' && cell.region !== undefined) {\n      burgToggleCapital.disabled = false\n      const capital = states[manors[id].region] ?\n                      id === states[manors[id].region].capital ? 1 : 0 : 0\n      d3.select('#burgToggleCapital').classed('pressed', capital)\n    } else {\n      burgToggleCapital.disabled = true\n      d3.select('#burgToggleCapital').classed('pressed', false)\n    }\n    d3.select('#burgTogglePort').classed('pressed', cell.port !== undefined)\n    burgPopulation.value = manors[id].population\n    burgPopulationFriendly.value =\n      Math.round(manors[id].population * urbanization.value * populationRate.value * 1000)\n\n    $('#burgEditor').dialog({\n      title: 'Edit Burg: ' + manors[id].name,\n      minHeight: 30, width: 'auto', resizable: false,\n      position: {my: 'center top+40', at: 'top', of: d3.event},\n      close: function() {\n        d3.selectAll('[data-id=\\'' + id + '\\']').call(d3.drag().on('drag', null))\n          .classed('draggable', false)\n        elSelected = null\n      }\n    })\n\n    if (modules.editBurg) return\n    modules.editBurg = true\n\n    loadDefaultFonts()\n\n    function updateBurgsGroupOptions() {\n      burgSelectGroup.innerHTML = ''\n      burgIcons.selectAll('g').each(function(d) {\n        const opt = document.createElement('option')\n        opt.value = opt.innerHTML = d3.select(this).attr('id')\n        burgSelectGroup.add(opt)\n      })\n    }\n\n    $('#burgEditor > button').not('#burgAddfromEditor').not('#burgRelocate').not('#burgRemove')\n                             .click(function() {\n                               if ($(this).next().is(':visible')) {\n                                 $('#burgEditor > button').show()\n                                 $(this).next('div').hide()\n                               } else {\n                                 $('#burgEditor > *').not(this).hide()\n                                 $(this).next('div').show()\n                               }\n                             })\n\n    $('#burgEditor > div > button').click(function() {\n      if ($(this).next().is(':visible')) {\n        $('#burgEditor > div > button').show()\n        $(this).parent().prev().show()\n        $(this).next('div').hide()\n      } else {\n        $('#burgEditor > div > button').not(this).hide()\n        $(this).parent().prev().hide()\n        $(this).next('div').show()\n      }\n    })\n\n    $('#burgSelectGroup').change(function() {\n      const id = +elSelected.attr('data-id')\n      const g = this.value\n      moveBurgToGroup(id, g)\n    })\n\n    $('#burgInputGroup').change(function() {\n      let newGroup = this.value.toLowerCase().replace(/ /g, '_').replace(/[^\\w\\s]/gi, '')\n      if (Number.isFinite(+newGroup.charAt(0))) newGroup = 'g' + newGroup\n      if (burgLabels.select('#' + newGroup).size()) {\n        tip('The group \"' + newGroup + '\" is already exists')\n        return\n      }\n      burgInputGroup.value = ''\n      // clone old group assigning new id\n      const id = elSelected.node().parentNode.id\n      const l = burgLabels.select('#' + id).node().cloneNode(false)\n      l.id = newGroup\n      const i = burgIcons.select('#' + id).node().cloneNode(false)\n      i.id = newGroup\n      burgLabels.node().insertBefore(l, null)\n      burgIcons.node().insertBefore(i, null)\n      // select new group\n      const opt = document.createElement('option')\n      opt.value = opt.innerHTML = newGroup\n      burgSelectGroup.add(opt)\n      $('#burgSelectGroup').val(newGroup).change()\n      $('#burgSelectGroup, #burgInputGroup').toggle()\n      updateLabelGroups()\n    })\n\n    $('#burgAddGroup').click(function() {\n      if ($('#burgInputGroup').css('display') === 'none') {\n        $('#burgInputGroup').css('display', 'inline-block')\n        $('#burgSelectGroup').css('display', 'none')\n        burgInputGroup.focus()\n      } else {\n        $('#burgSelectGroup').css('display', 'inline-block')\n        $('#burgInputGroup').css('display', 'none')\n      }\n    })\n\n    $('#burgRemoveGroup').click(function() {\n      const group = d3.select(elSelected.node().parentNode)\n      const type = group.attr('id')\n      const id = +elSelected.attr('data-id')\n      const count = group.selectAll('*').size()\n      const message = 'Are you sure you want to remove all Burgs (' + count + ') of that group?'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Remove Burgs',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            group.selectAll('*').each(function(d) {\n              const id = +d3.select(this).attr('data-id')\n              if (id === undefined) return\n              const cell = manors[id].cell\n              const state = manors[id].region\n              if (states[state]) {\n                if (states[state].capital === id) states[state].capital = 'select'\n                states[state].burgs--\n              }\n              manors[id].region = 'removed'\n              cells[cell].manor = undefined\n            })\n            burgLabels.select('#' + type).selectAll('*').remove()\n            burgIcons.select('#' + type).selectAll('*').remove()\n            $('#icons g[id*=\\'anchors\\'] [data-id=' + id + ']').parent().children().remove()\n            closeDialogs('.stable')\n            updateCountryEditors()\n            $('#burgEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n\n    })\n\n    $('#burgNameInput').on('input', function() {\n      if (this.value === '') {\n        tip(\n          'Name should not be blank, set opacity to 0 to hide label or remove button to delete')\n        return\n      }\n      const id = +elSelected.attr('data-id')\n      burgLabels.selectAll('[data-id=\\'' + id + '\\']').text(this.value)\n      manors[id].name = this.value\n      $('div[aria-describedby=\\'burgEditor\\'] .ui-dialog-title').text('Edit Burg: ' + this.value)\n    })\n\n    $('#burgNameReCulture, #burgNameReRandom').click(function() {\n      const id = +elSelected.attr('data-id')\n      const culture = this.id === 'burgNameReCulture' ? manors[id].culture :\n                      Math.floor(Math.random() * cultures.length)\n      const name = generateName(culture)\n      burgLabels.selectAll('[data-id=\\'' + id + '\\']').text(name)\n      manors[id].name = name\n      burgNameInput.value = name\n      $('div[aria-describedby=\\'burgEditor\\'] .ui-dialog-title').text('Edit Burg: ' + name)\n    })\n\n    $('#burgToggleExternalFont').click(function() {\n      if ($('#burgInputExternalFont').css('display') === 'none') {\n        $('#burgInputExternalFont').css('display', 'inline-block')\n        $('#burgSelectDefaultFont').css('display', 'none')\n        burgInputExternalFont.focus()\n      } else {\n        $('#burgSelectDefaultFont').css('display', 'inline-block')\n        $('#burgInputExternalFont').css('display', 'none')\n      }\n    })\n\n    $('#burgSelectDefaultFont').change(function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgLabels.select('#' + type)\n      if (burgSelectDefaultFont.value === '') return\n      const font = FONTS[burgSelectDefaultFont.value].split(':')[0].replace(/\\+/g, ' ')\n      group.attr('font-family', font).attr('data-font', FONTS[burgSelectDefaultFont.value])\n    })\n\n    $('#burgInputExternalFont').change(function() {\n      fetchFonts(this.value).then(fetched => {\n        if (!fetched) return\n        burgToggleExternalFont.click()\n        burgInputExternalFont.value = ''\n        if (fetched === 1) $('#burgSelectDefaultFont').val(FONTS.length - 1).change()\n      })\n    })\n\n    $('#burgSetLabelSize').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgLabels.select('#' + type)\n      group.attr('data-size', +this.value)\n      invokeActiveZooming()\n    })\n\n    $('#burgLabelColorInput').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgLabels.select('#' + type)\n      group.attr('fill', this.value)\n    })\n\n    $('#burgLabelOpacity').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgLabels.select('#' + type)\n      group.attr('opacity', +this.value)\n    })\n\n    $('#burgLabelAngle').on('input', function() {\n      const id = +elSelected.attr('data-id')\n      const el = burgLabels.select('[data-id=\\'' + id + '\\']')\n      const tr = parseTransform(el.attr('transform'))\n      const c = el.node().getBBox()\n      burgLabelAngleOutput.innerHTML = Math.abs(+this.value) + '°'\n      const angle = +this.value\n      const transform = `translate(${tr[0]},${tr[1]}) rotate(${angle} ${(c.x + c.width / 2)} ${(c.y + c.height / 2)})`\n      el.attr('transform', transform)\n    })\n\n    $('#burgIconSize').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      const size = +this.value\n      group.attr('size', size)\n      group.selectAll('*').each(function() {d3.select(this).attr('r', size)})\n    })\n\n    $('#burgIconFillOpacity').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('fill-opacity', +this.value)\n    })\n\n    $('#burgIconFillColor').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('fill', this.value)\n    })\n\n    $('#burgIconStrokeWidth').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('stroke-width', +this.value)\n    })\n\n    $('#burgIconStrokeOpacity').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('stroke-opacity', +this.value)\n    })\n\n    $('#burgIconStrokeColor').on('input', function() {\n      const type = elSelected.node().parentNode.id\n      const group = burgIcons.select('#' + type)\n      group.attr('stroke', this.value)\n    })\n\n    $('#burgToggleCapital').click(function() {\n      const id = +elSelected.attr('data-id')\n      const state = manors[id].region\n      if (states[state] === undefined) return\n      const capital = states[manors[id].region] ?\n                      id === states[manors[id].region].capital ? 0 : 1 : 1\n      if (capital && states[state].capital !== 'select') {\n        // move oldCapital to a town group\n        const oldCapital = states[state].capital\n        moveBurgToGroup(oldCapital, 'towns')\n      }\n      states[state].capital = capital ? id : 'select'\n      d3.select('#burgToggleCapital').classed('pressed', capital)\n      const g = capital ? 'capitals' : 'towns'\n      moveBurgToGroup(id, g)\n    })\n\n    $('#burgTogglePort').click(function() {\n      const id = +elSelected.attr('data-id')\n      const cell = cells[manors[id].cell]\n      const markAsPort = cell.port === undefined ? true : undefined\n      cell.port = markAsPort\n      d3.select('#burgTogglePort').classed('pressed', markAsPort)\n      if (markAsPort) {\n        const type = elSelected.node().parentNode.id\n        const ag = type === 'capitals' ? '#capital-anchors' : '#town-anchors'\n        const group = icons.select(ag)\n        const size = +group.attr('size')\n        const x = _.round(manors[id].x - size * 0.47, 2)\n        const y = _.round(manors[id].y - size * 0.47, 2)\n        group.append('use').attr('xlink:href', '#icon-anchor').attr('data-id', id)\n             .attr('x', x).attr('y', y).attr('width', size).attr('height', size)\n             .on('click', editIcon)\n      } else {\n        $('#icons g[id*=\\'anchors\\'] [data-id=' + id + ']').remove()\n      }\n    })\n\n    $('#burgPopulation').on('input', function() {\n      const id = +elSelected.attr('data-id')\n      burgPopulationFriendly.value =\n        Math.round(this.value * urbanization.value * populationRate.value * 1000)\n      manors[id].population = +this.value\n    })\n\n    $('#burgRelocate').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n        tip('', true)\n      } else {\n        $('.pressed').removeClass('pressed')\n        const id = elSelected.attr('data-id')\n        $(this).addClass('pressed').attr('data-id', id)\n        viewbox.style('cursor', 'crosshair').on('click', relocateBurgOnClick)\n        tip('Click on map to relocate burg. Hold Shift for continuous move', true)\n      }\n    })\n\n    // open legendsEditor\n    document.getElementById('burglLegend').addEventListener('click', function() {\n      let burg = +elSelected.attr('data-id')\n      let id = 'burg' + burg\n      let name = manors[burg].name\n      editLegends(id, name)\n    })\n\n    // move burg to a different cell\n    function relocateBurgOnClick() {\n      const point = d3.mouse(this)\n      const index = getIndex(point)\n      const i = +$('#burgRelocate').attr('data-id')\n      if (isNaN(i) || !manors[i]) return\n\n      if (cells[index].height < 20) {\n        tip('Cannot place burg in the water! Select a land cell', null, 'error')\n        return\n      }\n\n      if (cells[index].manor !== undefined && cells[index].manor !== i) {\n        tip('There is already a burg in this cell. Please select a free cell', null, 'error')\n        $('#grid').fadeIn()\n        d3.select('#toggleGrid').classed('buttonoff', false)\n        return\n      }\n\n      let region = cells[index].region\n      const oldRegion = manors[i].region\n      // relocating capital to other country you \"conquer\" target cell\n      if (states[oldRegion] && states[oldRegion].capital === i) {\n        if (region !== oldRegion) {\n          tip('Capital cannot be moved to another country!', null, 'error')\n          return\n        }\n      }\n\n      if (d3.event.shiftKey === false) {\n        $('#burgRelocate').removeClass('pressed')\n        restoreDefaultEvents()\n        tip('', true)\n        if (region !== oldRegion) {\n          recalculateStateData(oldRegion)\n          recalculateStateData(region)\n          updateCountryEditors()\n        }\n      }\n\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n      burgIcons.select('circle[data-id=\\'' + i + '\\']').attr('transform', null).attr('cx', x)\n               .attr('cy', y)\n      burgLabels.select('text[data-id=\\'' + i + '\\']').attr('transform', null).attr('x', x)\n                .attr('y', y)\n      const anchor = icons.select('use[data-id=\\'' + i + '\\']')\n      if (anchor.size()) {\n        const size = anchor.attr('width')\n        const xa = _.round(x - size * 0.47, 2)\n        const ya = _.round(y - size * 0.47, 2)\n        anchor.attr('transform', null).attr('x', xa).attr('y', ya)\n      }\n      cells[index].manor = i\n      cells[manors[i].cell].manor = undefined\n      manors[i].x = x, manors[i].y = y, manors[i].region = region, manors[i].cell = index\n    }\n\n    // open in MFCG\n    $('#burgSeeInMFCG').click(function() {\n      const id = +elSelected.attr('data-id')\n      const name = manors[id].name\n      const cell = manors[id].cell\n      const pop = Math.round(manors[id].population)\n      const size = pop > 65 ? 65 : pop < 6 ? 6 : pop\n      const s = seed + '' + id\n      const hub = cells[cell].crossroad > 2 ? 1 : 0\n      const river = cells[cell].river ? 1 : 0\n      const coast = cells[cell].port !== undefined ? 1 : 0\n      const sec = pop > 40 ? 1 : Math.random() < pop / 100 ? 1 : 0\n      const thr = sec && Math.random() < 0.8 ? 1 : 0\n      const url = 'http://fantasycities.watabou.ru/'\n      let params = `?name=${name}&size=${size}&seed=${s}&hub=${hub}&random=0&continuous=0`\n      params +=\n        `&river=${river}&coast=${coast}&citadel=${id & 1}&plaza=${sec}&temple=${thr}&walls=${sec}&shantytown=${sec}`\n      const win = window.open(url + params, '_blank')\n      win.focus()\n    })\n\n    $('#burgAddfromEditor').click(function() {\n      clickToAdd() // to load on click event function\n      $('#addBurg').click()\n    })\n\n    $('#burgRemove').click(function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the Burg?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove Burg',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            const id = +elSelected.attr('data-id')\n            d3.selectAll('[data-id=\\'' + id + '\\']').remove()\n            const cell = manors[id].cell\n            const state = manors[id].region\n            if (states[state]) {\n              if (states[state].capital === id) states[state].capital = 'select'\n              states[state].burgs--\n            }\n            manors[id].region = 'removed'\n            cells[cell].manor = undefined\n            closeDialogs('.stable')\n            updateCountryEditors()\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  function editMarker() {\n    if (customization) return\n\n    unselect()\n    closeDialogs('#markerEditor, .stable')\n    elSelected =\n      d3.select(this).call(d3.drag().on('start', elementDrag)).classed('draggable', true)\n\n    $('#markerEditor').dialog({\n      title: 'Edit Marker',\n      minHeight: 30, width: 'auto', maxWidth: 275, resizable: false,\n      position: {my: 'center top+30', at: 'bottom', of: d3.event},\n      close: unselect\n    })\n\n    // update inputs\n    let id = elSelected.attr('href')\n    let symbol = d3.select('#defs-markers').select(id)\n    let icon = symbol.select('text')\n    markerSelectGroup.value = id.slice(1)\n    markerIconSize.value = parseFloat(icon.attr('font-size'))\n    markerIconShiftX.value = parseFloat(icon.attr('x'))\n    markerIconShiftY.value = parseFloat(icon.attr('y'))\n    markerIconFill.value = icon.attr('fill')\n    markerIconStrokeWidth.value = icon.attr('stroke-width')\n    markerIconStroke.value = icon.attr('stroke')\n    markerSize.value = elSelected.attr('data-size')\n    markerBase.value = symbol.select('path').attr('fill')\n    markerFill.value = symbol.select('circle').attr('fill')\n    let opacity = symbol.select('circle').attr('opacity')\n    markerToggleBubble.className = opacity === '0' ? 'icon-info' : 'icon-info-circled'\n\n    let table = document.getElementById('markerIconTable')\n    let selected = table.getElementsByClassName('selected')\n    if (selected.length) selected[0].removeAttribute('class')\n    selected = document.querySelectorAll('#markerIcon' + icon.text().codePointAt())\n    if (selected.length) selected[0].className = 'selected'\n    markerIconCustom.value = selected.length ? '' : icon.text()\n\n    if (modules.editMarker) return\n    modules.editMarker = true\n\n    $('#markerGroup').click(function() {\n      $('#markerEditor > button').not(this).toggle()\n      $('#markerGroupSection').toggle()\n      updateMarkerGroupOptions()\n    })\n\n    function updateMarkerGroupOptions() {\n      markerSelectGroup.innerHTML = ''\n      d3.select('#defs-markers').selectAll('symbol').each(function() {\n        let opt = document.createElement('option')\n        opt.value = opt.innerHTML = this.id\n        markerSelectGroup.add(opt)\n      })\n      let id = elSelected.attr('href').slice(1)\n      markerSelectGroup.value = id\n    }\n\n    // on add marker type click\n    document.getElementById('markerAddGroup').addEventListener('click', function() {\n      if ($('#markerInputGroup').css('display') === 'none') {\n        $('#markerInputGroup').css('display', 'inline-block')\n        $('#markerSelectGroup').css('display', 'none')\n        markerInputGroup.focus()\n      } else {\n        $('#markerSelectGroup').css('display', 'inline-block')\n        $('#markerInputGroup').css('display', 'none')\n      }\n    })\n\n    // on marker type change\n    document.getElementById('markerSelectGroup').addEventListener('change', function() {\n      elSelected.attr('href', '#' + this.value)\n      elSelected.attr('data-id', '#' + this.value)\n    })\n\n    // on new type input\n    document.getElementById('markerInputGroup').addEventListener('change', function() {\n      let newGroup = this.value.toLowerCase().replace(/ /g, '_').replace(/[^\\w\\s]/gi, '')\n      if (Number.isFinite(+newGroup.charAt(0))) newGroup = 'm' + newGroup\n      if (d3.select('#defs-markers').select('#' + newGroup).size()) {\n        tip('The type \"' + newGroup + '\" is already exists')\n        return\n      }\n      markerInputGroup.value = ''\n      // clone old group assigning new id\n      let id = elSelected.attr('href')\n      let l = d3.select('#defs-markers').select(id).node().cloneNode(true)\n      l.id = newGroup\n      elSelected.attr('href', '#' + newGroup)\n      elSelected.attr('data-id', '#' + newGroup)\n      document.getElementById('defs-markers').insertBefore(l, null)\n\n      // select new group\n      let opt = document.createElement('option')\n      opt.value = opt.innerHTML = newGroup\n      markerSelectGroup.add(opt)\n      $('#markerSelectGroup').val(newGroup).change()\n      $('#markerSelectGroup, #markerInputGroup').toggle()\n      updateMarkerGroupOptions()\n    })\n\n    $('#markerIconButton').click(function() {\n      $('#markerEditor > button').not(this).toggle()\n      $('#markerIconButtons').toggle()\n      if (!$('#markerIconTable').text()) drawIconsList(icons)\n    })\n\n    $('#markerRemoveGroup').click(function() {\n      let id = elSelected.attr('href')\n      let used = document.querySelectorAll('use[data-id=\\'' + id + '\\']')\n      let count = used.length === 1 ? '1 element' : used.length + ' elements'\n      const message = 'Are you sure you want to remove the marker (' + count + ')?'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Remove marker',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            if (id !== '#marker0') d3.select('#defs-markers').select(id).remove()\n            used.forEach(function(e) {e.remove()})\n            updateMarkerGroupOptions()\n            $('#markerEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    function drawIconsList() {\n      let table = document.getElementById('markerIconTable'), row = ''\n      table.addEventListener('click', clickMarkerIconTable, false)\n      table.addEventListener('mouseover', hoverMarkerIconTable, false)\n\n      for (let i = 0; i < ICONS.length; i++) {\n        if (i % 20 === 0) row = table.insertRow(0)\n        let cell = row.insertCell(0)\n        let icon = String.fromCodePoint(parseInt(ICONS[i][0], 16))\n        cell.innerHTML = icon\n        cell.id = 'markerIcon' + icon.codePointAt()\n        cell.setAttribute('data-desc', ICONS[i][2])\n      }\n    }\n\n    function clickMarkerIconTable(e) {\n      if (e.target !== e.currentTarget) {\n        let table = document.getElementById('markerIconTable')\n        let selected = table.getElementsByClassName('selected')\n        if (selected.length) selected[0].removeAttribute('class')\n        e.target.className = 'selected'\n        let id = elSelected.attr('href')\n        let icon = e.target.innerHTML\n        d3.select('#defs-markers').select(id).select('text').text(icon)\n      }\n      e.stopPropagation()\n    }\n\n    function hoverMarkerIconTable(e) {\n      if (e.target !== e.currentTarget) {\n        let desc = e.target.getAttribute('data-desc')\n        tip(e.target.innerHTML + ' ' + desc)\n      }\n      e.stopPropagation()\n    }\n\n    // change marker icon size\n    document.getElementById('markerIconSize').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('font-size', this.value + 'px')\n    })\n\n    // change marker icon x shift\n    document.getElementById('markerIconShiftX').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('x', this.value + '%')\n    })\n\n    // change marker icon y shift\n    document.getElementById('markerIconShiftY').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('y', this.value + '%')\n    })\n\n    // apply custom unicode icon on input\n    document.getElementById('markerIconCustom').addEventListener('input', function() {\n      if (!this.value) return\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').text(this.value)\n    })\n\n    $('#markerStyleButton').click(function() {\n      $('#markerEditor > button').not(this).toggle()\n      $('#markerStyleButtons').toggle()\n    })\n\n    // change marker size\n    document.getElementById('markerSize').addEventListener('input', function() {\n      let id = elSelected.attr('data-id')\n      let used = document.querySelectorAll('use[data-id=\\'' + id + '\\']')\n      let size = this.value\n      used.forEach(function(e) {e.setAttribute('data-size', size)})\n      invokeActiveZooming()\n    })\n\n    // change marker base color\n    document.getElementById('markerBase').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select(id).select('path').attr('fill', this.value)\n      d3.select(id).select('circle').attr('stroke', this.value)\n    })\n\n    // change marker fill color\n    document.getElementById('markerFill').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select(id).select('circle').attr('fill', this.value)\n    })\n\n    // change marker icon y shift\n    document.getElementById('markerIconFill').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('fill', this.value)\n    })\n\n    // change marker icon y shift\n    document.getElementById('markerIconStrokeWidth').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('stroke-width', this.value)\n    })\n\n    // change marker icon y shift\n    document.getElementById('markerIconStroke').addEventListener('input', function() {\n      let id = elSelected.attr('href')\n      d3.select('#defs-markers').select(id).select('text').attr('stroke', this.value)\n    })\n\n    // toggle marker bubble display\n    document.getElementById('markerToggleBubble').addEventListener('click', function() {\n      let id = elSelected.attr('href')\n      let show = 1\n      if (this.className === 'icon-info-circled') {\n        this.className = 'icon-info'\n        show = 0\n      } else {\n        this.className = 'icon-info-circled'\n\n      }\n      d3.select(id).select('circle').attr('opacity', show)\n      d3.select(id).select('path').attr('opacity', show)\n    })\n\n    // open legendsEditor\n    document.getElementById('markerLegendButton').addEventListener('click', function() {\n      let id = elSelected.attr('id')\n      let symbol = elSelected.attr('href')\n      let icon = d3.select('#defs-markers').select(symbol).select('text').text()\n      let name = 'Marker ' + icon\n      editLegends(id, name)\n    })\n\n    // click on master button to add new markers on click\n    document.getElementById('markerAdd').addEventListener('click', function() {\n      document.getElementById('addMarker').click()\n    })\n\n    // remove marker on click\n    document.getElementById('markerRemove').addEventListener('click', function() {\n      alertMessage.innerHTML = 'Are you sure you want to remove the marker?'\n      $('#alert').dialog({\n        resizable: false, title: 'Remove marker',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            elSelected.remove()\n            $('#markerEditor').dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  // clear elSelected variable\n  function unselect() {\n    tip('', true)\n    restoreDefaultEvents()\n    if (customization === 5) customization = 0\n    if (!elSelected) return\n    elSelected.call(d3.drag().on('drag', null)).attr('class', null)\n    debug.selectAll('*').remove()\n    viewbox.style('cursor', 'default')\n    elSelected = null\n  }\n\n  // transform string to array [translateX,translateY,rotateDeg,rotateX,rotateY,scale]\n  function parseTransform(string) {\n    if (!string) {return [0, 0, 0, 0, 0, 1]}\n    const a = string.replace(/[a-z()]/g, '').replace(/[ ]/g, ',').split(',')\n    return [a[0] || 0, a[1] || 0, a[2] || 0, a[3] || 0, a[4] || 0, a[5] || 1]\n  }\n\n  // generic function to move any burg to any group\n  function moveBurgToGroup(id, g) {\n    $('#burgLabels [data-id=' + id + ']').detach().appendTo($('#burgLabels > #' + g))\n    $('#burgIcons [data-id=' + id + ']').detach().appendTo($('#burgIcons > #' + g))\n    const rSize = $('#burgIcons > #' + g).attr('size')\n    $('#burgIcons [data-id=' + id + ']').attr('r', rSize)\n    const el = $('#icons g[id*=\\'anchors\\'] [data-id=' + id + ']')\n    if (el.length) {\n      const to = g === 'towns' ? $('#town-anchors') : $('#capital-anchors')\n      el.detach().appendTo(to)\n      const useSize = to.attr('size')\n      const x = _.round(manors[id].x - useSize * 0.47, 2)\n      const y = _.round(manors[id].y - useSize * 0.47, 2)\n      el.attr('x', x).attr('y', y).attr('width', useSize).attr('height', useSize)\n    }\n    updateCountryEditors()\n  }\n\n  // generate cultures for a new map based on options and namesbase\n  function generateCultures() {\n    const count = +culturesInput.value\n    cultures = d3.shuffle(defaultCultures).slice(0, count)\n    const centers = d3.range(cultures.length).map(function(d, i) {\n      const x = Math.floor(Math.random() * graphWidth * 0.8 + graphWidth * 0.1)\n      const y = Math.floor(Math.random() * graphHeight * 0.8 + graphHeight * 0.1)\n      const center = [x, y]\n      cultures[i].center = center\n      return center\n    })\n    cultureTree = d3.quadtree(centers)\n  }\n\n  function manorsAndRegions() {\n    console.group('manorsAndRegions')\n    calculateChains()\n    rankPlacesGeography()\n    locateCapitals()\n    generateMainRoads()\n    rankPlacesEconomy()\n    locateTowns()\n    getNames()\n    shiftSettlements()\n    checkAccessibility()\n    defineRegions('withCultures')\n    generatePortRoads()\n    generateSmallRoads()\n    generateOceanRoutes()\n    calculatePopulation()\n    drawManors()\n    drawRegions()\n    console.groupEnd('manorsAndRegions')\n  }\n\n  // Assess cells geographycal suitability for settlement\n  function rankPlacesGeography() {\n    console.time('rankPlacesGeography')\n    land.map(function(c) {\n      let score = 0\n      c.flux = _.round(c.flux, 2)\n      // get base score from height (will be biom)\n      if (c.height <= 40) score = 2\n      else if (c.height <= 50) score = 1.8\n      else if (c.height <= 60) score = 1.6\n      else if (c.height <= 80) score = 1.4\n      score += (1 - c.height / 100) / 3\n      if (c.ctype && Math.random() < 0.8 && !c.river) {\n        c.score = 0 // ignore 80% of extended cells\n      } else {\n        if (c.harbor) {\n          if (c.harbor === 1) {score += 1} else {score -= 0.3} // good sea harbor is valued\n        }\n        if (c.river) score += 1 // coastline is valued\n        if (c.river && c.ctype === 1) score += 1 // estuary is valued\n        if (c.flux > 1) score += Math.pow(c.flux, 0.3) // riverbank is valued\n        if (c.confluence) score += Math.pow(c.confluence, 0.7) // confluence is valued;\n        const neighbEv = c.neighbors.map(\n          function(n) {if (cells[n].height >= 20) return cells[n].height})\n        const difEv = c.height - d3.mean(neighbEv)\n        // if (!isNaN(difEv)) score += difEv * 10 * (1 - c.height / 100); // local height maximums are valued\n      }\n      c.score = _.round(Math.random() * score + score, 3) // add random factor\n    })\n    land.sort(function(a, b) {return b.score - a.score})\n    console.timeEnd('rankPlacesGeography')\n  }\n\n  // Assess the cells economical suitability for settlement\n  function rankPlacesEconomy() {\n    console.time('rankPlacesEconomy')\n    land.map(function(c) {\n      let score = c.score\n      let path = c.path || 0 // roads are valued\n      if (path) {\n        path = Math.pow(path, 0.2)\n        const crossroad = c.crossroad || 0 // crossroads are valued\n        score = score + path + crossroad\n      }\n      c.score = _.round(Math.random() * score + score, 2) // add random factor\n    })\n    land.sort(function(a, b) {return b.score - a.score})\n    console.timeEnd('rankPlacesEconomy')\n  }\n\n  // calculate population for manors, cells and states\n  function calculatePopulation() {\n    // neutral population factors < 1 as neutral lands are usually pretty wild\n    const ruralFactor = 0.5, urbanFactor = 0.9\n\n    // calculate population for each burg (based on trade/people attractors)\n    manors.map(function(m) {\n      const cell = cells[m.cell]\n      let score = cell.score\n      if (score <= 0) {score = _.round(Math.random(), 2)}\n      if (cell.crossroad) {score += cell.crossroad} // crossroads\n      if (cell.confluence) {score += Math.pow(cell.confluence, 0.3)} // confluences\n      if (m.i !== m.region && cell.port) {score *= 1.5} // ports (not capital)\n      if (m.i === m.region && !cell.port) {score *= 2} // land-capitals\n      if (m.i === m.region && cell.port) {score *= 3} // port-capitals\n      if (m.region === 'neutral') score *= urbanFactor\n      const rnd = 0.6 + Math.random() * 0.8 // random factor\n      m.population = _.round(score * rnd, 1)\n    })\n\n    // calculate rural population for each cell based on area + elevation (elevation to be changed to biome)\n    const graphSizeAdj = 90 / Math.sqrt(cells.length, 2) // adjust to different graphSize\n    land.map(function(l) {\n      let population = 0\n      const elevationFactor = Math.pow(1 - l.height / 100, 3)\n      population = elevationFactor * l.area * graphSizeAdj\n      if (l.region === 'neutral') population *= ruralFactor\n      l.pop = _.round(population, 1)\n    })\n\n    // calculate population for each region\n    states.map(function(s, i) {\n      // define region burgs count\n      const burgs = $.grep(manors, function(e) {\n        return e.region === i\n      })\n      s.burgs = burgs.length\n      // define region total and burgs population\n      let burgsPop = 0 // get summ of all burgs population\n      burgs.map(function(b) {burgsPop += b.population})\n      s.urbanPopulation = _.round(burgsPop, 2)\n      const regionCells = $.grep(cells, function(e) {\n        return e.region === i\n      })\n      let cellsPop = 0\n      regionCells.map(function(c) {cellsPop += c.pop})\n      s.cells = regionCells.length\n      s.ruralPopulation = _.round(cellsPop, 1)\n    })\n\n    // collect data for neutrals\n    const neutralCells = $.grep(cells, function(e) {return e.region === 'neutral'})\n    if (neutralCells.length) {\n      let burgs = 0, urbanPopulation = 0, ruralPopulation = 0, area = 0\n      manors.forEach(function(m) {\n        if (m.region !== 'neutral') return\n        urbanPopulation += m.population\n        burgs++\n      })\n      neutralCells.forEach(function(c) {\n        ruralPopulation += c.pop\n        area += cells[c.index].area\n      })\n      states.push({\n        i: states.length, color: 'neutral', name: 'Neutrals', capital: 'neutral',\n        cells: neutralCells.length, burgs, urbanPopulation: _.round(urbanPopulation, 2),\n        ruralPopulation: _.round(ruralPopulation, 2), area: Math.round(area)\n      })\n    }\n  }\n\n  function locateCapitals() {\n    console.time('locateCapitals')\n    // min distance detween capitals\n    const count = +regionsInput.value\n    let spacing = (graphWidth + graphHeight) / 2 / count\n    console.log(' states: ' + count)\n\n    for (let l = 0; manors.length < count; l++) {\n      const region = manors.length\n      const x = land[l].data[0], y = land[l].data[1]\n      let minDist = 10000 // dummy value\n      for (let c = 0; c < manors.length; c++) {\n        const dist = Math.hypot(x - manors[c].x, y - manors[c].y)\n        if (dist < minDist) minDist = dist\n        if (minDist < spacing) break\n      }\n      if (minDist >= spacing) {\n        const cell = land[l].index\n        const closest = cultureTree.find(x, y)\n        const culture = getCultureId(closest)\n        manors.push({i: region, cell, x, y, region, culture})\n      }\n      if (l === land.length - 1) {\n        console.error(\n          'Cannot place capitals with current spacing. Trying again with reduced spacing')\n        l = -1, manors = [], spacing /= 1.2\n      }\n    }\n\n    // For each capital create a country\n    const scheme = count <= 8 ? colors8 : colors20\n    const mod = +powerInput.value\n    manors.forEach(function(m, i) {\n      const power = _.round(Math.random() * mod / 2 + 1, 1)\n      const color = scheme(i / count)\n      states.push({i, color, power, capital: i})\n      const p = cells[m.cell]\n      p.manor = i\n      p.region = i\n      p.culture = m.culture\n    })\n    console.timeEnd('locateCapitals')\n  }\n\n  function locateTowns() {\n    console.time('locateTowns')\n    const count = +manorsInput.value\n    const neutral = +neutralInput.value\n    const manorTree = d3.quadtree()\n    manors.forEach(function(m) {manorTree.add([m.x, m.y])})\n\n    for (let l = 0; manors.length < count && l < land.length; l++) {\n      const x = land[l].data[0], y = land[l].data[1]\n      const c = manorTree.find(x, y)\n      const d = Math.hypot(x - c[0], y - c[1])\n      if (d < 6) continue\n      const cell = land[l].index\n      let region = 'neutral', culture = -1, closest = neutral\n      for (let c = 0; c < states.length; c++) {\n        let dist = Math.hypot(manors[c].x - x, manors[c].y - y) / states[c].power\n        const cap = manors[c].cell\n        if (cells[cell].fn !== cells[cap].fn) dist *= 3\n        if (dist < closest) {\n          region = c\n          closest = dist\n        }\n      }\n      if (closest > neutral / 5 || region === 'neutral') {\n        const closestCulture = cultureTree.find(x, y)\n        culture = getCultureId(closestCulture)\n      } else {\n        culture = manors[region].culture\n      }\n      land[l].manor = manors.length\n      land[l].culture = culture\n      land[l].region = region\n      manors.push({i: manors.length, cell, x, y, region, culture})\n      manorTree.add([x, y])\n    }\n    if (manors.length < count) {\n      const error = 'Cannot place all burgs. Requested ' + count + ', placed ' + manors.length\n      console.error(error)\n    }\n    console.timeEnd('locateTowns')\n  }\n\n  // shift settlements from cell point\n  function shiftSettlements() {\n    for (let i = 0; i < manors.length; i++) {\n      const capital = i < regionsInput.value\n      const cell = cells[manors[i].cell]\n      let x = manors[i].x, y = manors[i].y\n      if ((capital && cell.harbor) || cell.harbor === 1) {\n        // port: capital with any harbor and towns with good harbors\n        if (cell.haven === undefined) {\n          cell.harbor = undefined\n        } else {\n          cell.port = cells[cell.haven].fn\n          x = cell.coastX\n          y = cell.coastY\n        }\n      }\n      if (cell.river && cell.type !== 1) {\n        let shift = 0.2 * cell.flux\n        if (shift < 0.2) shift = 0.2\n        if (shift > 1) shift = 1\n        shift = Math.random() > .5 ? shift : shift * -1\n        x = _.round(x + shift, 2)\n        shift = Math.random() > .5 ? shift : shift * -1\n        y = _.round(y + shift, 2)\n      }\n      cell.data[0] = manors[i].x = x\n      cell.data[1] = manors[i].y = y\n    }\n  }\n\n  // Validate each island with manors has port\n  function checkAccessibility() {\n    console.time('checkAccessibility')\n    for (let f = 0; f < features.length; f++) {\n      if (!features[f].land) continue\n      const manorsOnIsland = $.grep(land, function(e) {\n        return e.manor !== undefined && e.fn === f\n      })\n      if (!manorsOnIsland.length) continue\n\n      // if lake port is the only port on lake, remove port\n      const lakePorts = $.grep(manorsOnIsland, function(p) {\n        return p.port && !features[p.port].border\n      })\n      if (lakePorts.length) {\n        const lakes = []\n        lakePorts.forEach(function(p) {lakes[p.port] = lakes[p.port] ? lakes[p.port] + 1 : 1})\n        lakePorts.forEach(function(p) {if (lakes[p.port] === 1) p.port = undefined})\n      }\n\n      // check how many ocean ports are there on island\n      const oceanPorts = $.grep(manorsOnIsland, function(p) {\n        return p.port && features[p.port].border\n      })\n      if (oceanPorts.length) continue\n      const portCandidates = $.grep(manorsOnIsland, function(c) {\n        return c.harbor && features[cells[c.harbor].fn].border && c.ctype === 1\n      })\n      if (portCandidates.length) {\n        // No ports on island. Upgrading first burg to port\n        const candidate = portCandidates[0]\n        candidate.harbor = 1\n        candidate.port = cells[candidate.haven].fn\n        const manor = manors[portCandidates[0].manor]\n        candidate.data[0] = manor.x = candidate.coastX\n        candidate.data[1] = manor.y = candidate.coastY\n        // add score for each burg on island (as it's the only port)\n        candidate.score += Math.floor((portCandidates.length - 1) / 2)\n      } else {\n        // No ports on island. Reducing score for burgs\n        manorsOnIsland.forEach(function(e) {e.score -= 2})\n      }\n    }\n    console.timeEnd('checkAccessibility')\n  }\n\n  function generateMainRoads() {\n    console.time('generateMainRoads')\n    lineGen.curve(d3.curveBasis)\n    if (states.length < 2 || manors.length < 2) return\n    for (let f = 0; f < features.length; f++) {\n      if (!features[f].land) continue\n      const manorsOnIsland = $.grep(land,\n        function(e) {return e.manor !== undefined && e.fn === f})\n      if (manorsOnIsland.length > 1) {\n        for (let d = 1; d < manorsOnIsland.length; d++) {\n          for (let m = 0; m < d; m++) {\n            const path = findLandPath(manorsOnIsland[d].index, manorsOnIsland[m].index, 'main')\n            restorePath(manorsOnIsland[m].index, manorsOnIsland[d].index, 'main', path)\n          }\n        }\n      }\n    }\n    console.timeEnd('generateMainRoads')\n  }\n\n  // add roads from port to capital if capital is not a port\n  function generatePortRoads() {\n    console.time('generatePortRoads')\n    if (!states.length || manors.length < 2) return\n    const portless = []\n    for (let s = 0; s < states.length; s++) {\n      const cell = manors[s].cell\n      if (cells[cell].port === undefined) portless.push(s)\n    }\n    for (let l = 0; l < portless.length; l++) {\n      const ports = $.grep(land,\n        function(l) {return l.port !== undefined && l.region === portless[l]})\n      if (!ports.length) continue\n      let minDist = 1000, end = -1\n      ports.map(function(p) {\n        const dist = Math.hypot(e.data[0] - p.data[0], e.data[1] - p.data[1])\n        if (dist < minDist && dist > 1) {\n          minDist = dist\n          end = p.index\n        }\n      })\n      if (end !== -1) {\n        const start = manors[portless[l]].cell\n        const path = findLandPath(start, end, 'direct')\n        restorePath(end, start, 'main', path)\n      }\n    }\n    console.timeEnd('generatePortRoads')\n  }\n\n  function generateSmallRoads() {\n    console.time('generateSmallRoads')\n    if (manors.length < 2) return\n    for (let f = 0; f < features.length; f++) {\n      const manorsOnIsland = $.grep(land, function(e) {\n        return e.manor !== undefined && e.fn === f\n      })\n      const l = manorsOnIsland.length\n      if (l > 1) {\n        const secondary = Math.round((l + 8) / 10)\n        for (let s = 0; s < secondary; s++) {\n          var start = manorsOnIsland[Math.floor(Math.random() * l)].index\n          var end = manorsOnIsland[Math.floor(Math.random() * l)].index\n          var dist = Math.hypot(cells[start].data[0] - cells[end].data[0],\n            cells[start].data[1] - cells[end].data[1])\n          if (dist > 10) {\n            var path = findLandPath(start, end, 'direct')\n            restorePath(end, start, 'small', path)\n          }\n        }\n        manorsOnIsland.map(function(e, d) {\n          if (!e.path && d > 0) {\n            const start = e.index\n            let end = -1\n            const road = $.grep(land, function(e) {\n              return e.path && e.fn === f\n            })\n            if (road.length > 0) {\n              let minDist = 10000\n              road.map(function(i) {\n                const dist = Math.hypot(e.data[0] - i.data[0], e.data[1] - i.data[1])\n                if (dist < minDist) {\n                  minDist = dist\n                  end = i.index\n                }\n              })\n            } else {\n              end = manorsOnIsland[0].index\n            }\n            const path = findLandPath(start, end, 'main')\n            restorePath(end, start, 'small', path)\n          }\n        })\n      }\n    }\n    console.timeEnd('generateSmallRoads')\n  }\n\n  function generateOceanRoutes() {\n    console.time('generateOceanRoutes')\n    lineGen.curve(d3.curveBasis)\n    const cAnchors = icons.selectAll('#capital-anchors')\n    const tAnchors = icons.selectAll('#town-anchors')\n    const cSize = cAnchors.attr('size') || 2\n    const tSize = tAnchors.attr('size') || 1\n\n    const ports = []\n    // groups all ports on water feature\n    for (let m = 0; m < manors.length; m++) {\n      const cell = manors[m].cell\n      const port = cells[cell].port\n      if (port === undefined) continue\n      if (ports[port] === undefined) ports[port] = []\n      ports[port].push(cell)\n\n      // draw anchor icon\n      const group = m < states.length ? cAnchors : tAnchors\n      const size = m < states.length ? cSize : tSize\n      const x = _.round(cells[cell].data[0] - size * 0.47, 2)\n      const y = _.round(cells[cell].data[1] - size * 0.47, 2)\n      group.append('use').attr('xlink:href', '#icon-anchor').attr('data-id', m)\n           .attr('x', x).attr('y', y).attr('width', size).attr('height', size)\n      icons.selectAll('use').on('click', editIcon)\n    }\n\n    for (let w = 0; w < ports.length; w++) {\n      if (!ports[w]) continue\n      if (ports[w].length < 2) continue\n      const onIsland = []\n      for (let i = 0; i < ports[w].length; i++) {\n        const cell = ports[w][i]\n        const fn = cells[cell].fn\n        if (onIsland[fn] === undefined) onIsland[fn] = []\n        onIsland[fn].push(cell)\n      }\n\n      for (let fn = 0; fn < onIsland.length; fn++) {\n        if (!onIsland[fn]) continue\n        if (onIsland[fn].length < 2) continue\n        const start = onIsland[fn][0]\n        const paths = findOceanPaths(start, -1)\n\n        for (let h = 1; h < onIsland[fn].length; h++) {\n          // routes from all ports on island to 1st port on island\n          restorePath(onIsland[fn][h], start, 'ocean', paths)\n        }\n\n        // inter-island routes\n        for (let c = fn + 1; c < onIsland.length; c++) {\n          if (!onIsland[c]) continue\n          if (!onIsland[c].length) continue\n          if (onIsland[fn].length > 3) {\n            const end = onIsland[c][0]\n            restorePath(end, start, 'ocean', paths)\n          }\n        }\n\n        if (features[w].border && !features[fn].border && onIsland[fn].length > 5) {\n          // encircle the island\n          onIsland[fn].sort(function(a, b) {return cells[b].cost - cells[a].cost})\n          for (let a = 2; a < onIsland[fn].length && a < 10; a++) {\n            const from = onIsland[fn][1], to = onIsland[fn][a]\n            const dist = Math.hypot(cells[from].data[0] - cells[to].data[0],\n              cells[from].data[1] - cells[to].data[1])\n            const distPath = getPathDist(from, to)\n            if (distPath > dist * 4 + 10) {\n              const totalCost = cells[from].cost + cells[to].cost\n              const pathsAdd = findOceanPaths(from, to)\n              if (cells[to].cost < totalCost) {\n                restorePath(to, from, 'ocean', pathsAdd)\n                break\n              }\n            }\n          }\n        }\n\n      }\n\n    }\n    console.timeEnd('generateOceanRoutes')\n  }\n\n  function findLandPath(start, end, type) {\n    // A* algorithm\n    const queue = new PriorityQueue({\n      comparator: function(a, b) {\n        return a.p - b.p\n      }\n    })\n    const cameFrom = []\n    const costTotal = []\n    costTotal[start] = 0\n    queue.queue({e: start, p: 0})\n    while (queue.length > 0) {\n      const next = queue.dequeue().e\n      if (next === end) {break}\n      const pol = cells[next]\n      pol.neighbors.forEach(function(e) {\n        if (cells[e].height >= 20) {\n          let cost = cells[e].height / 100 * 2\n          if (cells[e].path && type === 'main') {\n            cost = 0.15\n          } else {\n            if (typeof e.manor === 'undefined') {cost += 0.1}\n            if (typeof e.river !== 'undefined') {cost -= 0.1}\n            if (cells[e].harbor) {cost *= 0.3}\n            if (cells[e].path) {cost *= 0.5}\n            cost +=\n              Math.hypot(cells[e].data[0] - pol.data[0], cells[e].data[1] - pol.data[1]) / 30\n          }\n          const costNew = costTotal[next] + cost\n          if (!cameFrom[e] || costNew < costTotal[e]) { //\n            costTotal[e] = costNew\n            cameFrom[e] = next\n            const dist = Math.hypot(cells[e].data[0] - cells[end].data[0],\n              cells[e].data[1] - cells[end].data[1]) / 15\n            const priority = costNew + dist\n            queue.queue({e, p: priority})\n          }\n        }\n      })\n    }\n    return cameFrom\n  }\n\n  function findOceanPaths(start, end) {\n    const queue = new PriorityQueue({comparator: function(a, b) {return a.p - b.p}})\n    let next\n    const cameFrom = [], costTotal = []\n    cameFrom[start] = 'no', costTotal[start] = 0\n    queue.queue({e: start, p: 0})\n    while (queue.length > 0 && next !== end) {\n      next = queue.dequeue().e\n      const pol = cells[next]\n      pol.neighbors.forEach(function(e) {\n        if (cells[e].ctype < 0 || cells[e].haven === next) {\n          let cost = 1\n          if (cells[e].ctype > 0) cost += 100\n          if (cells[e].ctype < -1) {\n            const dist = Math.hypot(cells[e].data[0] - pol.data[0],\n              cells[e].data[1] - pol.data[1])\n            cost += 50 + dist * 2\n          }\n          if (cells[e].path && cells[e].ctype < 0) cost *= 0.8\n          const costNew = costTotal[next] + cost\n          if (!cameFrom[e]) {\n            costTotal[e] = costNew\n            cells[e].cost = costNew\n            cameFrom[e] = next\n            queue.queue({e, p: costNew})\n          }\n        }\n      })\n    }\n    return cameFrom\n  }\n\n  function getPathDist(start, end) {\n    const queue = new PriorityQueue({\n      comparator: function(a, b) {\n        return a.p - b.p\n      }\n    })\n    let next, costNew\n    const cameFrom = []\n    const costTotal = []\n    cameFrom[start] = 'no'\n    costTotal[start] = 0\n    queue.queue({e: start, p: 0})\n    while (queue.length > 0 && next !== end) {\n      next = queue.dequeue().e\n      const pol = cells[next]\n      pol.neighbors.forEach(function(e) {\n        if (cells[e].path && (cells[e].ctype === -1 || cells[e].haven === next)) {\n          const dist = Math.hypot(cells[e].data[0] - pol.data[0], cells[e].data[1] - pol.data[1])\n          costNew = costTotal[next] + dist\n          if (!cameFrom[e]) {\n            costTotal[e] = costNew\n            cameFrom[e] = next\n            queue.queue({e, p: costNew})\n          }\n        }\n      })\n    }\n    return costNew\n  }\n\n  function restorePath(end, start, type, from) {\n    let path = [], current = end\n    const limit = 1000\n    let prev = cells[end]\n    if (type === 'ocean' || !prev.path) {\n      path.push({scX: prev.data[0], scY: prev.data[1], i: end})\n    }\n    if (!prev.path) {prev.path = 1}\n    for (let i = 0; i < limit; i++) {\n      current = from[current]\n      let cur = cells[current]\n      if (!cur) {break}\n      if (cur.path) {\n        cur.path += 1\n        path.push({scX: cur.data[0], scY: cur.data[1], i: current})\n        prev = cur\n        drawPath()\n      } else {\n        cur.path = 1\n        if (prev) {path.push({scX: prev.data[0], scY: prev.data[1], i: prev.index})}\n        prev = undefined\n        path.push({scX: cur.data[0], scY: cur.data[1], i: current})\n      }\n      if (current === start || !from[current]) {break}\n    }\n    drawPath()\n\n    function drawPath() {\n      if (path.length > 1) {\n        // mark crossroades\n        if (type === 'main' || type === 'small') {\n          const plus = type === 'main' ? 4 : 2\n          const f = cells[path[0].i]\n          if (f.path > 1) {\n            if (!f.crossroad) {f.crossroad = 0}\n            f.crossroad += plus\n          }\n          const t = cells[(path[path.length - 1].i)]\n          if (t.path > 1) {\n            if (!t.crossroad) {t.crossroad = 0}\n            t.crossroad += plus\n          }\n        }\n        // draw path segments\n        let line = lineGen(path)\n        line = round(line, 1)\n        let id = 0 // to create unique route id\n        if (type === 'main') {\n          id = roads.selectAll('path').size()\n          roads.append('path').attr('d', line).attr('id', 'road' + id).on('click', editRoute)\n        } else if (type === 'small') {\n          id = trails.selectAll('path').size()\n          trails.append('path').attr('d', line).attr('id', 'trail' + id).on('click', editRoute)\n        } else if (type === 'ocean') {\n          id = searoutes.selectAll('path').size()\n          searoutes.append('path').attr('d', line).attr('id', 'searoute' + id)\n                   .on('click', editRoute)\n        }\n      }\n      path = []\n    }\n  }\n\n  // Append burg elements\n  function drawManors() {\n    console.time('drawManors')\n    const capitalIcons = burgIcons.select('#capitals')\n    const capitalLabels = burgLabels.select('#capitals')\n    const townIcons = burgIcons.select('#towns')\n    const townLabels = burgLabels.select('#towns')\n    const capitalSize = capitalIcons.attr('size') || 1\n    const townSize = townIcons.attr('size') || 0.5\n    capitalIcons.selectAll('*').remove()\n    capitalLabels.selectAll('*').remove()\n    townIcons.selectAll('*').remove()\n    townLabels.selectAll('*').remove()\n\n    for (let i = 0; i < manors.length; i++) {\n      const x = manors[i].x, y = manors[i].y\n      const cell = manors[i].cell\n      const name = manors[i].name\n      const ic = i < states.length ? capitalIcons : townIcons\n      const lb = i < states.length ? capitalLabels : townLabels\n      const size = i < states.length ? capitalSize : townSize\n      ic.append('circle').attr('id', 'burg' + i).attr('data-id', i).attr('cx', x).attr('cy', y)\n        .attr('r', size).on('click', editBurg)\n      lb.append('text').attr('data-id', i).attr('x', x).attr('y', y).attr('dy', '-0.35em')\n        .text(name).on('click', editBurg)\n    }\n    console.timeEnd('drawManors')\n  }\n\n  // get settlement and country names based on option selected\n  function getNames() {\n    console.time('getNames')\n    // if names source is an external resource\n    if (namesInput.value === '1') {\n      const request = new XMLHttpRequest()\n      const url = 'https://archivist.xalops.com/archivist-core/api/name/settlement?count='\n      request.open('GET', url + manors.length, true)\n      request.onload = function() {\n        const names = JSON.parse(request.responseText)\n        for (let i = 0; i < manors.length; i++) {\n          manors[i].name = names[i]\n          burgLabels.select('[data-id=\\'' + i + '\\']').text(names[i])\n          if (i < states.length) {\n            states[i].name = generateStateName(i)\n            labels.select('#countries').select('#regionLabel' + i).text(states[i].name)\n          }\n        }\n        console.log(names)\n      }\n      request.send(null)\n    }\n\n    if (namesInput.value !== '0') return\n    for (let i = 0; i < manors.length; i++) {\n      const culture = manors[i].culture\n      manors[i].name = generateName(culture)\n      if (i < states.length) states[i].name = generateStateName(i)\n    }\n    console.timeEnd('getNames')\n  }\n\n  function calculateChains() {\n    for (let c = 0; c < nameBase.length; c++) {\n      chain[c] = calculateChain(c)\n    }\n  }\n\n  // calculate Markov's chain from namesbase data\n  function calculateChain(c) {\n    const chain = []\n    const d = nameBase[c].join(' ').toLowerCase()\n    const method = nameBases[c].method\n\n    for (let i = -1, prev = ' ', str = ''; i < d.length - 2; prev = str, i += str.length, str =\n      '') {\n      let vowel = 0, f = ' '\n      if (method === 'let-to-let') {str = d[i + 1]} else {\n        for (let c = i + 1; str.length < 5; c++) {\n          if (d[c] === undefined) break\n          str += d[c]\n          if (str === ' ') break\n          if (d[c] !== 'o' && d[c] !== 'e' && VOWELS.includes(d[c]) && d[c + 1] === d[c]) break\n          if (d[c + 2] === ' ') {\n            str += d[c + 1]\n            break\n          }\n          if (VOWELS.includes(d[c])) vowel++\n          if (vowel && VOWELS.includes(d[c + 2])) break\n        }\n      }\n      if (i >= 0) {\n        f = d[i]\n        if (method === 'syl-to-syl') f = prev\n      }\n      if (chain[f] === undefined) chain[f] = []\n      chain[f].push(str)\n    }\n    return chain\n  }\n\n  // generate random name using Markov's chain\n  function generateName(culture, base) {\n    if (base === undefined) {\n      if (!cultures[culture]) {\n        console.error('culture ' + culture + ' is not defined. Will load default cultures and set first culture')\n        generateCultures()\n        culture = 0\n      }\n      base = cultures[culture].base\n    }\n    if (!nameBases[base]) {\n      console.error('nameBase ' + base + ' is not defined. Will load default names data and first base')\n      if (!nameBases[0]) applyDefaultNamesData()\n      base = 0\n    }\n    const method = nameBases[base].method\n    const error = function(base) {\n      tip('Names data for base ' + nameBases[base].name + ' is incorrect. Please fix in Namesbase Editor')\n      editNamesbase()\n    }\n\n    if (method === 'selection') {\n      if (nameBase[base].length < 1) {\n        error(base)\n        return\n      }\n      const rnd = _.random(nameBase[base].length - 1)\n      return nameBase[base][rnd]\n    }\n\n    const data = chain[base]\n    if (data === undefined || data[' '] === undefined) {\n      error(base)\n      return\n    }\n    const max = nameBases[base].max\n    const min = nameBases[base].min\n    const d = nameBases[base].d\n    let word = '', variants = data[' ']\n    if (variants === undefined) {\n      error(base)\n      return\n    }\n    let cur = variants[_.random(variants.length - 1)]\n    for (let i = 0; i < 21; i++) {\n      if (cur === ' ' && Math.random() < 0.8) {\n        // space means word end, but we don't want to end if word is too short\n        if (word.length < min) {\n          word = ''\n          variants = data[' ']\n        } else {break}\n      } else {\n        const l = method === 'let-to-syl' && cur.length > 1 ? cur[cur.length - 1] : cur\n        variants = data[l]\n        // word is getting too long, restart\n        word += cur // add current el to word\n        if (word.length > max) word = ''\n      }\n      if (variants === undefined) {\n        error(base)\n        return\n      }\n      cur = variants[_.random(variants.length - 1)]\n    }\n    // very rare case, let's just select a random name\n    if (word.length < 2) word = nameBase[base][_.random(nameBase[base].length - 1)]\n\n    // do not allow multi-word name if word is foo short or not allowed for culture\n    if (word.includes(' ')) {\n      let words = word.split(' ')\n      if (Math.random() > nameBases[base].m) {word = words.join('')} else {\n        for (let i = 0; i < words.length; i++) {\n          if (words[i].length < 2) {\n            if (!i) words[1] = words[0] + words[1]\n            if (i) words[i - 1] += words[i]\n            words.splice(i, 1)\n            i--\n          }\n        }\n        word = words.join(' ')\n      }\n    }\n\n    // parse word to get a final name\n    return [...word].reduce(function(r, c, i, data) {\n      if (c === ' ') {\n        if (!r.length) return ''\n        if (i + 1 === data.length) return r\n      }\n      if (!r.length) return c.toUpperCase()\n      if (r.slice(-1) === ' ') return r + c.toUpperCase()\n      if (c === data[i - 1]) {\n        if (!d.includes(c)) return r\n        if (c === data[i - 2]) return r\n      }\n      return r + c\n    }, '')\n  }\n\n  // Define areas based on the closest manor to a polygon\n  function defineRegions(withCultures) {\n    console.time('defineRegions')\n    const manorTree = d3.quadtree()\n    manors.forEach(function(m) {if (m.region !== 'removed') manorTree.add([m.x, m.y])})\n\n    const neutral = +neutralInput.value\n    land.forEach(function(i) {\n      if (i.manor !== undefined && manors[i.manor].region !== 'removed') {\n        i.region = manors[i.manor].region\n        if (withCultures && manors[i.manor].culture !== undefined) i.culture =\n          manors[i.manor].culture\n        return\n      }\n      const x = i.data[0], y = i.data[1]\n\n      let dist = 100000, manor = null\n      if (manors.length) {\n        const c = manorTree.find(x, y)\n        dist = Math.hypot(c[0] - x, c[1] - y)\n        manor = getManorId(c)\n      }\n      if (dist > neutral / 2 || manor === null) {\n        i.region = 'neutral'\n        if (withCultures) {\n          const closestCulture = cultureTree.find(x, y)\n          i.culture = getCultureId(closestCulture)\n        }\n      } else {\n        const cell = manors[manor].cell\n        if (cells[cell].fn !== i.fn) {\n          let minDist = dist * 3\n          land.forEach(function(l) {\n            if (l.fn === i.fn && l.manor !== undefined) {\n              if (manors[l.manor].region === 'removed') return\n              const distN = Math.hypot(l.data[0] - x, l.data[1] - y)\n              if (distN < minDist) {\n                minDist = distN\n                manor = l.manor\n              }\n            }\n          })\n        }\n        i.region = manors[manor].region\n        if (withCultures) i.culture = manors[manor].culture\n      }\n    })\n    console.timeEnd('defineRegions')\n  }\n\n  // Define areas cells\n  function drawRegions() {\n    console.time('drawRegions')\n    labels.select('#countries').selectAll('*').remove()\n\n    // arrays to store edge data\n    const edges = [], coastalEdges = [], borderEdges = [], neutralEdges = []\n    for (let a = 0; a < states.length; a++) {\n      edges[a] = []\n      coastalEdges[a] = []\n    }\n    const e = diagram.edges\n    for (let i = 0; i < e.length; i++) {\n      if (e[i] === undefined) continue\n      const start = e[i][0].join(' ')\n      const end = e[i][1].join(' ')\n      const p = {start, end}\n      if (e[i].left === undefined) {\n        const r = e[i].right.index\n        const rr = cells[r].region\n        if (Number.isInteger(rr)) edges[rr].push(p)\n        continue\n      }\n      if (e[i].right === undefined) {\n        const l = e[i].left.index\n        const lr = cells[l].region\n        if (Number.isInteger(lr)) edges[lr].push(p)\n        continue\n      }\n      const l = e[i].left.index\n      const r = e[i].right.index\n      const lr = cells[l].region\n      const rr = cells[r].region\n      if (lr === rr) continue\n      if (Number.isInteger(lr)) {\n        edges[lr].push(p)\n        if (rr === undefined) {\n          coastalEdges[lr].push(p)\n        } else if (rr === 'neutral') {neutralEdges.push(p)}\n      }\n      if (Number.isInteger(rr)) {\n        edges[rr].push(p)\n        if (lr === undefined) {\n          coastalEdges[rr].push(p)\n        } else if (lr === 'neutral') {neutralEdges.push(p)} else if (Number.isInteger(\n          lr)) {borderEdges.push(p)}\n      }\n    }\n    edges.map(function(e, i) {\n      if (e.length) {\n        drawRegion(e, i)\n        drawRegionCoast(coastalEdges[i], i)\n      }\n    })\n    drawBorders(borderEdges, 'state')\n    drawBorders(neutralEdges, 'neutral')\n    console.timeEnd('drawRegions')\n  }\n\n  function drawRegion(edges, region) {\n    let path = ''\n    const array = []\n    lineGen.curve(d3.curveLinear)\n    while (edges.length > 2) {\n      const edgesOrdered = [] // to store points in a correct order\n      const start = edges[0].start\n      let end = edges[0].end\n      edges.shift()\n      let spl = start.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      spl = end.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      for (let i = 0; end !== start && i < 2000; i++) {\n        const next = $.grep(edges, function(e) {\n          return (e.start == end || e.end == end)\n        })\n        if (next.length > 0) {\n          if (next[0].start == end) {\n            end = next[0].end\n          } else if (next[0].end == end) {\n            end = next[0].start\n          }\n          spl = end.split(' ')\n          edgesOrdered.push({scX: spl[0], scY: spl[1]})\n        }\n        const rem = edges.indexOf(next[0])\n        edges.splice(rem, 1)\n      }\n      path += lineGen(edgesOrdered) + 'Z '\n      array[array.length] = edgesOrdered.map(function(e) {return [+e.scX, +e.scY]})\n    }\n    const color = states[region].color\n    regions.append('path').attr('d', round(path, 1)).attr('fill', color)\n           .attr('class', 'region' + region)\n    array.sort(function(a, b) {return b.length - a.length})\n    let capital = states[region].capital\n    // add capital cell as a hole\n    if (!isNaN(capital)) {\n      const capitalCell = manors[capital].cell\n      array.push(polygons[capitalCell])\n    }\n    const name = states[region].name\n    const c = polylabel(array, 1.0) // pole of inaccessibility\n    labels.select('#countries').append('text').attr('id', 'regionLabel' + region)\n          .attr('x', Math.round(c[0])).attr('y', Math.round(c[1])).text(name).on('click', editLabel)\n    states[region].area = Math.round(Math.abs(d3.polygonArea(array[0]))) // define region area\n  }\n\n  function drawRegionCoast(edges, region) {\n    let path = ''\n    while (edges.length > 0) {\n      const edgesOrdered = [] // to store points in a correct order\n      const start = edges[0].start\n      let end = edges[0].end\n      edges.shift()\n      let spl = start.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      spl = end.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      let next = $.grep(edges, function(e) {\n        return (e.start == end || e.end == end)\n      })\n      while (next.length > 0) {\n        if (next[0].start == end) {\n          end = next[0].end\n        } else if (next[0].end == end) {\n          end = next[0].start\n        }\n        spl = end.split(' ')\n        edgesOrdered.push({scX: spl[0], scY: spl[1]})\n        const rem = edges.indexOf(next[0])\n        edges.splice(rem, 1)\n        next = $.grep(edges, function(e) {return (e.start == end || e.end == end)})\n      }\n      path += lineGen(edgesOrdered)\n    }\n    const color = states[region].color\n    regions.append('path').attr('d', round(path, 1)).attr('fill', 'none').attr('stroke', color)\n           .attr('stroke-width', 5).attr('class', 'region' + region)\n  }\n\n  function drawBorders(edges, type) {\n    let path = ''\n    if (edges.length < 1) {return}\n    while (edges.length > 0) {\n      const edgesOrdered = [] // to store points in a correct order\n      const start = edges[0].start\n      let end = edges[0].end\n      edges.shift()\n      let spl = start.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      spl = end.split(' ')\n      edgesOrdered.push({scX: spl[0], scY: spl[1]})\n      let next = $.grep(edges, function(e) {\n        return (e.start == end || e.end == end)\n      })\n      while (next.length > 0) {\n        if (next[0].start == end) {\n          end = next[0].end\n        } else if (next[0].end == end) {\n          end = next[0].start\n        }\n        spl = end.split(' ')\n        edgesOrdered.push({scX: spl[0], scY: spl[1]})\n        const rem = edges.indexOf(next[0])\n        edges.splice(rem, 1)\n        next = $.grep(edges, function(e) {return (e.start == end || e.end == end)})\n      }\n      path += lineGen(edgesOrdered)\n    }\n    if (type === 'state') {stateBorders.append('path').attr('d', round(path, 1))}\n    if (type === 'neutral') {neutralBorders.append('path').attr('d', round(path, 1))}\n  }\n\n  // generate region name\n  function generateStateName(state) {\n    let culture = null\n    if (states[state]) if (manors[states[state].capital]) culture =\n      manors[states[state].capital].culture\n    let name = 'NameIdontWant'\n    if (Math.random() < 0.85 || culture === null) {\n      // culture is random if capital is not yet defined\n      if (culture === null) culture = _.random(cultures.length - 1)\n      // try to avoid too long words as a basename\n      for (let i = 0; i < 20 && name.length > 7; i++) {\n        name = generateName(culture)\n      }\n    } else {\n      name = manors[state].name\n    }\n    const base = cultures[culture].base\n\n    let addSuffix = false\n    // handle special cases\n    const e = name.slice(-2)\n    if (base === 5 && (e === 'sk' || e === 'ev' || e === 'ov')) {\n      // remove -sk and -ev/-ov for Ruthenian\n      name = name.slice(0, -2)\n      addSuffix = true\n    } else if (name.length > 5 && base === 1 && name.slice(-3) === 'ton') {\n      // remove -ton ending for English\n      name = name.slice(0, -3)\n      addSuffix = true\n    } else if (name.length > 6 && name.slice(-4) === 'berg') {\n      // remove -berg ending for any\n      name = name.slice(0, -4)\n      addSuffix = true\n    } else if (base === 12) {\n      // Japanese ends on vowels\n      if (VOWELS.includes(name.slice(-1))) return name\n      return name + 'u'\n    } else if (base === 10) {\n      // Korean has \"guk\" suffix\n      if (name.slice(-3) === 'guk') return name\n      if (name.slice(-1) === 'g') name = name.slice(0, -1)\n      if (Math.random() < 0.2 && name.length < 7) name = name + 'guk' // 20% for \"guk\"\n      return name\n    } else if (base === 11) {\n      // Chinese has \"guo\" suffix\n      if (name.slice(-3) === 'guo') return name\n      if (name.slice(-1) === 'g') name = name.slice(0, -1)\n      if (Math.random() < 0.3 && name.length < 7) name = name + ' Guo' // 30% for \"guo\"\n      return name\n    }\n\n    // define if suffix should be used\n    let vowel = VOWELS.includes(name.slice(-1)) // last char is vowel\n    if (vowel && name.length > 3) {\n      if (Math.random() < 0.85) {\n        if (VOWELS.includes(name.slice(-2, -1))) {\n          name = name.slice(0, -2)\n          addSuffix = true // 85% for vv\n        } else if (Math.random() < 0.7) {\n          name = name.slice(0, -1)\n          addSuffix = true // ~60% for cv\n        }\n      }\n    } else if (Math.random() < 0.6) {\n      addSuffix = true // 60% for cc and vc\n    }\n\n    if (addSuffix === false) return name\n    let suffix = 'ia' // common latin suffix\n    const rnd = Math.random()\n    if (rnd < 0.05 && base === 3) suffix = 'terra' // 5% \"terra\" for Italian\n    else if (rnd < 0.05 && base === 4) suffix = 'terra' // 5% \"terra\" for Spanish\n    else if (rnd < 0.05 && base == 2) suffix = 'terre' // 5% \"terre\" for French\n    else if (rnd < 0.5 && base == 0) suffix = 'land' // 50% \"land\" for German\n    else if (rnd < 0.4 && base == 1) suffix = 'land' // 40% \"land\" for English\n    else if (rnd < 0.3 && base == 6) suffix = 'land' // 30% \"land\" for Nordic\n    else if (rnd < 0.1 && base == 7) suffix = 'eia' // 10% \"eia\" for Greek (\"ia\" is also Greek)\n    else if (rnd < 0.4 && base == 9) suffix = 'maa' // 40% \"maa\" for Finnic\n    if (name.slice(-1 * suffix.length) === suffix) return name // no suffix if name already ends with it\n    if (name.slice(-1) === suffix.charAt(0)) name = name.slice(0, -1) // remove name last letter if it's a suffix first letter\n    return name + suffix\n  }\n\n  // re-calculate cultures\n  function recalculateCultures(fullRedraw) {\n    console.time('recalculateCultures')\n    // For each capital find closest culture and assign it to capital\n    states.forEach(function(s) {\n      if (s.capital === 'neutral' || s.capital === 'select') return\n      const capital = manors[s.capital]\n      const c = cultureTree.find(capital.x, capital.y)\n      capital.culture = getCultureId(c)\n    })\n\n    // For each town if distance to its capital > neutral / 2,\n    // assign closest culture to the town; else assign capital's culture\n    const manorTree = d3.quadtree()\n    const neutral = +neutralInput.value\n    manors.forEach(function(m) {\n      if (m.region === 'removed') return\n      manorTree.add([m.x, m.y])\n      if (m.region === 'neutral') {\n        const culture = cultureTree.find(m.x, m.y)\n        m.culture = getCultureId(culture)\n        return\n      }\n      const c = states[m.region].capital\n      if (c !== 'neutral' && c !== 'select') {\n        const dist = Math.hypot(m.x - manors[c].x, m.y - manors[c].y)\n        if (dist <= neutral / 5) {\n          m.culture = manors[c].culture\n          return\n        }\n      }\n      const culture = cultureTree.find(m.x, m.y)\n      m.culture = getCultureId(culture)\n    })\n\n    // For each land cell if distance to closest manor > neutral / 2,\n    // assign closest culture to the cell; else assign manors's culture\n    const changed = []\n    land.forEach(function(i) {\n      const x = i.data[0], y = i.data[1]\n      const c = manorTree.find(x, y)\n      const culture = i.culture\n      const dist = Math.hypot(c[0] - x, c[1] - y)\n      let manor = getManorId(c)\n      if (dist > neutral / 2 || manor === undefined) {\n        const closestCulture = cultureTree.find(i.data[0], i.data[1])\n        i.culture = getCultureId(closestCulture)\n      } else {\n        const cell = manors[manor].cell\n        if (cells[cell].fn !== i.fn) {\n          let minDist = dist * 3\n          land.forEach(function(l) {\n            if (l.fn === i.fn && l.manor !== undefined) {\n              if (manors[l.manor].region === 'removed') return\n              const distN = Math.hypot(l.data[0] - x, l.data[1] - y)\n              if (distN < minDist) {\n                minDist = distN\n                manor = l.manor\n              }\n            }\n          })\n        }\n        i.culture = manors[manor].culture\n      }\n      // re-color cells\n      if (i.culture !== culture || fullRedraw) {\n        const clr = cultures[i.culture].color\n        cults.select('#cult' + i.index).attr('fill', clr).attr('stroke', clr)\n      }\n    })\n    console.timeEnd('recalculateCultures')\n  }\n\n  // get culture Id from center coordinates\n  function getCultureId(c) {\n    for (let i = 0; i < cultures.length; i++) {\n      if (cultures[i].center[0] === c[0]) if (cultures[i].center[1] === c[1]) return i\n    }\n  }\n\n  // get manor Id from center coordinates\n  function getManorId(c) {\n    for (let i = 0; i < manors.length; i++) {\n      if (manors[i].x === c[0]) if (manors[i].y === c[1]) return i\n    }\n  }\n\n  // focus on coorditanes, cell or burg provided in searchParams\n  function focusOn() {\n    if (params.get('from') === 'MFCG') {\n      // focus on burg from MFCG\n      findBurgForMFCG()\n      return\n    }\n    let s = params.get('scale') || 8\n    let x = params.get('x')\n    let y = params.get('y')\n    let c = params.get('cell')\n    if (c !== null) {\n      x = cells[+c].data[0]\n      y = cells[+c].data[1]\n    }\n    let b = params.get('burg')\n    if (b !== null) {\n      x = manors[+b].x\n      y = manors[+b].y\n    }\n    if (x !== null && y !== null) zoomTo(x, y, s, 1600)\n  }\n\n  // find burg from MFCG and focus on it\n  function findBurgForMFCG() {\n    if (!manors.length) {\n      console.error('No burgs generated. Cannot select a burg for MFCG')\n      return\n    }\n    const size = +params.get('size')\n    let coast = +params.get('coast')\n    let port = +params.get('port')\n    let river = +params.get('river')\n    let selection = defineSelection(coast, port, river)\n    if (!selection.length) selection = defineSelection(coast, !port, !river)\n    if (!selection.length) selection = defineSelection(!coast, 0, !river)\n    if (!selection.length) selection = manors[0] // select first if nothing is found\n    if (!selection.length) {\n      console.error('Cannot find a burg for MFCG')\n      return\n    }\n\n    function defineSelection(coast, port, river) {\n      let selection = []\n      if (port && river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].port !== undefined && cells[e.cell].river !== undefined})\n      else if (!port && coast && river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].port === undefined && cells[e.cell].ctype === 1 && cells[e.cell].river !== undefined})\n      else if (!coast && !river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].ctype !== 1 && cells[e.cell].river === undefined})\n      else if (!coast && river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].ctype !== 1 && cells[e.cell].river !== undefined})\n      else if (coast && !river) selection = $.grep(manors,\n        function(e) {return cells[e.cell].ctype === 1 && cells[e.cell].river === undefined})\n      return selection\n    }\n\n    // select a burg with closes population from selection\n    const selected = d3.scan(selection,\n      function(a, b) {return Math.abs(a.population - size) - Math.abs(b.population - size)})\n    const burg = selection[selected].i\n    if (size && burg !== undefined) {manors[burg].population = size} else {return}\n\n    // focus on found burg\n    const label = burgLabels.select('[data-id=\\'' + burg + '\\']')\n    if (!label.size()) {\n      console.error('Cannot find a label for MFCG burg ' + burg)\n      return\n    }\n    tip('Here stands the glorious city of ' + manors[burg].name, true)\n    label.classed('drag', true).on('mouseover', function() {\n      d3.select(this).classed('drag', false)\n      tip('', true)\n    })\n    const x = +label.attr('x'), y = +label.attr('y')\n    zoomTo(x, y, 8, 1600)\n  }\n\n  // draw Cultures\n  function toggleCultures() {\n    if (cults.selectAll('path').size() == 0) {\n      land.map(function(i) {\n        const color = cultures[i.culture].color\n        cults.append('path')\n             .attr('d', 'M' + polygons[i.index].join('L') + 'Z')\n             .attr('id', 'cult' + i.index)\n             .attr('fill', color)\n             .attr('stroke', color)\n      })\n    } else {\n      cults.selectAll('path').remove()\n    }\n  }\n\n  // clean data to get rid of redundand info\n  function cleanData() {\n    console.time('cleanData')\n    cells.map(function(c) {\n      delete c.cost\n      delete c.used\n      delete c.coastX\n      delete c.coastY\n      if (c.ctype === undefined) delete c.ctype\n      if (c.lake === undefined) delete c.lake\n      c.height = Math.trunc(c.height)\n      if (c.height >= 20) c.flux = _.round(c.flux, 2)\n    })\n    // restore layers if they was turned on\n    if (!$('#toggleHeight').hasClass('buttonoff') && !terrs.selectAll('path')\n                                                           .size()) toggleHeight()\n    if (!$('#toggleCultures').hasClass('buttonoff') && !cults.selectAll('path')\n                                                             .size()) toggleCultures()\n    closeDialogs()\n    invokeActiveZooming()\n    console.timeEnd('cleanData')\n  }\n\n  // close all dialogs except stated\n  function closeDialogs(except) {\n    except = except || '#except'\n    $('.dialog:visible').not(except).each(function(e) {\n      $(this).dialog('close')\n    })\n  }\n\n  // change transparency for modal windowa\n  function changeDialogsTransparency(v) {\n    localStorage.setItem('transparency', v)\n    const alpha = (100 - +v) / 100\n    const optionsColor = 'rgba(164, 139, 149, ' + alpha + ')' // purple-red\n    const dialogsColor = 'rgba(255, 255, 255, ' + alpha + ')' // white\n    document.getElementById('options').style.backgroundColor = optionsColor\n    document.getElementById('dialogs').style.backgroundColor = dialogsColor\n  }\n\n  // Draw the water flux system (for dubugging)\n  function toggleFlux() {\n    const colorFlux = d3.scaleSequential(d3chromatic.interpolateBlues)\n    if (terrs.selectAll('path').size() == 0) {\n      land.map(function(i) {\n        terrs.append('path')\n             .attr('d', 'M' + polygons[i.index].join('L') + 'Z')\n             .attr('fill', colorFlux(0.1 + i.flux))\n             .attr('stroke', colorFlux(0.1 + i.flux))\n      })\n    } else {\n      terrs.selectAll('path').remove()\n    }\n  }\n\n  // Draw the Relief (need to create more beautiness)\n  function drawRelief() {\n    console.time('drawRelief')\n    let h, count, rnd, cx, cy, swampCount = 0\n    const hills = terrain.select('#hills')\n    const mounts = terrain.select('#mounts')\n    const swamps = terrain.select('#swamps')\n    const forests = terrain.select('#forests')\n    terrain.selectAll('g').selectAll('g').remove()\n    // sort the land to Draw the top element first (reduce the elements overlapping)\n    land.sort(compareY)\n    for (let i = 0; i < land.length; i++) {\n      if (land[i].river) continue // no icons on rivers\n      const cell = land[i].index\n      const p = d3.polygonCentroid(polygons[cell]) // polygon centroid point\n      if (p === undefined) continue // something is wrong with data\n      const height = land[i].height\n      const area = land[i].area\n      if (height >= 70) {\n        // mount icon\n        h = (height - 55) * 0.12\n        for (let c = 0, a = area; Math.random() < a / 50; c++, a -= 50) {\n          if (polygons[cell][c] === undefined) break\n          const g = mounts.append('g').attr('data-cell', cell)\n          if (c < 2) {\n            cx = p[0] - h / 100 * (1 - c / 10) - c * 2\n            cy = p[1] + h / 400 + c\n          } else {\n            const p2 = polygons[cell][c]\n            cx = (p[0] * 1.2 + p2[0] * 0.8) / 2\n            cy = (p[1] * 1.2 + p2[1] * 0.8) / 2\n          }\n          rnd = Math.random() * 0.8 + 0.2\n          let mount = 'M' + cx + ',' + cy + ' L' + (cx + h / 3 + rnd) + ',' + (cy - h / 4 - rnd * 1.2) + ' L' + (cx + h / 1.1) + ',' + (cy - h) + ' L' + (cx + h + rnd) + ',' + (cy - h / 1.2 + rnd) + ' L' + (cx + h * 2) + ',' + cy\n          let shade = 'M' + cx + ',' + cy + ' L' + (cx + h / 3 + rnd) + ',' + (cy - h / 4 - rnd * 1.2) + ' L' + (cx + h / 1.1) + ',' + (cy - h) + ' L' + (cx + h / 1.5) + ',' + cy\n          let dash = 'M' + (cx - 0.1) + ',' + (cy + 0.3) + ' L' + (cx + 2 * h + 0.1) + ',' + (cy + 0.3)\n          dash +=\n            'M' + (cx + 0.4) + ',' + (cy + 0.6) + ' L' + (cx + 2 * h - 0.3) + ',' + (cy + 0.6)\n          g.append('path').attr('d', round(mount, 1)).attr('stroke', '#5c5c70')\n          g.append('path').attr('d', round(shade, 1)).attr('fill', '#999999')\n          g.append('path').attr('d', round(dash, 1)).attr('class', 'strokes')\n        }\n      } else if (height > 50) {\n        // hill icon\n        h = (height - 40) / 10\n        if (h > 1.7) h = 1.7\n        for (let c = 0, a = area; Math.random() < a / 30; c++, a -= 30) {\n          if (land[i].ctype === 1 && c > 0) break\n          if (polygons[cell][c] === undefined) break\n          const g = hills.append('g').attr('data-cell', cell)\n          if (c < 2) {\n            cx = p[0] - h - c * 1.2\n            cy = p[1] + h / 4 + c / 1.6\n          } else {\n            const p2 = polygons[cell][c]\n            cx = (p[0] * 1.2 + p2[0] * 0.8) / 2\n            cy = (p[1] * 1.2 + p2[1] * 0.8) / 2\n          }\n          let hill = 'M' + cx + ',' + cy + ' Q' + (cx + h) + ',' + (cy - h) + ' ' + (cx + 2 * h) + ',' + cy\n          let shade = 'M' + (cx + 0.6 * h) + ',' + (cy + 0.1) + ' Q' + (cx + h * 0.95) + ',' + (cy - h * 0.91) + ' ' + (cx + 2 * h * 0.97) + ',' + cy\n          let dash = 'M' + (cx - 0.1) + ',' + (cy + 0.2) + ' L' + (cx + 2 * h + 0.1) + ',' + (cy + 0.2)\n          dash +=\n            'M' + (cx + 0.4) + ',' + (cy + 0.4) + ' L' + (cx + 2 * h - 0.3) + ',' + (cy + 0.4)\n          g.append('path').attr('d', round(hill, 1)).attr('stroke', '#5c5c70')\n          g.append('path').attr('d', round(shade, 1)).attr('fill', 'white')\n          g.append('path').attr('d', round(dash, 1)).attr('class', 'strokes')\n        }\n      }\n\n      // swamp icons\n      if (height >= 21 && height < 22 && swampCount < +swampinessInput.value && land[i].used != 1) {\n        const g = swamps.append('g').attr('data-cell', cell)\n        swampCount++\n        land[i].used = 1\n        let swamp = drawSwamp(p[0], p[1])\n        land[i].neighbors.forEach(function(e) {\n          if (cells[e].height >= 20 && cells[e].height < 30 && !cells[e].river && cells[e].used != 1) {\n            cells[e].used = 1\n            swamp += drawSwamp(cells[e].data[0], cells[e].data[1])\n          }\n        })\n        g.append('path').attr('d', round(swamp, 1))\n      }\n\n      // forest icons\n      if (Math.random() < height / 100 && height >= 22 && height < 48) {\n        for (let c = 0, a = area; Math.random() < a / 15; c++, a -= 15) {\n          if (land[i].ctype === 1 && c > 0) break\n          if (polygons[cell][c] === undefined) break\n          const g = forests.append('g').attr('data-cell', cell)\n          if (c === 0) {\n            cx = _.round(p[0] - 1 - Math.random(), 1)\n            cy = p[1] - 2\n          } else {\n            const p2 = polygons[cell][c]\n            if (c > 1) {\n              const dist = Math.hypot(p2[0] - polygons[cell][c - 1][0],\n                p2[1] - polygons[cell][c - 1][1])\n              if (dist < 2) continue\n            }\n            cx = (p[0] * 0.5 + p2[0] * 1.5) / 2\n            cy = (p[1] * 0.5 + p2[1] * 1.5) / 2 - 1\n          }\n          const forest = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 v0.75 h0.1 v-0.75 q0.95,-0.47 -0.05,-1.25 z '\n          const light = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 h0.1 q0.95,-0.47 -0.05,-1.25 z '\n          const shade = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 q-0.2,-0.55 0,-1.1 z '\n          g.append('path').attr('d', forest)\n          g.append('path').attr('d', light).attr('fill', 'white').attr('stroke', 'none')\n          g.append('path').attr('d', shade).attr('fill', '#999999').attr('stroke', 'none')\n        }\n      }\n    }\n    terrain.selectAll('g').selectAll('g').on('click', editReliefIcon)\n    console.timeEnd('drawRelief')\n  }\n\n  function addReliefIcon(height, type, cx, cy, cell) {\n    const g = terrain.select('#' + type).append('g').attr('data-cell', cell)\n    if (type === 'mounts') {\n      const h = height >= 0.7 ? (height - 0.55) * 12 : 1.8\n      const rnd = Math.random() * 0.8 + 0.2\n      let mount = 'M' + cx + ',' + cy + ' L' + (cx + h / 3 + rnd) + ',' + (cy - h / 4 - rnd * 1.2) + ' L' + (cx + h / 1.1) + ',' + (cy - h) + ' L' + (cx + h + rnd) + ',' + (cy - h / 1.2 + rnd) + ' L' + (cx + h * 2) + ',' + cy\n      let shade = 'M' + cx + ',' + cy + ' L' + (cx + h / 3 + rnd) + ',' + (cy - h / 4 - rnd * 1.2) + ' L' + (cx + h / 1.1) + ',' + (cy - h) + ' L' + (cx + h / 1.5) + ',' + cy\n      let dash = 'M' + (cx - 0.1) + ',' + (cy + 0.3) + ' L' + (cx + 2 * h + 0.1) + ',' + (cy + 0.3)\n      dash += 'M' + (cx + 0.4) + ',' + (cy + 0.6) + ' L' + (cx + 2 * h - 0.3) + ',' + (cy + 0.6)\n      g.append('path').attr('d', round(mount, 1)).attr('stroke', '#5c5c70')\n      g.append('path').attr('d', round(shade, 1)).attr('fill', '#999999')\n      g.append('path').attr('d', round(dash, 1)).attr('class', 'strokes')\n    }\n    if (type === 'hills') {\n      let h = height > 0.5 ? (height - 0.4) * 10 : 1.2\n      if (h > 1.8) h = 1.8\n      let hill = 'M' + cx + ',' + cy + ' Q' + (cx + h) + ',' + (cy - h) + ' ' + (cx + 2 * h) + ',' + cy\n      let shade = 'M' + (cx + 0.6 * h) + ',' + (cy + 0.1) + ' Q' + (cx + h * 0.95) + ',' + (cy - h * 0.91) + ' ' + (cx + 2 * h * 0.97) + ',' + cy\n      let dash = 'M' + (cx - 0.1) + ',' + (cy + 0.2) + ' L' + (cx + 2 * h + 0.1) + ',' + (cy + 0.2)\n      dash += 'M' + (cx + 0.4) + ',' + (cy + 0.4) + ' L' + (cx + 2 * h - 0.3) + ',' + (cy + 0.4)\n      g.append('path').attr('d', round(hill, 1)).attr('stroke', '#5c5c70')\n      g.append('path').attr('d', round(shade, 1)).attr('fill', 'white')\n      g.append('path').attr('d', round(dash, 1)).attr('class', 'strokes')\n    }\n    if (type === 'swamps') {\n      const swamp = drawSwamp(cx, cy)\n      g.append('path').attr('d', round(swamp, 1))\n    }\n    if (type === 'forests') {\n      const rnd = Math.random()\n      const h = rnd * 0.4 + 0.6\n      const forest = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 v0.75 h0.1 v-0.75 q0.95,-0.47 -0.05,-1.25 z '\n      const light = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 h0.1 q0.95,-0.47 -0.05,-1.25 z '\n      const shade = 'M' + cx + ',' + cy + ' q-1,0.8 -0.05,1.25 q-0.2,-0.55 0,-1.1 z '\n      g.append('path').attr('d', forest)\n      g.append('path').attr('d', light).attr('fill', 'white').attr('stroke', 'none')\n      g.append('path').attr('d', shade).attr('fill', '#999999').attr('stroke', 'none')\n    }\n    g.on('click', editReliefIcon)\n    return g\n  }\n\n  function compareY(a, b) {\n    if (a.data[1] > b.data[1]) return 1\n    if (a.data[1] < b.data[1]) return -1\n    return 0\n  }\n\n  function drawSwamp(x, y) {\n    const h = 0.6\n    let line = ''\n    for (let c = 0; c < 3; c++) {\n      let cx\n      let cy\n      if (c == 0) {\n        cx = x\n        cy = y - 0.5 - Math.random()\n      }\n      if (c == 1) {\n        cx = x + h + Math.random()\n        cy = y + h + Math.random()\n      }\n      if (c == 2) {\n        cx = x - h - Math.random()\n        cy = y + 2 * h + Math.random()\n      }\n      line +=\n        'M' + cx + ',' + cy + ' H' + (cx - h / 6) + ' M' + cx + ',' + cy + ' H' + (cx + h / 6) + ' M' + cx + ',' + cy + ' L' + (cx - h / 3) + ',' + (cy - h / 2) + ' M' + cx + ',' + cy + ' V' + (cy - h / 1.5) + ' M' + cx + ',' + cy + ' L' + (cx + h / 3) + ',' + (cy - h / 2)\n      line +=\n        'M' + (cx - h) + ',' + cy + ' H' + (cx - h / 2) + ' M' + (cx + h / 2) + ',' + cy + ' H' + (cx + h)\n    }\n    return line\n  }\n\n  // Complete the map for the \"customize\" mode\n  function getMap() {\n    if (customization !== 1) {\n      tip(\n        'Nothing to complete! Click on \"Edit\" or \"Clear all\" to enter a heightmap customization mode',\n        null, 'error')\n      return\n    }\n    if (+landmassCounter.innerHTML < 150) {\n      tip('Insufficient land area! Please add more land cells to complete the map', null,\n        'error')\n      return\n    }\n    exitCustomization()\n    console.time('TOTAL')\n    markFeatures()\n    drawOcean()\n    elevateLakes()\n    resolveDepressionsPrimary()\n    reGraph()\n    resolveDepressionsSecondary()\n    flux()\n    addLakes()\n    if (!changeHeights.checked) restoreCustomHeights()\n    drawCoastline()\n    drawRelief()\n    const keepData = states.length && manors.length\n    if (keepData) {\n      restoreRegions()\n    } else {\n      generateCultures()\n      manorsAndRegions()\n    }\n    cleanData()\n    console.timeEnd('TOTAL')\n  }\n\n  // Add support \"click to add\" button events\n  $('#customizeTab').click(clickToAdd)\n\n  function clickToAdd() {\n    if (modules.clickToAdd) return\n    modules.clickToAdd = true\n\n    // add label on click\n    $('#addLabel').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        closeDialogs('.stable')\n        viewbox.style('cursor', 'crosshair').on('click', addLabelOnClick)\n      }\n    })\n\n    function addLabelOnClick() {\n      const point = d3.mouse(this)\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n\n      // get culture in clicked point to generate a name\n      const closest = cultureTree.find(x, y)\n      const culture = cultureTree.data().indexOf(closest) || 0\n      const name = generateName(culture)\n\n      let group = labels.select('#addedLabels')\n      if (!group.size()) {\n        group = labels.append('g').attr('id', 'addedLabels')\n                      .attr('fill', '#3e3e4b').attr('opacity', 1)\n                      .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n                      .attr('font-size', 18).attr('data-size', 18)\n      }\n      let id = 'label' + Date.now().toString().slice(7)\n      group.append('text').attr('id', id).attr('x', x).attr('y', y).text(name)\n           .on('click', editLabel)\n\n      if (d3.event.shiftKey === false) {\n        $('#addLabel').removeClass('pressed')\n        restoreDefaultEvents()\n      }\n    }\n\n    // add burg on click\n    $('#addBurg').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n        tip('', true)\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).attr('data-state', -1).addClass('pressed')\n        $('#burgAdd, #burgAddfromEditor').addClass('pressed')\n        viewbox.style('cursor', 'crosshair').on('click', addBurgOnClick)\n        tip('Click on map to place burg icon with a label. Hold Shift to place several', true)\n      }\n    })\n\n    function addBurgOnClick() {\n      const point = d3.mouse(this)\n      const index = getIndex(point)\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n\n      // get culture in clicked point to generate a name\n      let culture = cells[index].culture\n      if (culture === undefined) culture = 0\n      const name = generateName(culture)\n\n      if (cells[index].height < 20) {\n        tip('Cannot place burg in the water! Select a land cell', null, 'error')\n        return\n      }\n      if (cells[index].manor !== undefined) {\n        tip('There is already a burg in this cell. Please select a free cell', null, 'error')\n        $('#grid').fadeIn()\n        d3.select('#toggleGrid').classed('buttonoff', false)\n        return\n      }\n      const i = manors.length\n      const size = burgIcons.select('#towns').attr('size')\n      burgIcons.select('#towns').append('circle').attr('id', 'burg' + i).attr('data-id', i)\n               .attr('cx', x).attr('cy', y).attr('r', size).on('click', editBurg)\n      burgLabels.select('#towns').append('text').attr('data-id', i).attr('x', x).attr('y', y)\n                .attr('dy', '-0.35em').text(name).on('click', editBurg)\n      invokeActiveZooming()\n\n      if (d3.event.shiftKey === false) {\n        $('#addBurg, #burgAdd, #burgAddfromEditor').removeClass('pressed')\n        restoreDefaultEvents()\n      }\n\n      let region, state = +$('#addBurg').attr('data-state')\n      if (state !== -1) {\n        region = states[state].capital === 'neutral' ? 'neutral' : state\n        const oldRegion = cells[index].region\n        if (region !== oldRegion) {\n          cells[index].region = region\n          redrawRegions()\n        }\n      } else {\n        region = cells[index].region\n        state = region === 'neutral' ? states.length - 1 : region\n      }\n      cells[index].manor = i\n      let score = cells[index].score\n      if (score <= 0) {score = _.round(Math.random(), 2)}\n      if (cells[index].crossroad) {score += cells[index].crossroad} // crossroads\n      if (cells[index].confluence) {score += Math.pow(cells[index].confluence, 0.3)} // confluences\n      if (cells[index].port !== undefined) {score *= 3} // port-capital\n      const population = _.round(score, 1)\n      manors.push({i, cell: index, x, y, region, culture, name, population})\n      recalculateStateData(state)\n      updateCountryEditors()\n      tip('', true)\n    }\n\n    // add river on click\n    $('#addRiver').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        unselect()\n      } else {\n        $('.pressed').removeClass('pressed')\n        unselect()\n        $(this).addClass('pressed')\n        closeDialogs('.stable')\n        viewbox.style('cursor', 'crosshair').on('click', addRiverOnClick)\n        tip('Click on map to place new river or extend an existing one', true)\n      }\n    })\n\n    function addRiverOnClick() {\n      const point = d3.mouse(this)\n      const index = diagram.find(point[0], point[1]).index\n      let cell = cells[index]\n      if (cell.river || cell.height < 20) return\n      const dataRiver = [] // to store river points\n      const last = $('#rivers > path').last()\n      const river = last.length ? +last.attr('id').slice(5) + 1 : 0\n      cell.flux = 0.85\n      while (cell) {\n        cell.river = river\n        const x = cell.data[0], y = cell.data[1]\n        dataRiver.push({x, y, cell: index})\n        const nHeights = []\n        cell.neighbors.forEach(function(e) {nHeights.push(cells[e].height)})\n        const minId = nHeights.indexOf(d3.min(nHeights))\n        const min = cell.neighbors[minId]\n        const tx = cells[min].data[0], ty = cells[min].data[1]\n        if (cells[min].height < 20) {\n          const px = (x + tx) / 2\n          const py = (y + ty) / 2\n          dataRiver.push({x: px, y: py, cell: index})\n          cell = undefined\n        } else {\n          if (cells[min].river === undefined) {\n            cells[min].flux += cell.flux\n            cell = cells[min]\n          } else {\n            const r = cells[min].river\n            const riverEl = $('#river' + r)\n            const riverCells = $.grep(land, function(e) {return e.river === r})\n            riverCells.sort(function(a, b) {return b.height - a.height})\n            const riverCellsUpper = $.grep(riverCells,\n              function(e) {return e.height > cells[min].height})\n            if (dataRiver.length > riverCellsUpper.length) {\n              // new river is more perspective\n              const avPrec = _.round(precInput.value / Math.sqrt(cells.length), 2)\n              let dataRiverMin = []\n              riverCells.map(function(c) {\n                if (c.height < cells[min].height) {\n                  cells[c.index].river = undefined\n                  cells[c.index].flux = avPrec\n                } else {\n                  dataRiverMin.push({x: c.data[0], y: c.data[1], cell: c.index})\n                }\n              })\n              cells[min].flux += cell.flux\n              if (cells[min].confluence) {\n                cells[min].confluence += riverCellsUpper.length\n              } else {cells[min].confluence = riverCellsUpper.length}\n              cell = cells[min]\n              // redraw old river's upper part or remove if small\n              if (dataRiverMin.length > 1) {\n                var riverAmended = amendRiver(dataRiverMin, 1)\n                var d = drawRiver(riverAmended, 1.3, 1)\n                riverEl.attr('d', d).attr('data-width', 1.3).attr('data-increment', 1)\n              } else {\n                riverEl.remove()\n                dataRiverMin.map(function(c) {cells[c.cell].river = undefined})\n              }\n            } else {\n              if (cells[min].confluence) {\n                cells[min].confluence += dataRiver.length\n              } else {cells[min].confluence = dataRiver.length}\n              cells[min].flux += cell.flux\n              dataRiver.push({x: tx, y: ty, cell: min})\n              cell = undefined\n            }\n          }\n        }\n      }\n      const rndFactor = 0.2 + Math.random() * 1.6 // random factor in range 0.2-1.8\n      var riverAmended = amendRiver(dataRiver, rndFactor)\n      var d = drawRiver(riverAmended, 1.3, 1)\n      rivers.append('path').attr('d', d).attr('id', 'river' + river)\n            .attr('data-width', 1.3).attr('data-increment', 1).on('click', editRiver)\n    }\n\n    // add relief icon on click\n    $('#addRelief').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        closeDialogs('.stable')\n        viewbox.style('cursor', 'crosshair').on('click', addReliefOnClick)\n        tip('Click on map to place relief icon. Hold Shift to place several', true)\n      }\n    })\n\n    function addReliefOnClick() {\n      const point = d3.mouse(this)\n      const index = getIndex(point)\n      const height = cells[index].height\n      if (height < 20) {\n        tip('Cannot place icon in the water! Select a land cell')\n        return\n      }\n\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n      const type = reliefGroup.value\n      addReliefIcon(height / 100, type, x, y, index)\n\n      if (d3.event.shiftKey === false) {\n        $('#addRelief').removeClass('pressed')\n        restoreDefaultEvents()\n      }\n      tip('', true)\n    }\n\n    // add route on click\n    $('#addRoute').click(function() {\n      if (!modules.editRoute) editRoute()\n      $('#routeNew').click()\n    })\n\n    // add marker on click\n    $('#addMarker').click(function() {\n      if ($(this).hasClass('pressed')) {\n        $('.pressed').removeClass('pressed')\n        restoreDefaultEvents()\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        $('#markerAdd').addClass('pressed')\n        viewbox.style('cursor', 'crosshair').on('click', addMarkerOnClick)\n      }\n    })\n\n    function addMarkerOnClick() {\n      const point = d3.mouse(this)\n      let x = _.round(point[0], 2), y = _.round(point[1], 2)\n      let selected = markerSelectGroup.value\n      let valid = selected && d3.select('#defs-markers').select('#' + selected).size() === 1\n      let symbol = valid ? '#' + selected : '#marker0'\n      let desired = valid ? markers.select('[data-id=\\'' + symbol + '\\']').attr('data-size') : 1\n      if (isNaN(desired)) desired = 1\n      let id = 'marker' + Date.now().toString().slice(7) // unique id\n      let size = desired * 5 + 25 / scale\n\n      markers.append('use').attr('id', id).attr('xlink:href', symbol).attr('data-id', symbol)\n             .attr('data-x', x).attr('data-y', y).attr('x', x - size / 2).attr('y', y - size)\n             .attr('data-size', desired).attr('width', size).attr('height', size)\n             .on('click', editMarker)\n\n      if (d3.event.shiftKey === false) {\n        $('#addMarker, #markerAdd').removeClass('pressed')\n        restoreDefaultEvents()\n      }\n    }\n\n  }\n\n  // return cell / polly Index or error\n  function getIndex(point) {\n    let c = diagram.find(point[0], point[1])\n    if (!c) {\n      console.error('Cannot find closest cell for points' + point[0] + ', ' + point[1])\n      return\n    }\n    return c.index\n  }\n\n  // re-calculate data for a particular state\n  function recalculateStateData(state) {\n    const s = states[state] || states[states.length - 1]\n    if (s.capital === 'neutral') state = 'neutral'\n    const burgs = $.grep(manors, function(e) {return e.region === state})\n    s.burgs = burgs.length\n    let burgsPop = 0 // get summ of all burgs population\n    burgs.map(function(b) {burgsPop += b.population})\n    s.urbanPopulation = _.round(burgsPop, 1)\n    const regionCells = $.grep(cells, function(e) {return (e.region === state)})\n    let cellsPop = 0, area = 0\n    regionCells.map(function(c) {\n      cellsPop += c.pop\n      area += c.area\n    })\n    s.cells = regionCells.length\n    s.area = Math.round(area)\n    s.ruralPopulation = _.round(cellsPop, 1)\n  }\n\n  function changeSelectedOnClick() {\n    const point = d3.mouse(this)\n    const index = diagram.find(point[0], point[1]).index\n    if (cells[index].height < 20) return\n    $('.selected').removeClass('selected')\n    let color\n\n    // select state\n    if (customization === 2) {\n      const assigned = regions.select('#temp').select('path[data-cell=\\'' + index + '\\']')\n      let s = assigned.size() ? assigned.attr('data-state') : cells[index].region\n      if (s === 'neutral') s = states.length - 1\n      color = states[s].color\n      if (color === 'neutral') color = 'white'\n      $('#state' + s).addClass('selected')\n    }\n\n    // select culture\n    if (customization === 4) {\n      const assigned = cults.select('#cult' + index)\n      const c = assigned.attr('data-culture') !== null\n                ? +assigned.attr('data-culture')\n                : cells[index].culture\n      color = cultures[c].color\n      $('#culture' + c).addClass('selected')\n    }\n\n    debug.selectAll('.circle').attr('stroke', color)\n  }\n\n  // fetch default fonts if not done before\n  function loadDefaultFonts() {\n    if (!$('link[href=\"fonts.css\"]').length) {\n      $('head').append('<link rel=\"stylesheet\" type=\"text/css\" href=\"fonts.css\">')\n      const fontsToAdd = ['Amatic+SC:700', 'IM+Fell+English', 'Great+Vibes', 'MedievalSharp', 'Metamorphous',\n                          'Nova+Script', 'Uncial+Antiqua', 'Underdog', 'Caesar+Dressing', 'Bitter', 'Yellowtail', 'Montez',\n                          'Shadows+Into+Light', 'Fredericka+the+Great', 'Orbitron', 'Dancing+Script:700',\n                          'Architects+Daughter', 'Kaushan+Script', 'Gloria+Hallelujah', 'Satisfy', 'Comfortaa:700', 'Cinzel']\n      fontsToAdd.forEach(function(f) {if (FONTS.indexOf(f) === -1) FONTS.push(f)})\n      updateFontOptions()\n    }\n  }\n\n  function fetchFonts(url) {\n    return new Promise((resolve, reject) => {\n      if (url === '') {\n        tip(\n          'Use a direct link to any @font-face declaration or just font name to fetch from Google Fonts')\n        return\n      }\n      if (url.indexOf('http') === -1) {\n        url = url.replace(url.charAt(0), url.charAt(0).toUpperCase()).split(' ').join('+')\n        url = 'https://fonts.googleapis.com/css?family=' + url\n      }\n      const fetched = addFonts(url).then(fetched => {\n        if (fetched === undefined) {\n          tip('Cannot fetch font for this value!')\n          return\n        }\n        if (fetched === 0) {\n          tip('Already in the fonts list!')\n          return\n        }\n        updateFontOptions()\n        if (fetched === 1) {\n          tip('Font ' + FONTS[FONTS.length - 1] + ' is fetched')\n        } else if (fetched > 1) {\n          tip(fetched + ' fonts are added to the list')\n        }\n        resolve(fetched)\n      })\n    })\n  }\n\n  function addFonts(url) {\n    $('head').append('<link rel=\"stylesheet\" type=\"text/css\" href=\"' + url + '\">')\n    return fetch(url)\n      .then(resp => resp.text())\n      .then(text => {\n        let s = document.createElement('style')\n        s.innerHTML = text\n        document.head.appendChild(s)\n        let styleSheet = Array.prototype.filter.call(\n          document.styleSheets,\n          sS => sS.ownerNode === s)[0]\n        let FontRule = rule => {\n          let family = rule.style.getPropertyValue('font-family')\n          let font = family.replace(/['\"]+/g, '').replace(/ /g, '+')\n          let weight = rule.style.getPropertyValue('font-weight')\n          if (weight !== '400') font += ':' + weight\n          if (FONTS.indexOf(font) == -1) {\n            FONTS.push(font)\n            fetched++\n          }\n        }\n        let fetched = 0\n        for (let r of styleSheet.cssRules) {FontRule(r)}\n        document.head.removeChild(s)\n        return fetched\n      })\n      .catch(function() {})\n  }\n\n  // Update font list for Label and Burg Editors\n  function updateFontOptions() {\n    labelFontSelect.innerHTML = ''\n    for (let i = 0; i < FONTS.length; i++) {\n      const opt = document.createElement('option')\n      opt.value = i\n      const font = FONTS[i].split(':')[0].replace(/\\+/g, ' ')\n      opt.style.fontFamily = opt.innerHTML = font\n      labelFontSelect.add(opt)\n    }\n    burgSelectDefaultFont.innerHTML = labelFontSelect.innerHTML\n  }\n\n  // Save in .map format, based on FileSystem API\n  function saveMap() {\n    console.time('saveMap')\n    // data convention: 0 - params; 1 - all points; 2 - cells; 3 - manors; 4 - states;\n    // 5 - svg; 6 - options (see below); 7 - cultures;\n    // 8 - empty (former nameBase); 9 - empty (former nameBases); 10 - heights; 11 - notes;\n    // size stats: points = 6%, cells = 36%, manors and states = 2%, svg = 56%;\n    const date = new Date()\n    const dateString = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate()\n    const license = 'File can be loaded in azgaar.github.io/Fantasy-Map-Generator'\n    const params = version + '|' + license + '|' + dateString + '|' + seed\n    const options = customization + '|' +\n                    distanceUnit.value + '|' + distanceScale.value + '|' + areaUnit.value + '|' +\n                    barSize.value + '|' + barLabel.value + '|' + barBackOpacity.value + '|' + barBackColor.value + '|' +\n                    populationRate.value + '|' + urbanization.value\n\n    // set zoom / transform values to default\n    svg.attr('width', graphWidth).attr('height', graphHeight)\n    const transform = d3.zoomTransform(svg.node())\n    viewbox.attr('transform', null)\n    const oceanBack = ocean.select('rect')\n    const oceanShift = [oceanBack.attr('x'), oceanBack.attr('y'), oceanBack.attr(\n      'width'), oceanBack.attr('height')]\n    oceanBack.attr('x', 0).attr('y', 0).attr('width', graphWidth).attr('height', graphHeight)\n\n    const svg_xml = (new XMLSerializer()).serializeToString(svg.node())\n    const line = '\\r\\n'\n    let data = params + line + JSON.stringify(points) + line + JSON.stringify(cells) + line\n    data += JSON.stringify(manors) + line + JSON.stringify(\n      states) + line + svg_xml + line + options + line\n    data +=\n      JSON.stringify(cultures) + line + '' + line + '' + line + heights + line + JSON.stringify(\n      notes) + line\n    const dataBlob = new Blob([data], {type: 'text/plain'})\n    const dataURL = window.URL.createObjectURL(dataBlob)\n    const link = document.createElement('a')\n    link.download = 'fantasy_map_' + Date.now() + '.map'\n    link.href = dataURL\n    document.body.appendChild(link)\n    link.click()\n\n    // restore initial values\n    svg.attr('width', svgWidth).attr('height', svgHeight)\n    zoom.transform(svg, transform)\n    oceanBack.attr('x', oceanShift[0]).attr('y', oceanShift[1]).attr('width', oceanShift[2])\n             .attr('height', oceanShift[3])\n\n    console.timeEnd('saveMap')\n    window.setTimeout(function() {window.URL.revokeObjectURL(dataURL)}, 4000)\n  }\n\n  // Map Loader based on FileSystem API\n  $('#mapToLoad').change(function() {\n    console.time('loadMap')\n    closeDialogs()\n    const fileToLoad = this.files[0]\n    this.value = ''\n    uploadFile(fileToLoad)\n  })\n\n  function uploadFile(file, callback) {\n    console.time('loadMap')\n    const fileReader = new FileReader()\n    fileReader.onload = function(fileLoadedEvent) {\n      const dataLoaded = fileLoadedEvent.target.result\n      const data = dataLoaded.split('\\r\\n')\n      // data convention: 0 - params; 1 - all points; 2 - cells; 3 - manors; 4 - states;\n      // 5 - svg; 6 - options; 7 - cultures; 8 - none; 9 - none; 10 - heights; 11 - notes;\n      const params = data[0].split('|')\n      const mapVersion = params[0] || data[0]\n      if (mapVersion !== version) {\n        let message = `The Map version `\n        // mapVersion reference was not added to downloaded map before v. 0.52b, so I cannot support really old files\n        if (mapVersion.length <= 10) {\n          message += `(${mapVersion}) does not match the Generator version (${version}). The map will be auto-updated.\n                    In case of critical issues you may send the .map file\n                    <a href=\"mailto:maxganiev@yandex.ru?Subject=Map%20update%20request\" target=\"_blank\">to me</a>\n                    or just keep using\n                    <a href=\"https://github.com/Azgaar/Fantasy-Map-Generator/wiki/Changelog\" target=\"_blank\">an appropriate version</a>\n                    of the Generator`\n        } else if (!mapVersion || parseFloat(mapVersion) < 0.54) {\n          message += `you are trying to load is too old and cannot be updated. Please re-create the map or just keep using\n                    <a href=\"https://github.com/Azgaar/Fantasy-Map-Generator/wiki/Changelog\" target=\"_blank\">an archived version</a>\n                    of the Generator. Please note the Generator is still on demo and a lot of changes are being made every month`\n        }\n        alertMessage.innerHTML = message\n        $('#alert').dialog({\n          title: 'Warning', buttons: {\n            OK: function() {\n              loadDataFromMap(data)\n            }\n          }\n        })\n      } else {loadDataFromMap(data)}\n      if (mapVersion.length > 10) {console.error('Cannot load map') }\n    }\n    fileReader.readAsText(file, 'UTF-8')\n    if (callback) {callback()}\n  }\n\n  function loadDataFromMap(data) {\n    closeDialogs()\n    // update seed\n    const params = data[0].split('|')\n    if (params[3]) {\n      seed = params[3]\n      $('#optionsSeed').value = seed\n    }\n\n    // get options\n    if (data[0] === '0.52b' || data[0] === '0.53b') {\n      customization = 0\n    } else if (data[6]) {\n      const options = data[6].split('|')\n      customization = +options[0] || 0\n      if (options[1]) distanceUnit.value = options[1]\n      if (options[2]) distanceScale.value = options[2]\n      if (options[3]) areaUnit.value = options[3]\n      if (options[4]) barSize.value = options[4]\n      if (options[5]) barLabel.value = options[5]\n      if (options[6]) barBackOpacity.value = options[6]\n      if (options[7]) barBackColor.value = options[7]\n      if (options[8]) populationRate.value = options[8]\n      if (options[9]) urbanization.value = options[9]\n    }\n\n    // replace old svg\n    svg.remove()\n    if (data[0] === '0.52b' || data[0] === '0.53b') {\n      states = [] // no states data in old maps\n      document.body.insertAdjacentHTML('afterbegin', data[4])\n    } else {\n      states = JSON.parse(data[4])\n      document.body.insertAdjacentHTML('afterbegin', data[5])\n    }\n\n    svg = d3.select('svg')\n\n    // always change graph size to the size of loaded map\n    const nWidth = +svg.attr('width'), nHeight = +svg.attr('height')\n    graphWidth = nWidth\n    graphHeight = nHeight\n    voronoi = d3.voronoi().extent([[-1, -1], [graphWidth + 1, graphHeight + 1]])\n    zoom.translateExtent([[0, 0], [graphWidth, graphHeight]]).scaleExtent([1, 20])\n        .scaleTo(svg, 1)\n    viewbox.attr('transform', null)\n\n    // temporary fit loaded svg element to current canvas size\n    svg.attr('width', svgWidth).attr('height', svgHeight)\n    if (nWidth !== svgWidth || nHeight !== svgHeight) {\n      alertMessage.innerHTML =\n        `The loaded map has size ${nWidth} x ${nHeight} pixels, while the current canvas size is ${svgWidth} x ${svgHeight} pixels.\n                              Click \"Rescale\" to fit the map to the current canvas size. Click \"OK\" to browse the map without rescaling`\n      $('#alert').dialog({\n        title: 'Map size conflict',\n        buttons: {\n          Rescale: function() {\n            applyLoadedData(data)\n            // rescale loaded map\n            const xRatio = svgWidth / nWidth\n            const yRatio = svgHeight / nHeight\n            const scaleTo = _.round(Math.min(xRatio, yRatio), 4)\n            // calculate frames to scretch ocean background\n            const extent = (100 / scaleTo) + '%'\n            const xShift = (nWidth * scaleTo - svgWidth) / 2 / scaleTo\n            const yShift = (nHeight * scaleTo - svgHeight) / 2 / scaleTo\n            svg.select('#ocean').selectAll('rect').attr('x', xShift).attr('y', yShift)\n               .attr('width', extent).attr('height', extent)\n            zoom.translateExtent([[0, 0], [nWidth, nHeight]]).scaleExtent([scaleTo, 20])\n                .scaleTo(svg, scaleTo)\n            $(this).dialog('close')\n          },\n          OK: function() {\n            changeMapSize()\n            applyLoadedData(data)\n            $(this).dialog('close')\n          }\n        }\n      })\n    } else {\n      applyLoadedData(data)\n    }\n  }\n\n  function applyLoadedData(data) {\n    // redefine variables\n    defs = svg.select('#deftemp')\n    viewbox = svg.select('#viewbox')\n    ocean = viewbox.select('#ocean')\n    oceanLayers = ocean.select('#oceanLayers')\n    oceanPattern = ocean.select('#oceanPattern')\n    landmass = viewbox.select('#landmass')\n    grid = viewbox.select('#grid')\n    overlay = viewbox.select('#overlay')\n    terrs = viewbox.select('#terrs')\n    cults = viewbox.select('#cults')\n    routes = viewbox.select('#routes')\n    roads = routes.select('#roads')\n    trails = routes.select('#trails')\n    rivers = viewbox.select('#rivers')\n    terrain = viewbox.select('#terrain')\n    regions = viewbox.select('#regions')\n    borders = viewbox.select('#borders')\n    stateBorders = borders.select('#stateBorders')\n    neutralBorders = borders.select('#neutralBorders')\n    coastline = viewbox.select('#coastline')\n    lakes = viewbox.select('#lakes')\n    searoutes = routes.select('#searoutes')\n    labels = viewbox.select('#labels')\n    icons = viewbox.select('#icons')\n    markers = viewbox.select('#markers')\n    ruler = viewbox.select('#ruler')\n    debug = viewbox.select('#debug')\n\n    if (!d3.select('#defs-markers').size()) {\n      let symbol = '<g id=\"defs-markers\"><symbol id=\"marker0\" viewBox=\"0 0 30 30\"><path d=\"M6,19 l9,10 L24,19\" fill=\"#000000\" stroke=\"none\"></path><circle cx=\"15\" cy=\"15\" r=\"10\" stroke-width=\"1\" stroke=\"#000000\" fill=\"#ffffff\"></circle><text x=\"50%\" y=\"50%\" fill=\"#000000\" stroke-width=\"0\" stroke=\"#000000\" font-size=\"22px\" dominant-baseline=\"central\">?</text></symbol></g>'\n      let cont = document.getElementsByTagName('defs')\n      cont[0].insertAdjacentHTML('afterbegin', symbol)\n      markers = viewbox.append('g').attr('id', 'markers')\n    }\n\n    // version control: ensure required groups are created with correct data\n    if (!labels.select('#burgLabels').size()) {\n      labels.append('g').attr('id', 'burgLabels')\n      $('#labels #capitals, #labels #towns').detach().appendTo($('#burgLabels'))\n    }\n\n    if (!icons.select('#burgIcons').size()) {\n      icons.append('g').attr('id', 'burgIcons')\n      $('#icons #capitals, #icons #towns').detach().appendTo($('#burgIcons'))\n      icons.select('#burgIcons').select('#capitals').attr('size', 1).attr('fill-opacity', .7)\n           .attr('stroke-opacity', 1)\n      icons.select('#burgIcons').select('#towns').attr('size', .5).attr('fill-opacity', .7)\n           .attr('stroke-opacity', 1)\n    }\n\n    icons.selectAll('g').each(function() {\n      const size = this.getAttribute('font-size')\n      if (size === null || size === undefined) return\n      this.removeAttribute('font-size')\n      this.setAttribute('size', size)\n    })\n\n    icons.select('#burgIcons').selectAll('circle').each(function() {\n      this.setAttribute('r', this.parentNode.getAttribute('size'))\n    })\n\n    icons.selectAll('use').each(function() {\n      const size = this.parentNode.getAttribute('size')\n      if (size === null || size === undefined) return\n      this.setAttribute('width', size)\n      this.setAttribute('height', size)\n    })\n\n    if (!labels.select('#countries').size()) {\n      labels.append('g').attr('id', 'countries')\n            .attr('fill', '#3e3e4b').attr('opacity', 1)\n            .attr('font-family', 'Almendra SC').attr('data-font', 'Almendra+SC')\n            .attr('font-size', 14).attr('data-size', 14)\n    }\n\n    burgLabels = labels.select('#burgLabels')\n    burgIcons = icons.select('#burgIcons')\n\n    // restore events\n    svg.call(zoom)\n    restoreDefaultEvents()\n    viewbox.on('touchmove mousemove', moved)\n    overlay.selectAll('*').call(d3.drag().on('start', elementDrag))\n    terrain.selectAll('g').selectAll('g').on('click', editReliefIcon)\n    labels.selectAll('text').on('click', editLabel)\n    icons.selectAll('circle, path, use').on('click', editIcon)\n    burgLabels.selectAll('text').on('click', editBurg)\n    burgIcons.selectAll('circle, path, use').on('click', editBurg)\n    rivers.selectAll('path').on('click', editRiver)\n    routes.selectAll('path').on('click', editRoute)\n    markers.selectAll('use').on('click', editMarker)\n    svg.select('#scaleBar').call(d3.drag().on('start', elementDrag)).on('click', editScale)\n    ruler.selectAll('g').call(d3.drag().on('start', elementDrag))\n    ruler.selectAll('g').selectAll('text').on('click', removeParent)\n    ruler.selectAll('.opisometer').selectAll('circle')\n         .call(d3.drag().on('start', opisometerEdgeDrag))\n    ruler.selectAll('.linear').selectAll('circle:not(.center)')\n         .call(d3.drag().on('drag', rulerEdgeDrag))\n    ruler.selectAll('.linear').selectAll('circle.center')\n         .call(d3.drag().on('drag', rulerCenterDrag))\n\n    // update data\n    const newPoints = []\n    riversData = [], queue = [], elSelected = ''\n    points = JSON.parse(data[1])\n    cells = JSON.parse(data[2])\n    manors = JSON.parse(data[3])\n    if (data[7]) cultures = JSON.parse(data[7])\n    if (data[7] === undefined) generateCultures()\n    if (data[11]) notes = JSON.parse(data[11])\n\n    // place random point\n    function placePoint() {\n      const x = Math.floor(Math.random() * graphWidth * 0.8 + graphWidth * 0.1)\n      const y = Math.floor(Math.random() * graphHeight * 0.8 + graphHeight * 0.1)\n      return [x, y]\n    }\n\n    // ensure each culure has a valid namesbase assigned, if not assign first base\n    if (!nameBase[0]) applyDefaultNamesData()\n    cultures.forEach(function(c) {\n      const b = c.base\n      if (b === undefined) c.base = 0\n      if (!nameBase[b] || !nameBases[b]) c.base = 0\n      if (c.center === undefined) c.center = placePoint()\n    })\n    const graphSizeAdj = 90 / Math.sqrt(cells.length, 2) // adjust to different graphSize\n\n    // cells validations\n    cells.forEach(function(c, d) {\n      // collect points\n      newPoints.push(c.data)\n\n      // update old 0-1 height range to a new 0-100 range\n      if (c.height < 1) c.height = Math.trunc(c.height * 100)\n      if (c.height === 1 && c.region !== undefined && c.flux !== undefined) c.height = 100\n\n      // check if there are any unavailable cultures\n      if (c.culture > cultures.length - 1) {\n        const center = [c.data[0], c.data[1]]\n        const cult = {name: 'AUTO_' + c.culture, color: '#ff0000', base: 0, center}\n        cultures.push(cult)\n      }\n\n      if (c.height >= 20) {\n        if (!polygons[d] || !polygons[d].length) return\n        // calculate area\n        if (c.area === undefined || isNaN(c.area)) {\n          const area = d3.polygonArea(polygons[d])\n          c.area = _.round(Math.abs(area), 2)\n        }\n        // calculate population\n        if (c.pop === undefined || isNaN(c.pop)) {\n          let population = 0\n          const elevationFactor = Math.pow((100 - c.height) / 100, 3)\n          population = elevationFactor * c.area * graphSizeAdj\n          if (c.region === 'neutral') population *= 0.5\n          c.pop = _.round(population, 1)\n        }\n        // if culture is undefined, set to 0\n        if (c.culture === undefined || isNaN(c.culture)) c.culture = 0\n      }\n    })\n\n    land = $.grep(cells, function(e) {return (e.height >= 20)})\n    calculateVoronoi(newPoints)\n\n    // get heights Uint8Array\n    if (data[10]) {heights = new Uint8Array(data[10].split(','))} else {\n      heights = new Uint8Array(points.length)\n      for (let i = 0; i < points.length; i++) {\n        const cell = diagram.find(points[i][0], points[i][1]).index\n        heights[i] = cells[cell].height\n      }\n    }\n\n    // restore Heightmap customization mode\n    if (customization === 1) {\n      optionsTrigger.click()\n      $('#customizeHeightmap, #customizationMenu').slideDown()\n      $('#openEditor').slideUp()\n      updateHistory()\n      customizeTab.click()\n      paintBrushes.click()\n      tip('The map is in Heightmap customization mode. Please finalize the Heightmap', true)\n    }\n    // restore Country Edition mode\n    if (customization === 2 || customization === 3) tip(\n      'The map is in Country Edition mode. Please complete the assignment', true)\n\n    // restore layers state\n    d3.select('#toggleCultures').classed('buttonoff', !cults.selectAll('path').size())\n    d3.select('#toggleHeight').classed('buttonoff', !terrs.selectAll('path').size())\n    d3.select('#toggleCountries').classed('buttonoff', regions.style('display') === 'none')\n    d3.select('#toggleRivers').classed('buttonoff', rivers.style('display') === 'none')\n    d3.select('#toggleOcean').classed('buttonoff', oceanPattern.style('display') === 'none')\n    d3.select('#toggleRelief').classed('buttonoff', terrain.style('display') === 'none')\n    d3.select('#toggleBorders').classed('buttonoff', borders.style('display') === 'none')\n    d3.select('#toggleIcons').classed('buttonoff', icons.style('display') === 'none')\n    d3.select('#toggleLabels').classed('buttonoff', labels.style('display') === 'none')\n    d3.select('#toggleRoutes').classed('buttonoff', routes.style('display') === 'none')\n    d3.select('#toggleGrid').classed('buttonoff', grid.style('display') === 'none')\n\n    // update map to support some old versions and fetch fonts\n    labels.selectAll('g').each(function(d) {\n      const el = d3.select(this)\n      if (el.attr('id') === 'burgLabels') return\n      const font = el.attr('data-font')\n      if (font && FONTS.indexOf(font) === -1) addFonts(\n        'https://fonts.googleapis.com/css?family=' + font)\n      if (!el.attr('data-size')) el.attr('data-size', +el.attr('font-size'))\n      if (el.style('display') === 'none') el.node().style.display = null\n    })\n\n    invokeActiveZooming()\n    console.timeEnd('loadMap')\n  }\n\n  // get square grid with some jirrering\n  function getJitteredGrid() {\n    let sizeMod = _.round((graphWidth + graphHeight) / 1500, 2) // screen size modifier\n    spacing = _.round(7.5 * sizeMod / graphSize, 2) // space between points before jirrering\n    const radius = spacing / 2 // square radius\n    const jittering = radius * 0.9 // max deviation\n    const jitter = function() {return Math.random() * 2 * jittering - jittering}\n    let points = []\n    for (let y = radius; y < graphHeight; y += spacing) {\n      for (let x = radius; x < graphWidth; x += spacing) {\n        let xj = _.round(x + jitter(), 2)\n        let yj = _.round(y + jitter(), 2)\n        points.push([xj, yj])\n      }\n    }\n    return points\n  }\n\n  // Hotkeys, see github.com/Azgaar/Fantasy-Map-Generator/wiki/Hotkeys\n  d3.select('body').on('keydown', function() {\n    const active = document.activeElement.tagName\n    if (active === 'INPUT' || active === 'SELECT' || active === 'TEXTAREA') return\n    const key = d3.event.keyCode\n    const ctrl = d3.event.ctrlKey\n    const p = d3.mouse(this)\n    if (key === 117) $('#randomMap').click() // \"F6\" for new map\n    else if (key === 27) closeDialogs() // Escape to close all dialogs\n    else if (key === 79) optionsTrigger.click() // \"O\" to toggle options\n    else if (key === 80) saveAsImage('png') // \"P\" to save as PNG\n    else if (key === 83) saveAsImage('svg') // \"S\" to save as SVG\n    else if (key === 77) saveMap() // \"M\" to save MAP file\n    else if (key === 76) mapToLoad.click() // \"L\" to load MAP\n    else if (key === 32) console.table(cells[diagram.find(p[0], p[1]).index]) // Space to log focused cell data\n    else if (key === 192) console.log(cells) // \"`\" to log cells data\n    else if (key === 66) console.table(manors) // \"B\" to log burgs data\n    else if (key === 67) console.table(states) // \"C\" to log countries data\n    else if (key === 70) console.table(features) // \"F\" to log features data\n    else if (key === 37) zoom.translateBy(svg, 10, 0) // Left to scroll map left\n    else if (key === 39) zoom.translateBy(svg, -10, 0) // Right to scroll map right\n    else if (key === 38) zoom.translateBy(svg, 0, 10) // Up to scroll map up\n    else if (key === 40) zoom.translateBy(svg, 0, -10) // Up to scroll map up\n    else if (key === 107) zoom.scaleBy(svg, 1.2) // Plus to zoom map up\n    else if (key === 109) zoom.scaleBy(svg, 0.8) // Minus to zoom map out\n    else if (key === 48 || key === 96) resetZoom() // 0 to reset zoom\n    else if (key === 49 || key === 97) zoom.scaleTo(svg, 1) // 1 to zoom to 1\n    else if (key === 50 || key === 98) zoom.scaleTo(svg, 2) // 2 to zoom to 2\n    else if (key === 51 || key === 99) zoom.scaleTo(svg, 3) // 3 to zoom to 3\n    else if (key === 52 || key === 100) zoom.scaleTo(svg, 4) // 4 to zoom to 4\n    else if (key === 53 || key === 101) zoom.scaleTo(svg, 5) // 5 to zoom to 5\n    else if (key === 54 || key === 102) zoom.scaleTo(svg, 6) // 6 to zoom to 6\n    else if (key === 55 || key === 103) zoom.scaleTo(svg, 7) // 7 to zoom to 7\n    else if (key === 56 || key === 104) zoom.scaleTo(svg, 8) // 8 to zoom to 8\n    else if (key === 57 || key === 105) zoom.scaleTo(svg, 9) // 9 to zoom to 9\n    else if (key === 9) $('#updateFullscreen').click() // Tab to fit map to fullscreen\n    else if (ctrl && key === 90) undo.click() // Ctrl + \"Z\" to toggle undo\n    else if (ctrl && key === 89) redo.click() // Ctrl + \"Y\" to toggle undo\n  })\n\n  // move layers on mapLayers dragging (jquery sortable)\n  function moveLayer(event, ui) {\n    const el = getLayer(ui.item.attr('id'))\n    if (el) {\n      const prev = getLayer(ui.item.prev().attr('id'))\n      const next = getLayer(ui.item.next().attr('id'))\n      if (prev) {el.insertAfter(prev)} else if (next) {el.insertBefore(next)}\n    }\n  }\n\n  // define connection between option layer buttons and actual svg groups\n  function getLayer(id) {\n    if (id === 'toggleGrid') {return $('#grid')}\n    if (id === 'toggleOverlay') {return $('#overlay')}\n    if (id === 'toggleHeight') {return $('#terrs')}\n    if (id === 'toggleCultures') {return $('#cults')}\n    if (id === 'toggleRoutes') {return $('#routes')}\n    if (id === 'toggleRivers') {return $('#rivers')}\n    if (id === 'toggleCountries') {return $('#regions')}\n    if (id === 'toggleBorders') {return $('#borders')}\n    if (id === 'toggleRelief') {return $('#terrain')}\n    if (id === 'toggleLabels') {return $('#labels')}\n    if (id === 'toggleIcons') {return $('#icons')}\n  }\n\n  // UI Button handlers\n  $('button, a, li, i').on('click', function() {\n    const id = this.id\n    const parent = this.parentNode.id\n    if (debug.selectAll('.tag').size()) {debug.selectAll('.tag, .line').remove()}\n    if (id === 'toggleCountries') {$('#regions').fadeToggle()}\n    if (id === 'toggleCultures') {toggleCultures()}\n    if (id === 'toggleFlux') {toggleFlux()}\n    if (parent === 'mapLayers' || parent === 'styleContent') {$(this).toggleClass('buttonoff')}\n    if (id === 'randomMap' || id === 'regenerate') {\n      changeSeed()\n      exitCustomization()\n      undraw()\n      resetZoom(1000)\n      generate()\n      return\n    }\n    if (id === 'editCountries') editCountries()\n    if (id === 'editCultures') editCultures()\n    if (id === 'editScale' || id === 'editScaleCountries' || id === 'editScaleBurgs') editScale()\n    if (id === 'countriesManually') {\n      customization = 2\n      tip('Click to select a country, drag the circle to re-assign', true)\n      mockRegions()\n      let temp = regions.append('g').attr('id', 'temp')\n      $('#countriesBottom').children().hide()\n      $('#countriesManuallyButtons').show()\n      // highlight capital cells as it's not allowed to change capital's state that way\n      states.map(function(s) {\n        if (s.capital === 'neutral' || s.capital === 'select') return\n        const capital = s.capital\n        const index = manors[capital].cell\n        temp.append('path')\n            .attr('data-cell', index).attr('data-state', s.i)\n            .attr('d', 'M' + polygons[index].join('L') + 'Z')\n            .attr('fill', s.color).attr('stroke', 'red').attr('stroke-width', .7)\n      })\n      viewbox.style('cursor', 'crosshair').call(drag).on('click', changeSelectedOnClick)\n    }\n    if (id === 'countriesRegenerate') {\n      customization = 3\n      tip('Manually change \"Expansion\" value for a country or click on \"Randomize\" button',\n        true)\n      mockRegions()\n      regions.append('g').attr('id', 'temp')\n      $('#countriesBottom').children().hide()\n      $('#countriesRegenerateButtons').show()\n      $('.statePower, .icon-resize-full, .stateCells, .icon-check-empty').toggleClass('hidden')\n      $('div[data-sortby=\\'expansion\\'],div[data-sortby=\\'cells\\']').toggleClass('hidden')\n    }\n    if (id === 'countriesManuallyComplete') {\n      debug.selectAll('.circle').remove()\n      const changedCells = regions.select('#temp').selectAll('path')\n      let changedStates = []\n      changedCells.each(function() {\n        const el = d3.select(this)\n        const cell = +el.attr('data-cell')\n        let stateOld = cells[cell].region\n        if (stateOld === 'neutral') {stateOld = states.length - 1}\n        const stateNew = +el.attr('data-state')\n        const region = states[stateNew].color === 'neutral' ? 'neutral' : stateNew\n        cells[cell].region = region\n        if (cells[cell].manor !== undefined) {manors[cells[cell].manor].region = region}\n        changedStates.push(stateNew, stateOld)\n      })\n      changedStates = [...new Set(changedStates)]\n      changedStates.map(function(s) {recalculateStateData(s)})\n      const last = states.length - 1\n      if (states[last].capital === 'neutral' && states[last].cells === 0) {\n        $('#state' + last).remove()\n        states.splice(-1)\n      }\n      $('#countriesManuallyCancel').click()\n      if (changedStates.length) {editCountries()}\n    }\n    if (id === 'countriesManuallyCancel') {\n      redrawRegions()\n      debug.selectAll('.circle').remove()\n      if (grid.style('display') === 'inline') {toggleGrid.click()}\n      if (labels.style('display') === 'none') {toggleLabels.click()}\n      $('#countriesBottom').children().show()\n      $('#countriesManuallyButtons, #countriesRegenerateButtons').hide()\n      $('.selected').removeClass('selected')\n      $('div[data-sortby=\\'expansion\\'],.statePower, .icon-resize-full').addClass('hidden')\n      $('div[data-sortby=\\'cells\\'],.stateCells, .icon-check-empty').removeClass('hidden')\n      customization = 0\n      restoreDefaultEvents()\n    }\n    if (id === 'countriesApply') {$('#countriesManuallyCancel').click()}\n    if (id === 'countriesRandomize') {\n      const mod = +powerInput.value * 2\n      $('.statePower').each(function(e, i) {\n        const state = +(this.parentNode.id).slice(5)\n        if (states[state].capital === 'neutral') return\n        const power = _.round(Math.random() * mod / 2 + 1, 1)\n        $(this).val(power)\n        $(this).parent().attr('data-expansion', power)\n        states[state].power = power\n      })\n      regenerateCountries()\n    }\n    if (id === 'countriesAddM' || id === 'countriesAddR' || id === 'countriesAddG') {\n      let i = states.length\n      // move neutrals to the last line\n      if (states[i - 1].capital === 'neutral') {\n        states[i - 1].i = i\n        i -= 1\n      }\n      var name = generateStateName(0)\n      const color = colors20(i)\n      states.push({\n        i,\n        color,\n        name,\n        capital: 'select',\n        cells: 0,\n        burgs: 0,\n        urbanPopulation: 0,\n        ruralPopulation: 0,\n        area: 0,\n        power: 1\n      })\n      states.sort(function(a, b) {return a.i - b.i})\n      editCountries()\n    }\n    if (id === 'countriesRegenerateNames') {\n      const editor = d3.select('#countriesBody')\n      states.forEach(function(s) {\n        if (s.capital === 'neutral') return\n        s.name = generateStateName(s.i)\n        labels.select('#regionLabel' + s.i).text(s.name)\n        editor.select('#state' + s.i).select('.stateName').attr('value', s.name)\n      })\n    }\n    if (id === 'countriesPercentage') {\n      var el = $('#countriesEditor')\n      if (el.attr('data-type') === 'absolute') {\n        el.attr('data-type', 'percentage')\n        const totalCells = land.length\n        const totalBurgs = +countriesFooterBurgs.innerHTML\n        let totalArea = countriesFooterArea.innerHTML\n        totalArea = getInteger(totalArea.split(' ')[0])\n        const totalPopulation = getInteger(countriesFooterPopulation.innerHTML)\n        $('#countriesBody > .states').each(function() {\n          const cells = Math.round($(this).attr('data-cells') / totalCells * 100)\n          const burgs = Math.round($(this).attr('data-burgs') / totalBurgs * 100)\n          const area = Math.round($(this).attr('data-area') / totalArea * 100)\n          const population = Math.round($(this).attr('data-population') / totalPopulation * 100)\n          $(this).children().filter('.stateCells').text(cells + '%')\n          $(this).children().filter('.stateBurgs').text(burgs + '%')\n          $(this).children().filter('.stateArea').text(area + '%')\n          $(this).children().filter('.statePopulation').val(population + '%')\n        })\n      } else {\n        el.attr('data-type', 'absolute')\n        editCountries()\n      }\n    }\n    if (id === 'countriesExport') {\n      if ($('.statePower').length === 0) {return}\n      const unit = areaUnit.value === 'square' ? distanceUnit.value + '2' : areaUnit.value\n      let data = 'Country,Capital,Cells,Burgs,Area (' + unit + '),Population\\n' // countries headers\n      $('#countriesBody > .states').each(function() {\n        const country = $(this).attr('data-country')\n        if (country === 'bottom') {data += 'neutral,'} else {data += country + ','}\n        const capital = $(this).attr('data-capital')\n        if (capital === 'bottom' || capital === 'select') {data += ','} else {\n          data += capital + ','\n        }\n        data += $(this).attr('data-cells') + ','\n        data += $(this).attr('data-burgs') + ','\n        data += $(this).attr('data-area') + ','\n        const population = +$(this).attr('data-population')\n        data += population + '\\n'\n      })\n      data += '\\nBurg,Country,Culture,Population\\n' // burgs headers\n      manors.map(function(m) {\n        if (m.region === 'removed') return // skip removed burgs\n        data += m.name + ','\n        const country = m.region === 'neutral' ? 'neutral' : states[m.region].name\n        data += country + ','\n        data += cultures[m.culture].name + ','\n        const population = m.population * urbanization.value * populationRate.value * 1000\n        data += population + '\\n'\n      })\n      const dataBlob = new Blob([data], {type: 'text/plain'})\n      const url = window.URL.createObjectURL(dataBlob)\n      const link = document.createElement('a')\n      document.body.appendChild(link)\n      link.download = 'countries_data' + Date.now() + '.csv'\n      link.href = url\n      link.click()\n      window.setTimeout(function() {window.URL.revokeObjectURL(url)}, 2000)\n    }\n\n    if (id === 'burgNamesImport') burgsListToLoad.click()\n\n    if (id === 'removeCountries') {\n      alertMessage.innerHTML = `Are you sure you want remove all countries?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove countries',\n        buttons: {\n          Cancel: function() {$(this).dialog('close')},\n          Remove: function() {\n            $(this).dialog('close')\n            $('#countriesBody').empty()\n            manors.map(function(m) {m.region = 'neutral'})\n            land.map(function(l) {l.region = 'neutral'})\n            states.map(function(s) {\n              const c = +s.capital\n              if (isNaN(c)) return\n              moveBurgToGroup(c, 'towns')\n            })\n            removeAllLabelsInGroup('countries')\n            regions.selectAll('path').remove()\n            states = []\n            states.push({i: 0, color: 'neutral', capital: 'neutral', name: 'Neutrals'})\n            recalculateStateData(0)\n            if ($('#burgsEditor').is(':visible')) {$('#burgsEditor').dialog('close')}\n            editCountries()\n          }\n        }\n      })\n    }\n    if (id === 'removeBurgs') {\n      alertMessage.innerHTML =\n        `Are you sure you want to remove all burgs associated with the country?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove associated burgs',\n        buttons: {\n          Cancel: function() {$(this).dialog('close')},\n          Remove: function() {\n            $(this).dialog('close')\n            const state = +$('#burgsEditor').attr('data-state')\n            const region = states[state].capital === 'neutral' ? 'neutral' : state\n            $('#burgsBody').empty()\n            manors.map(function(m) {\n              if (m.region !== region) {return}\n              m.region = 'removed'\n              cells[m.cell].manor = undefined\n              labels.select('[data-id=\\'' + m.i + '\\']').remove()\n              icons.selectAll('[data-id=\\'' + m.i + '\\']').remove()\n            })\n            states[state].urbanPopulation = 0\n            states[state].burgs = 0\n            states[state].capital = 'select'\n            if ($('#countriesEditor').is(':visible')) {\n              editCountries()\n              $('#burgsEditor').dialog('moveToTop')\n            }\n            burgsFooterBurgs.innerHTML = 0\n            burgsFooterPopulation.value = 0\n          }\n        }\n      })\n    }\n    if (id === 'changeCapital') {\n      if ($(this).hasClass('pressed')) {\n        $(this).removeClass('pressed')\n      } else {\n        $('.pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n      }\n    }\n    if (id === 'regenerateBurgNames') {\n      var s = +$('#burgsEditor').attr('data-state')\n      $('.burgName').each(function(e, i) {\n        const b = +(this.parentNode.id).slice(5)\n        const name = generateName(manors[b].culture)\n        $(this).val(name)\n        $(this).parent().attr('data-burg', name)\n        manors[b].name = name\n        labels.select('[data-id=\\'' + b + '\\']').text(name)\n      })\n      if ($('#countriesEditor').is(':visible')) {\n        if (states[s].capital === 'neutral') {return}\n        var c = states[s].capital\n        $('#state' + s).attr('data-capital', manors[c].name)\n        $('#state' + s + ' > .stateCapital').val(manors[c].name)\n      }\n    }\n    if (id === 'burgAdd') {\n      var state = +$('#burgsEditor').attr('data-state')\n      clickToAdd() // to load on click event function\n      $('#addBurg').click().attr('data-state', state)\n    }\n    if (id === 'toggleScaleBar') {$('#scaleBar').toggleClass('hidden')}\n    if (id === 'addRuler') {\n      $('#ruler').show()\n      const rulerNew = ruler.append('g').attr('class', 'linear')\n                            .call(d3.drag().on('start', elementDrag))\n      const factor = _.round(1 / Math.pow(scale, 0.3), 1)\n      const y = Math.floor(Math.random() * graphHeight * 0.5 + graphHeight * 0.25)\n      const x1 = graphWidth * 0.2, x2 = graphWidth * 0.8\n      const dash = _.round(30 / distanceScale.value, 2)\n      rulerNew.append('line').attr('x1', x1).attr('y1', y).attr('x2', x2).attr('y2', y)\n              .attr('class', 'white').attr('stroke-width', factor)\n      rulerNew.append('line').attr('x1', x1).attr('y1', y).attr('x2', x2).attr('y2', y)\n              .attr('class', 'gray').attr('stroke-width', factor).attr('stroke-dasharray', dash)\n      rulerNew.append('circle').attr('r', 2 * factor).attr('stroke-width', 0.5 * factor)\n              .attr('cx', x1).attr('cy', y).attr('data-edge', 'left')\n              .call(d3.drag().on('drag', rulerEdgeDrag))\n      rulerNew.append('circle').attr('r', 2 * factor).attr('stroke-width', 0.5 * factor)\n              .attr('cx', x2).attr('cy', y).attr('data-edge', 'rigth')\n              .call(d3.drag().on('drag', rulerEdgeDrag))\n      rulerNew.append('circle').attr('r', 1.2 * factor).attr('stroke-width', 0.3 * factor)\n              .attr('cx', graphWidth / 2).attr('cy', y).attr('class', 'center')\n              .call(d3.drag().on('start', rulerCenterDrag))\n      const dist = Math.round(x2 - x1)\n      const label = Math.round(dist * distanceScale.value) + ' ' + distanceUnit.value\n      rulerNew.append('text').attr('x', graphWidth / 2).attr('y', y).attr('dy', -1)\n              .attr('data-dist', dist).text(label).text(label).on('click', removeParent)\n              .attr('font-size', 10 * factor)\n      return\n    }\n    if (id === 'addOpisometer' || id === 'addPlanimeter') {\n      if ($(this).hasClass('pressed')) {\n        restoreDefaultEvents()\n        $(this).removeClass('pressed')\n      } else {\n        $(this).addClass('pressed')\n        viewbox.style('cursor', 'crosshair').call(drag)\n      }\n      return\n    }\n    if (id === 'removeAllRulers') {\n      if ($('#ruler > g').length < 1) {return}\n      alertMessage.innerHTML = `Are you sure you want to remove all placed rulers?`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove all rulers',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            $('#ruler > g').remove()\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n      return\n    }\n    if (id === 'editHeightmap') {$('#customizeHeightmap').slideToggle()}\n    if (id === 'fromScratch') {\n      alertMessage.innerHTML =\n        'Are you sure you want to clear the map? All progress will be lost'\n      $('#alert').dialog({\n        resizable: false, title: 'Clear map',\n        buttons: {\n          Clear: function() {\n            closeDialogs()\n            undraw()\n            placePoints()\n            calculateVoronoi(points)\n            detectNeighbors('grid')\n            drawScaleBar()\n            customizeHeightmap()\n            openBrushesPanel()\n            $(this).dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    }\n    if (id === 'fromHeightmap') {\n      const message = `Hightmap is a basic element on which secondary data (rivers, burgs, countries etc) is based.\n    If you want to significantly change the hightmap, it may be better to clean up all the secondary data\n    and let the system to re-generate it based on the updated hightmap. In case of minor changes, you can keep the data.\n    Newly added lands will be considered as neutral. Burgs located on a removed land cells will be deleted.\n    Rivers and small lakes will be re-gerenated based on updated heightmap. Routes won't be regenerated.`\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        resizable: false, title: 'Edit Heightmap',\n        buttons: {\n          'Clean up': function() {\n            editHeightmap('clean')\n            $(this).dialog('close')\n          },\n          Keep: function() {\n            $(this).dialog('close')\n            editHeightmap('keep')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n      return\n    }\n    // heightmap customization buttons\n    if (customization === 1) {\n      if (id === 'paintBrushes') {openBrushesPanel()}\n      if (id === 'rescaleExecute') {\n        const subject = rescaleLower.value + '-' + rescaleHigher.value\n        const sign = conditionSign.value\n        let modifier = rescaleModifier.value\n        if (sign === '×') {modifyHeights(subject, 0, +modifier)}\n        if (sign === '÷') {modifyHeights(subject, 0, (1 / modifier))}\n        if (sign === '+') {modifyHeights(subject, +modifier, 1)}\n        if (sign === '-') {modifyHeights(subject, (-1 * modifier), 1)}\n        if (sign === '^') {modifyHeights(subject, 0, '^' + modifier)}\n        updateHeightmap()\n        updateHistory()\n      }\n      if (id === 'rescaleButton') {\n        $('#modifyButtons').children().not('#rescaleButton, .condition').toggle()\n      }\n      if (id === 'rescaleCondButton') {\n        $('#modifyButtons').children().not('#rescaleCondButton, #rescaler').toggle()\n      }\n      if (id === 'undo' || id === 'templateUndo') {restoreHistory(historyStage - 1)}\n      if (id === 'redo' || id === 'templateRedo') {restoreHistory(historyStage + 1)}\n      if (id === 'smoothHeights') {\n        smoothHeights(4)\n        updateHeightmap()\n        updateHistory()\n      }\n      if (id === 'disruptHeights') {\n        disruptHeights()\n        updateHeightmap()\n        updateHistory()\n      }\n      if (id === 'getMap') getMap()\n      if (id === 'applyTemplate') {\n        if ($('#templateEditor').is(':visible')) {return}\n        $('#templateEditor').dialog({\n          title: 'Template Editor',\n          minHeight: 'auto', width: 'auto', resizable: false,\n          position: {my: 'right top', at: 'right-10 top+10', of: 'svg'}\n        })\n      }\n      if (id === 'convertImage') {convertImage()}\n      if (id === 'convertImageGrid') {$('#grid').fadeToggle()}\n      if (id === 'convertImageHeights') {$('#landmass').fadeToggle()}\n      if (id === 'perspectiveView') {\n        if ($('#perspectivePanel').is(':visible')) return\n        $('#perspectivePanel').dialog({\n          title: 'Perspective View',\n          width: 520, height: 190,\n          position: {my: 'center center', at: 'center center', of: 'svg'}\n        })\n        drawPerspective()\n        return\n      }\n    }\n    if (parent === 'mapFilters') {\n      $('svg').attr('filter', '')\n      if ($(this).hasClass('pressed')) {\n        $('#mapFilters .pressed').removeClass('pressed')\n      } else {\n        $('#mapFilters .pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        $('svg').attr('filter', 'url(#filter-' + id + ')')\n      }\n      return\n    }\n    if (id === 'updateFullscreen') {\n      mapWidthInput.value = window.innerWidth\n      mapHeightInput.value = window.innerHeight\n      localStorage.removeItem('mapHeight')\n      localStorage.removeItem('mapWidth')\n      changeMapSize()\n    }\n    if (id === 'zoomExtentDefault') {\n      zoomExtentMin.value = 1\n      zoomExtentMax.value = 20\n      zoom.scaleExtent([1, 20]).scaleTo(svg, 1)\n    }\n    if (id === 'saveButton') {$('#saveDropdown').slideToggle()}\n    if (id === 'loadMap') {mapToLoad.click()}\n    if (id === 'zoomReset') {resetZoom(1000)}\n    if (id === 'zoomPlus') {\n      scale += 1\n      if (scale > 40) {scale = 40}\n      invokeActiveZooming()\n    }\n    if (id === 'zoomMinus') {\n      scale -= 1\n      if (scale <= 1) {\n        scale = 1\n        viewX = 0\n        viewY = 0\n      }\n      invokeActiveZooming()\n    }\n    if (id === 'styleFontPlus' || id === 'styleFontMinus') {\n      var el = viewbox.select('#' + styleElementSelect.value)\n      var mod = id === 'styleFontPlus' ? 1.1 : 0.9\n      el.selectAll('g').each(function() {\n        const el = d3.select(this)\n        let size = _.round(el.attr('data-size') * mod, 2)\n        if (size < 2) {size = 2}\n        el.attr('data-size', size).attr('font-size', _.round((size + (size / scale)) / 2, 2))\n      })\n      invokeActiveZooming()\n      return\n    }\n    if (id === 'brushClear') {\n      if (customization === 1) {\n        var message = 'Are you sure you want to clear the map?'\n        alertMessage.innerHTML = message\n        $('#alert').dialog({\n          resizable: false, title: 'Clear map',\n          buttons: {\n            Clear: function() {\n              $(this).dialog('close')\n              viewbox.style('cursor', 'crosshair').call(drag)\n              landmassCounter.innerHTML = '0'\n              $('#landmass').empty()\n              heights = new Uint8Array(heights.length)\n              // clear history\n              history = []\n              historyStage = 0\n              updateHistory()\n              redo.disabled = templateRedo.disabled = true\n              undo.disabled = templateUndo.disabled = true\n            },\n            Cancel: function() {$(this).dialog('close')}\n          }\n        })\n      } else {\n        start.click()\n      }\n    }\n    if (id === 'templateComplete') getMap()\n    if (id === 'convertColorsMinus') {\n      var current = +convertColors.value - 1\n      if (current < 4) {current = 3}\n      convertColors.value = current\n      heightsFromImage(current)\n    }\n    if (id === 'convertColorsPlus') {\n      var current = +convertColors.value + 1\n      if (current > 255) {current = 256}\n      convertColors.value = current\n      heightsFromImage(current)\n    }\n    if (id === 'convertOverlayButton') {\n      $('#convertImageButtons').children().not(this).not('#convertColors').toggle()\n    }\n    if (id === 'convertAutoLum') {autoAssing('lum')}\n    if (id === 'convertAutoHue') {autoAssing('hue')}\n    if (id === 'convertComplete') {completeConvertion()}\n  })\n\n  // support save options\n  $('#saveDropdown > div').click(function() {\n    const id = this.id\n    let dns_allow_popup_message = localStorage.getItem('dns_allow_popup_message')\n    if (!dns_allow_popup_message) {\n      localStorage.clear()\n      let message = 'Generator uses pop-up window to download files. '\n      message += 'Please ensure your browser does not block popups. '\n      message += 'Please check browser settings and turn off adBlocker if it is enabled'\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        title: 'File saver. Please enable popups!',\n        buttons: {\n          'Don\\'t show again': function() {\n            localStorage.setItem('dns_allow_popup_message', true)\n            $(this).dialog('close')\n          },\n          Close: function() {$(this).dialog('close')}\n        },\n        position: {my: 'center', at: 'center', of: 'svg'}\n      })\n    }\n    if (id === 'saveMap') {saveMap()}\n    if (id === 'saveSVG') {saveAsImage('svg')}\n    if (id === 'savePNG') {saveAsImage('png')}\n    $('#saveDropdown').slideUp('fast')\n  })\n\n  function editHeightmap(type) {\n    closeDialogs()\n    const regionData = [], cultureData = []\n    if (type !== 'clean') {\n      for (let i = 0; i < points.length; i++) {\n        let cell = diagram.find(points[i][0], points[i][1]).index\n        // if closest cell is a small lake, try to find a land neighbor\n        if (cells[cell].lake === 2) cells[cell].neighbors.forEach(function(n) {\n          if (cells[n].height >= 20) {cell = n }\n        })\n        let region = cells[cell].region\n        if (region === undefined) region = -1\n        regionData.push(region)\n        let culture = cells[cell].culture\n        if (culture === undefined) culture = -1\n        cultureData.push(culture)\n      }\n    } else {undraw()}\n    calculateVoronoi(points)\n    detectNeighbors('grid')\n    drawScaleBar()\n    if (type === 'keep') {\n      svg.selectAll(\n        '#lakes, #coastline, #terrain, #rivers, #grid, #terrs, #landmass, #ocean, #regions')\n         .selectAll('path, circle, line').remove()\n      svg.select('#shape').remove()\n      for (let i = 0; i < points.length; i++) {\n        if (regionData[i] !== -1) cells[i].region = regionData[i]\n        if (cultureData[i] !== -1) cells[i].culture = cultureData[i]\n      }\n    }\n    mockHeightmap()\n    customizeHeightmap()\n    openBrushesPanel()\n  }\n\n  function openBrushesPanel() {\n    if ($('#brushesPanel').is(':visible')) {return}\n    $('#brushesPanel').dialog({\n      title: 'Paint Brushes',\n      minHeight: 40, width: 'auto', maxWidth: 200, resizable: false,\n      position: {my: 'right top', at: 'right-10 top+10', of: 'svg'}\n    }).on('dialogclose', function() {\n      restoreDefaultEvents()\n      $('#brushesButtons > .pressed').removeClass('pressed')\n    })\n\n    if (modules.openBrushesPanel) return\n    modules.openBrushesPanel = true\n\n    $('#brushesButtons > button').on('click', function() {\n      const rSlider = $('#brushRadiusLabel, #brushRadius')\n      debug.selectAll('.circle, .tag, .line').remove()\n      if ($(this).hasClass('pressed')) {\n        $(this).removeClass('pressed')\n        restoreDefaultEvents()\n        rSlider.attr('disabled', true).addClass('disabled')\n      } else {\n        $('#brushesButtons > .pressed').removeClass('pressed')\n        $(this).addClass('pressed')\n        viewbox.style('cursor', 'crosshair')\n        const id = this.id\n        if (id === 'brushRange' || id === 'brushTrough') {\n          viewbox.on('click', placeLinearFeature)\n        } // on click brushes\n        else {viewbox.call(drag).on('click', null)} // on drag brushes\n        if ($(this).hasClass('feature')) {\n          rSlider.attr('disabled', true).addClass('disabled')\n        } else {rSlider.attr('disabled', false).removeClass('disabled')}\n      }\n    })\n  }\n\n  function drawPerspective() {\n    console.time('drawPerspective')\n    const width = 320, height = 180\n    const wRatio = graphWidth / width, hRatio = graphHeight / height\n    const lineCount = 320, lineGranularity = 90\n    const perspective = document.getElementById('perspective')\n    const pContext = perspective.getContext('2d')\n    const lines = []\n    let i = lineCount\n    while (i--) {\n      const x = i / lineCount * width | 0\n      const canvasPoints = []\n      lines.push(canvasPoints)\n      let j = Math.floor(lineGranularity)\n      while (j--) {\n        const y = j / lineGranularity * height | 0\n        let index = getCellIndex(x * wRatio, y * hRatio)\n        let h = heights[index] - 20\n        if (h < 1) h = 0\n        canvasPoints.push([x, y, h])\n      }\n    }\n    pContext.clearRect(0, 0, perspective.width, perspective.height)\n    for (let canvasPoints of lines) {\n      for (let i = 0; i < canvasPoints.length - 1; i++) {\n        const pt1 = canvasPoints[i]\n        const pt2 = canvasPoints[i + 1]\n        const avHeight = (pt1[2] + pt2[2]) / 200\n        pContext.beginPath()\n        pContext.moveTo(...transformPt(pt1))\n        pContext.lineTo(...transformPt(pt2))\n        let clr = 'rgb(81, 103, 169)' // water\n        if (avHeight !== 0) {clr = color(1 - avHeight - 0.2)}\n        pContext.strokeStyle = clr\n        pContext.stroke()\n      }\n      for (let i = 0; i < canvasPoints.length - 1; i++) {\n\n      }\n    }\n    console.timeEnd('drawPerspective')\n  }\n\n  // get square grid cell index based on coords\n  function getCellIndex(x, y) {\n    const index = diagram.find(x, y).index\n    // let cellsX = Math.round(graphWidth / spacing);\n    // let index = Math.ceil(y / spacing) * cellsX + Math.round(x / spacing);\n    return index\n  }\n\n  function transformPt(pt) {\n    const width = 320, maxHeight = 0.2\n    var [x, y] = projectIsometric(pt[0], pt[1])\n    return [x + width / 2 + 10, y + 10 - pt[2] * maxHeight]\n  }\n\n  function projectIsometric(x, y) {\n    const scale = 1, yProj = 4\n    return [(x - y) * scale, (x + y) / yProj * scale]\n  }\n\n  // Execute custom template\n  $('#templateRun').on('click', function() {\n    if (customization !== 1) return\n    let steps = $('#templateBody > div').length\n    if (!steps) return\n    heights = new Uint8Array(heights.length) // clean all heights\n    for (let step = 1; step <= steps; step++) {\n      const type = $('#templateBody div:nth-child(' + step + ')').attr('data-type')\n      if (type === 'Mountain') {\n        addMountain()\n        continue\n      }\n      let count = $('#templateBody div:nth-child(' + step + ') .templateElCount').val()\n      const dist = $('#templateBody div:nth-child(' + step + ') .templateElDist').val()\n      if (count) {\n        if (count[0] !== '-' && count.includes('-')) {\n          const lim = count.split('-')\n          count = Math.floor(Math.random() * (+lim[1] - +lim[0] + 1) + +lim[0])\n        } else {\n          count = +count // parse string\n        }\n      }\n      if (type === 'Hill') {addHill(count, +dist)}\n      if (type === 'Pit') {addPit(count)}\n      if (type === 'Range') {addRange(count)}\n      if (type === 'Trough') {addRange(-1 * count)}\n      if (type === 'Strait') {addStrait(count)}\n      if (type === 'Add') {modifyHeights(dist, count, 1)}\n      if (type === 'Multiply') {modifyHeights(dist, 0, count)}\n      if (type === 'Smooth') {smoothHeights(count)}\n    }\n    mockHeightmap()\n    updateHistory()\n  })\n\n  $('#templateToLoad').change(function() {\n    const fileToLoad = this.files[0]\n    this.value = ''\n    const fileReader = new FileReader()\n    fileReader.onload = function(fileLoadedEvent) {\n      const dataLoaded = fileLoadedEvent.target.result\n      const data = dataLoaded.split('\\r\\n')\n      $('#templateBody').empty()\n      if (data.length > 0) {\n        $('#templateBody').attr('data-changed', 1)\n        $('#templateSelect').attr('data-prev', 'templateCustom').val('templateCustom')\n      }\n      for (let i = 0; i < data.length; i++) {\n        const line = data[i].split(' ')\n        this.addStep(line[0], line[1], line[2])\n      }\n    }\n    fileReader.readAsText(fileToLoad, 'UTF-8')\n  })\n\n  // Image to Heightmap Converter dialog\n  function convertImage() {\n    canvas.width = svgWidth\n    canvas.height = svgHeight\n    // turn off paint brushes drag and cursor\n    $('.pressed').removeClass('pressed')\n    restoreDefaultEvents()\n    const div = d3.select('#colorScheme')\n    if (div.selectAll('*').size() === 0) {\n      for (let i = 0; i <= 100; i++) {\n        let width = i < 20 || i > 70 ? '1px' : '3px'\n        if (i === 0) width = '4px'\n        const clr = color(1 - i / 100)\n        const style = 'background-color: ' + clr + '; width: ' + width\n        div.append('div').attr('data-color', i).attr('style', style)\n      }\n      div.selectAll('*').on('touchmove mousemove', showHeight).on('click', assignHeight)\n    }\n    if ($('#imageConverter').is(':visible')) {return}\n    $('#imageConverter').dialog({\n      title: 'Image to Heightmap Converter',\n      minHeight: 30, width: 260, resizable: false,\n      position: {my: 'right top', at: 'right-10 top+10', of: 'svg'}\n    })\n                        .on('dialogclose', function() {completeConvertion()})\n  }\n\n  // Load image to convert\n  $('#convertImageLoad').on('click', function() {imageToLoad.click()})\n  $('#imageToLoad').change(function() {\n    console.time('loadImage')\n    // set style\n    resetZoom()\n    grid.attr('stroke-width', .2)\n    // load image\n    const file = this.files[0]\n    this.value = '' // reset input value to get triggered if the same file is uploaded\n    const reader = new FileReader()\n    const img = new Image\n    // draw image\n    img.onload = function() {\n      ctx.drawImage(img, 0, 0, svgWidth, svgHeight)\n      heightsFromImage(+convertColors.value)\n      console.timeEnd('loadImage')\n    }\n    reader.onloadend = function() {img.src = reader.result}\n    reader.readAsDataURL(file)\n  })\n\n  function heightsFromImage(count) {\n    const imageData = ctx.getImageData(0, 0, svgWidth, svgHeight)\n    const data = imageData.data\n    $('#landmass > path, .color-div').remove()\n    $('#landmass, #colorsUnassigned').fadeIn()\n    $('#colorsAssigned').fadeOut()\n    const colors = [], palette = []\n    points.map(function(i) {\n      let x = Math.round(i[0]), y = Math.round(i[1])\n      if (y == svgHeight) {y--}\n      if (x == svgWidth) {x--}\n      const p = (x + y * svgWidth) * 4\n      const r = data[p], g = data[p + 1], b = data[p + 2]\n      colors.push([r, g, b])\n    })\n    const cmap = quantize(colors, count)\n    heights = new Uint8Array(points.length)\n    polygons.map(function(i, d) {\n      const nearest = cmap.nearest(colors[d])\n      const rgb = 'rgb(' + nearest[0] + ', ' + nearest[1] + ', ' + nearest[2] + ')'\n      const hex = toHEX(rgb)\n      if (palette.indexOf(hex) === -1) {palette.push(hex)}\n      landmass.append('path')\n              .attr('d', 'M' + i.join('L') + 'Z').attr('data-i', d)\n              .attr('fill', hex).attr('stroke', hex)\n    })\n    landmass.selectAll('path').on('click', landmassClicked)\n    palette.sort(function(a, b) {return d3.lab(a).b - d3.lab(b).b}).map(function(i) {\n      $('#colorsUnassigned').append(\n        '<div class=\"color-div\" id=\"' + i.substr(1) + '\" style=\"background-color: ' + i + ';\"/>')\n    })\n    $('.color-div').click(selectColor)\n  }\n\n  function landmassClicked() {\n    const color = d3.select(this).attr('fill')\n    $('#' + color.slice(1)).click()\n  }\n\n  function selectColor() {\n    landmass.selectAll('.selectedCell').classed('selectedCell', 0)\n    const el = d3.select(this)\n    if (el.classed('selectedColor')) {\n      el.classed('selectedColor', 0)\n    } else {\n      $('.selectedColor').removeClass('selectedColor')\n      el.classed('selectedColor', 1)\n      $('#colorScheme .hoveredColor').removeClass('hoveredColor')\n      $('#colorsSelectValue').text(0)\n      if (el.attr('data-height')) {\n        const height = el.attr('data-height')\n        $('#colorScheme div[data-color=\\'' + height + '\\']').addClass('hoveredColor')\n        $('#colorsSelectValue').text(height)\n      }\n      const color = '#' + d3.select(this).attr('id')\n      landmass.selectAll('path').classed('selectedCell', 0)\n      landmass.selectAll('path[fill=\\'' + color + '\\']').classed('selectedCell', 1)\n    }\n  }\n\n  function showHeight() {\n    let el = d3.select(this)\n    let height = el.attr('data-color')\n    $('#colorsSelectValue').text(height)\n    $('#colorScheme .hoveredColor').removeClass('hoveredColor')\n    el.classed('hoveredColor', 1)\n  }\n\n  function assignHeight() {\n    const sel = $('.selectedColor')[0]\n    const height = +d3.select(this).attr('data-color')\n    const rgb = color(1 - height / 100)\n    const hex = toHEX(rgb)\n    sel.style.backgroundColor = rgb\n    sel.setAttribute('data-height', height)\n    const cur = '#' + sel.id\n    sel.id = hex.substr(1)\n    landmass.selectAll('.selectedCell').each(function() {\n      d3.select(this).attr('fill', hex).attr('stroke', hex)\n      let i = +d3.select(this).attr('data-i')\n      heights[i] = height\n    })\n    const parent = sel.parentNode\n    if (parent.id === 'colorsUnassigned') {\n      colorsAssigned.appendChild(sel)\n      $('#colorsAssigned').fadeIn()\n      if ($('#colorsUnassigned .color-div').length < 1) {$('#colorsUnassigned').fadeOut()}\n    }\n    if ($('#colorsAssigned .color-div').length > 1) {sortAssignedColors()}\n  }\n\n  // sort colors based on assigned height\n  function sortAssignedColors() {\n    const data = []\n    const colors = d3.select('#colorsAssigned').selectAll('.color-div')\n    colors.each(function(d) {\n      const id = d3.select(this).attr('id')\n      const height = +d3.select(this).attr('data-height')\n      data.push({id, height})\n    })\n    data.sort(function(a, b) {return a.height - b.height}).map(function(i) {\n      $('#colorsAssigned').append($('#' + i.id))\n    })\n  }\n\n  // auto assign color based on luminosity or hue\n  function autoAssing(type) {\n    const imageData = ctx.getImageData(0, 0, svgWidth, svgHeight)\n    const data = imageData.data\n    $('#landmass > path, .color-div').remove()\n    $('#colorsAssigned').fadeIn()\n    $('#colorsUnassigned').fadeOut()\n    polygons.forEach(function(i, d) {\n      let x = Math.round(i.data[0]), y = Math.round(i.data[1])\n      if (y == svgHeight) y--\n      if (x == svgWidth) x--\n      const p = (x + y * svgWidth) * 4\n      const r = data[p], g = data[p + 1], b = data[p + 2]\n      const lab = d3.lab('rgb(' + r + ', ' + g + ', ' + b + ')')\n      if (type === 'hue') {\n        var normalized = _.round(normalize(lab.b + lab.a / 2, -50, 200), 2)\n      } else {\n        var normalized = _.round(normalize(lab.l, 0, 100), 2)\n      }\n      const rgb = color(1 - normalized)\n      const hex = toHEX(rgb)\n      heights[d] = normalized * 100\n      landmass.append('path').attr('d', 'M' + i.join('L') + 'Z').attr('data-i', d)\n              .attr('fill', hex).attr('stroke', hex)\n    })\n    let unique = [...new Set(heights)].sort()\n    unique.forEach(function(h) {\n      const rgb = color(1 - h / 100)\n      const hex = toHEX(rgb)\n      $('#colorsAssigned').append('<div class=\"color-div\" id=\"' + hex.substr(\n        1) + '\" data-height=\"' + h + '\" style=\"background-color: ' + hex + ';\"/>')\n    })\n    $('.color-div').click(selectColor)\n  }\n\n  function normalize(val, min, max) {\n    let normalized = (val - min) / (max - min)\n    if (normalized < 0) {normalized = 0}\n    if (normalized > 1) {normalized = 1}\n    return normalized\n  }\n\n  function completeConvertion() {\n    mockHeightmap()\n    restartHistory()\n    $('.color-div').remove()\n    $('#colorsAssigned, #colorsUnassigned').fadeOut()\n    grid.attr('stroke-width', .1)\n    canvas.style.opacity = convertOverlay.value = convertOverlayValue.innerHTML = 0\n    // turn on paint brushes drag and cursor\n    viewbox.style('cursor', 'crosshair').call(drag)\n    $('#imageConverter').dialog('close')\n  }\n\n  // Clear the map\n  function undraw() {\n    viewbox.selectAll('path, circle, line, text, use, #ruler > g').remove()\n    defs.selectAll('*').remove()\n    landmass.select('rect').remove()\n    cells = [], land = [], riversData = [], manors = [], states = [], features = [], queue = []\n  }\n\n  // Enter Heightmap Customization mode\n  function customizeHeightmap() {\n    customization = 1\n    tip('Heightmap customization mode is active. Click on \"Complete\" to finalize the Heightmap',\n      true)\n    $('#getMap').removeClass('buttonoff').addClass('glow')\n    resetZoom()\n    landmassCounter.innerHTML = '0'\n    $('#grid').fadeIn()\n    $('#toggleGrid').removeClass('buttonoff')\n    restartHistory()\n    $('#customizationMenu').slideDown()\n    $('#openEditor').slideUp()\n  }\n\n  // Remove all customization related styles, reset values\n  function exitCustomization() {\n    customization = 0\n    tip('', true)\n    canvas.style.opacity = 0\n    $('#customizationMenu').slideUp()\n    $('#getMap').addClass('buttonoff').removeClass('glow')\n    $('#landmass').empty()\n    $('#grid').empty().fadeOut()\n    $('#toggleGrid').addClass('buttonoff')\n    restoreDefaultEvents()\n    if (!$('#toggleHeight').hasClass('buttonoff')) {toggleHeight()}\n    closeDialogs()\n    history = []\n    historyStage = 0\n    $('#customizeHeightmap').slideUp()\n    $('#openEditor').slideDown()\n    debug.selectAll('.circle, .tag, .line').remove()\n  }\n\n  // open editCountries dialog\n  function editCountries() {\n    if (cults.selectAll('path').size()) $('#toggleCultures').click()\n    if (regions.style('display') === 'none') $('#toggleCountries').click()\n    layoutPreset.value = 'layoutPolitical'\n    $('#countriesBody').empty()\n    $('#countriesHeader').children().removeClass(\n      'icon-sort-name-up icon-sort-name-down icon-sort-number-up icon-sort-number-down')\n    let totalArea = 0, totalBurgs = 0, unit, areaConv\n    if (areaUnit.value === 'square') {unit = ' ' + distanceUnit.value + '²'} else {\n      unit = ' ' + areaUnit.value\n    }\n    let totalPopulation = 0\n    for (let s = 0; s < states.length; s++) {\n      $('#countriesBody').append('<div class=\"states\" id=\"state' + s + '\"></div>')\n      const el = $('#countriesBody div:last-child')\n      const burgsCount = states[s].burgs\n      totalBurgs += burgsCount\n      // calculate user-friendly area and population\n      const area = Math.round(states[s].area * Math.pow(distanceScale.value, 2))\n      totalArea += area\n      areaConv = si(area) + unit\n      const urban = Math.round(states[s].urbanPopulation * urbanization.value * populationRate.value)\n      const rural = _.round(states[s].ruralPopulation * populationRate.value)\n      var population = (urban + rural) * 1000\n      totalPopulation += population\n      const populationConv = si(population)\n      const title = '\\'Total population: ' + populationConv + '; Rural population: ' + rural + 'K; Urban population: ' + urban + 'K\\''\n      let neutral = states[s].color === 'neutral' || states[s].capital === 'neutral'\n      // append elements to countriesBody\n      if (!neutral) {\n        el.append(\n          '<input onmouseover=\"tip(\\'Country color. Click to change\\')\" class=\"stateColor\" type=\"color\" value=\"' + states[s].color + '\"/>')\n        el.append(\n          '<input onmouseover=\"tip(\\'Country name. Click and type to change\\')\" class=\"stateName\" value=\"' + states[s].name + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n        var capital = states[s].capital !== 'select' ? manors[states[s].capital].name : 'select'\n        if (capital === 'select') {\n          el.append(\n            '<button onmouseover=\"tip(\\'Click on map to select a capital or to create a new capital\\')\" class=\"selectCapital\" id=\"selectCapital' + s + '\">★ select</button>')\n        } else {\n          el.append(\n            '<span onmouseover=\"tip(\\'Country capital. Click to enlange\\')\" class=\"icon-star-empty enlange\"></span>')\n          el.append(\n            '<input onmouseover=\"tip(\\'Capital name. Click and type to rename\\')\" class=\"stateCapital\" value=\"' + capital + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n        }\n        el.append(\n          '<span onmouseover=\"tip(\\'Country expansionism (defines competitive size)\\')\" class=\"icon-resize-full hidden\"></span>')\n        el.append(\n          '<input onmouseover=\"tip(\\'Capital expansionism (defines competitive size)\\')\" class=\"statePower hidden\" type=\"number\" min=\"0\" max=\"99\" step=\"0.1\" value=\"' + states[s].power + '\"/>')\n      } else {\n        el.append('<input class=\"stateColor placeholder\" disabled type=\"color\"/>')\n        el.append(\n          '<input onmouseover=\"tip(\\'Neutral burgs are united into this group. Click to change the group name\\')\" class=\"stateName italic\" id=\"stateName' + s + '\" value=\"' + states[s].name + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n        el.append('<span class=\"icon-star-empty placeholder\"></span>')\n        el.append('<input class=\"stateCapital placeholder\"/>')\n        el.append('<span class=\"icon-resize-full hidden placeholder\"></span>')\n        el.append('<input class=\"statePower hidden placeholder\" value=\"0.0\"/>')\n      }\n      el.append('<span onmouseover=\"tip(\\'Cells count\\')\" class=\"icon-check-empty\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Cells count\\')\" class=\"stateCells\">' + states[s].cells + '</div>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Burgs count. Click to see a full list\\')\" style=\"padding-right: 1px\" class=\"stateBIcon icon-dot-circled\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Burgs count. Click to see a full list\\')\" class=\"stateBurgs\">' + burgsCount + '</div>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Country area: ' + (area + unit) + '\\')\" style=\"padding-right: 4px\" class=\"icon-map-o\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Country area: ' + (area + unit) + '\\')\" class=\"stateArea\">' + areaConv + '</div>')\n      el.append('<span onmouseover=\"tip(' + title + ')\" class=\"icon-male\"></span>')\n      el.append(\n        '<input onmouseover=\"tip(' + title + ')\" class=\"statePopulation\" value=\"' + populationConv + '\">')\n      if (!neutral) {\n        el.append(\n          '<span onmouseover=\"tip(\\'Remove country, all assigned cells will become Neutral\\')\" class=\"icon-trash-empty\"></span>')\n        el.attr('data-country', states[s].name).attr('data-capital', capital)\n          .attr('data-expansion', states[s].power).attr('data-cells', states[s].cells)\n          .attr('data-burgs', states[s].burgs).attr('data-area', area)\n          .attr('data-population', population)\n      } else {\n        el.attr('data-country', 'bottom').attr('data-capital', 'bottom')\n          .attr('data-expansion', 'bottom').attr('data-cells', states[s].cells)\n          .attr('data-burgs', states[s].burgs).attr('data-area', area)\n          .attr('data-population', population)\n      }\n    }\n    // initialize jQuery dialog\n    if (!$('#countriesEditor').is(':visible')) {\n      $('#countriesEditor').dialog({\n        title: 'Countries Editor',\n        minHeight: 'auto', minWidth: Math.min(svgWidth, 390),\n        position: {my: 'right top', at: 'right-10 top+10', of: 'svg'}\n      }).on('dialogclose', function() {\n        if (customization === 2 || customization === 3) {\n          $('#countriesManuallyCancel').click()\n        }\n      })\n    }\n    // restore customization Editor version\n    if (customization === 3) {\n      $('div[data-sortby=\\'expansion\\'],.statePower, .icon-resize-full').removeClass('hidden')\n      $('div[data-sortby=\\'cells\\'],.stateCells, .icon-check-empty').addClass('hidden')\n    } else {\n      $('div[data-sortby=\\'expansion\\'],.statePower, .icon-resize-full').addClass('hidden')\n      $('div[data-sortby=\\'cells\\'],.stateCells, .icon-check-empty').removeClass('hidden')\n    }\n    // populate total line on footer\n    countriesFooterCountries.innerHTML = states.length\n    if (states[states.length - 1].capital === 'neutral') {\n      countriesFooterCountries.innerHTML = states.length - 1\n    }\n    countriesFooterBurgs.innerHTML = totalBurgs\n    countriesFooterArea.innerHTML = si(totalArea) + unit\n    countriesFooterPopulation.innerHTML = si(totalPopulation)\n    // handle events\n    $('#countriesBody .states').hover(focusOnState, unfocusState)\n    $('.enlange').click(function() {\n      const s = +(this.parentNode.id).slice(5)\n      const capital = states[s].capital\n      const l = labels.select('[data-id=\\'' + capital + '\\']')\n      const x = +l.attr('x'), y = +l.attr('y')\n      zoomTo(x, y, 8, 1600)\n    })\n    $('.stateName').on('input', function() {\n      const s = +(this.parentNode.id).slice(5)\n      states[s].name = this.value\n      labels.select('#regionLabel' + s).text(this.value)\n      if ($('#burgsEditor').is(':visible')) {\n        if ($('#burgsEditor').attr('data-state') == s) {\n          const color = '<input title=\"Country color. Click to change\" type=\"color\" class=\"stateColor\" value=\"' + states[s].color + '\"/>'\n          $('div[aria-describedby=\\'burgsEditor\\'] .ui-dialog-title').text('Burgs of ' + this.value)\n                                                                   .prepend(color)\n        }\n      }\n    })\n    $('.states > .stateColor').on('change', function() {\n      const s = +(this.parentNode.id).slice(5)\n      states[s].color = this.value\n      regions.selectAll('.region' + s).attr('fill', this.value).attr('stroke', this.value)\n      if ($('#burgsEditor').is(':visible')) {\n        if ($('#burgsEditor').attr('data-state') == s) {\n          $('.ui-dialog-title > .stateColor').val(this.value)\n        }\n      }\n    })\n    $('.stateCapital').on('input', function() {\n      const s = +(this.parentNode.id).slice(5)\n      const capital = states[s].capital\n      manors[capital].name = this.value\n      labels.select('[data-id=\\'' + capital + '\\']').text(this.value)\n      if ($('#burgsEditor').is(':visible')) {\n        if ($('#burgsEditor').attr('data-state') == s) {\n          $('#burgs' + capital + ' > .burgName').val(this.value)\n        }\n      }\n    }).hover(focusCapital, unfocus)\n    $('.stateBurgs, .stateBIcon').on('click', editBurgs).hover(focusBurgs, unfocus)\n\n    $('#countriesBody > .states').on('click', function() {\n      if (customization === 2) {\n        $('.selected').removeClass('selected')\n        $(this).addClass('selected')\n        const state = +$(this).attr('id').slice(5)\n        let color = states[state].color\n        if (color === 'neutral') {color = 'white'}\n        if (debug.selectAll('.circle').size()) debug.selectAll('.circle').attr('stroke', color)\n      }\n    })\n\n    $('.selectCapital').on('click', function() {\n      if ($(this).hasClass('pressed')) {\n        $(this).removeClass('pressed')\n        tooltip.setAttribute('data-main', '')\n        restoreDefaultEvents()\n      } else {\n        $(this).addClass('pressed')\n        viewbox.style('cursor', 'crosshair').on('click', selectCapital)\n        tip('Click on the map to select or create a new capital', true)\n      }\n    })\n\n    function selectCapital() {\n      const point = d3.mouse(this)\n      const index = getIndex(point)\n      const x = _.round(point[0], 2), y = _.round(point[1], 2)\n\n      if (cells[index].height < 20) {\n        tip('Cannot place capital on the water! Select a land cell')\n        return\n      }\n      const state = +$('.selectCapital.pressed').attr('id').replace('selectCapital', '')\n      let oldState = cells[index].region\n      if (oldState === 'neutral') {oldState = states.length - 1}\n      if (cells[index].manor !== undefined) {\n        // cell has burg\n        const burg = cells[index].manor\n        if (states[oldState].capital === burg) {\n          tip('Existing capital cannot be selected as a new state capital! Select other cell')\n          return\n        } else {\n          // make this burg a new capital\n          const urbanFactor = 0.9 // for old neutrals\n          manors[burg].region = state\n          if (oldState === 'neutral') {manors[burg].population *= (1 / urbanFactor)}\n          manors[burg].population *= 2 // give capital x2 population bonus\n          states[state].capital = burg\n          moveBurgToGroup(burg, 'capitals')\n        }\n      } else {\n        // free cell -> create new burg for a capital\n        const closest = cultureTree.find(x, y)\n        const culture = cultureTree.data().indexOf(closest) || 0\n        const name = generateName(culture)\n        const i = manors.length\n        cells[index].manor = i\n        states[state].capital = i\n        let score = cells[index].score\n        if (score <= 0) {score = _.round(Math.random(), 2)}\n        if (cells[index].crossroad) {score += cells[index].crossroad} // crossroads\n        if (cells[index].confluence) {score += Math.pow(cells[index].confluence, 0.3)} // confluences\n        if (cells[index].port !== undefined) {score *= 3} // port-capital\n        const population = _.round(score, 1)\n        manors.push({i, cell: index, x, y, region: state, culture, name, population})\n        burgIcons.select('#capitals').append('circle').attr('id', 'burg' + i).attr('data-id', i)\n                 .attr('cx', x).attr('cy', y).attr('r', 1).on('click', editBurg)\n        burgLabels.select('#capitals').append('text').attr('data-id', i).attr('x', x).attr('y', y)\n                  .attr('dy', '-0.35em').text(name).on('click', editBurg)\n      }\n      cells[index].region = state\n      cells[index].neighbors.map(function(n) {\n        if (cells[n].height < 20) {return}\n        if (cells[n].manor !== undefined) {return}\n        cells[n].region = state\n      })\n      redrawRegions()\n      recalculateStateData(oldState) // re-calc old state data\n      recalculateStateData(state) // calc new state data\n      editCountries()\n      restoreDefaultEvents()\n    }\n\n    $('.statePower').on('input', function() {\n      const s = +(this.parentNode.id).slice(5)\n      states[s].power = +this.value\n      regenerateCountries()\n    })\n    $('.statePopulation').on('change', function() {\n      let s = +(this.parentNode.id).slice(5)\n      const popOr = +$(this).parent().attr('data-population')\n      const popNew = getInteger(this.value)\n      if (!Number.isInteger(popNew) || popNew < 1000) {\n        this.value = si(popOr)\n        return\n      }\n      const change = popNew / popOr\n      states[s].urbanPopulation = _.round(states[s].urbanPopulation * change, 2)\n      states[s].ruralPopulation = _.round(states[s].ruralPopulation * change, 2)\n      const urban = Math.round(states[s].urbanPopulation * urbanization.value * populationRate.value)\n      const rural = Math.round(states[s].ruralPopulation * populationRate.value)\n      const population = (urban + rural) * 1000\n      $(this).parent().attr('data-population', population)\n      this.value = si(population)\n      let total = 0\n      $('#countriesBody > div').each(function(e, i) {\n        total += +$(this).attr('data-population')\n      })\n      countriesFooterPopulation.innerHTML = si(total)\n      if (states[s].capital === 'neutral') {s = 'neutral'}\n      manors.map(function(m) {\n        if (m.region !== s) {return}\n        m.population = _.round(m.population * change, 2)\n      })\n    })\n    // fully remove country\n    $('#countriesBody .icon-trash-empty').on('click', function() {\n      const s = +(this.parentNode.id).slice(5)\n      alertMessage.innerHTML =\n        `Are you sure you want to remove the country? All lands and burgs will become neutral`\n      $('#alert').dialog({\n        resizable: false, title: 'Remove country', buttons: {\n          Remove: function() {\n            removeCountry(s)\n            $(this).dialog('close')\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    function removeCountry(s) {\n      const cellsCount = states[s].cells\n      const capital = +states[s].capital\n      if (!isNaN(capital)) moveBurgToGroup(capital, 'towns')\n      states.splice(s, 1)\n      states.map(function(s, i) {s.i = i})\n      land.map(function(c) {\n        if (c.region === s) c.region = 'neutral'\n        else if (c.region > s) c.region -= 1\n      })\n      // do only if removed state had cells\n      if (cellsCount) {\n        manors.map(function(b) {if (b.region === s) b.region = 'neutral'})\n        // re-calculate neutral data\n        const i = states.length\n        if (states[i - 1].capital !== 'neutral') {\n          states.push({i, color: 'neutral', name: 'Neutrals', capital: 'neutral'})\n        }\n        recalculateStateData(i - 1) // re-calc data for neutrals\n        redrawRegions()\n      }\n      editCountries()\n    }\n\n    $('#countriesNeutral, #countriesNeutralNumber').on('change', regenerateCountries)\n  }\n\n  // burgs list + editor\n  function editBurgs(context, s) {\n    if (s === undefined) {s = +(this.parentNode.id).slice(5)}\n    $('#burgsEditor').attr('data-state', s)\n    $('#burgsBody').empty()\n    $('#burgsHeader').children().removeClass(\n      'icon-sort-name-up icon-sort-name-down icon-sort-number-up icon-sort-number-down')\n    const region = states[s].capital === 'neutral' ? 'neutral' : s\n    const burgs = $.grep(manors, function(e) {\n      return (e.region === region)\n    })\n    const populationArray = []\n    burgs.map(function(b) {\n      $('#burgsBody').append('<div class=\"states\" id=\"burgs' + b.i + '\"></div>')\n      const el = $('#burgsBody div:last-child')\n      el.append(\n        '<span title=\"Click to enlarge the burg\" style=\"padding-right: 2px\" class=\"enlarge icon-globe\"></span>')\n      el.append(\n        '<input title=\"Burg name. Click and type to change\" class=\"burgName\" value=\"' + b.name + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n      el.append(\n        '<span title=\"Burg culture\" class=\"icon-book\" style=\"padding-right: 2px\"></span>')\n      el.append(\n        '<div title=\"Burg culture\" class=\"burgCulture\">' + cultures[b.culture].name + '</div>')\n      let population = b.population * urbanization.value * populationRate.value * 1000\n      populationArray.push(population)\n      population = population > 1e4 ? si(population) : _.round(population, -1)\n      el.append('<span title=\"Population\" class=\"icon-male\"></span>')\n      el.append(\n        '<input title=\"Population. Input to change\" class=\"burgPopulation\" value=\"' + population + '\"/>')\n      const capital = states[s].capital\n      let type = 'z-burg' // usual burg by default\n      if (b.i === capital) {\n        el.append('<span title=\"Capital\" class=\"icon-star-empty\"></span>')\n        type = 'c-capital'\n      } else {el.append('<span class=\"icon-star-empty placeholder\"></span>')}\n      if (cells[b.cell].port !== undefined) {\n        el.append('<span title=\"Port\" class=\"icon-anchor small\"></span>')\n        if (type === 'c-capital') {type = 'a-capital-port'} else {type = 'p-port'}\n      } else {\n        el.append('<span class=\"icon-anchor placeholder\"></span>')\n      }\n      if (b.i !== capital) {\n        el.append('<span title=\"Remove burg\" class=\"icon-trash-empty\"></span>')\n      }\n      el.attr('data-burg', b.name).attr('data-culture', cultures[b.culture].name)\n        .attr('data-population', b.population).attr('data-type', type)\n    })\n    if (!$('#burgsEditor').is(':visible')) {\n      $('#burgsEditor').dialog({\n        title: 'Burgs of ' + states[s].name,\n        minHeight: 'auto', width: 'auto',\n        position: {my: 'right bottom', at: 'right-10 bottom-10', of: 'svg'}\n      })\n      const color = '<input title=\"Country color. Click to change\" type=\"color\" class=\"stateColor\" value=\"' + states[s].color + '\"/>'\n      if (region !== 'neutral') {\n        $('div[aria-describedby=\\'burgsEditor\\'] .ui-dialog-title').prepend(color)\n      }\n    }\n    // populate total line on footer\n    burgsFooterBurgs.innerHTML = burgs.length\n    burgsFooterCulture.innerHTML = $('#burgsBody div:first-child .burgCulture').text()\n    const avPop = _.round(d3.mean(populationArray), -1)\n    burgsFooterPopulation.value = avPop\n    $('.enlarge').click(function() {\n      const b = +(this.parentNode.id).slice(5)\n      const l = labels.select('[data-id=\\'' + b + '\\']')\n      const x = +l.attr('x'), y = +l.attr('y')\n      zoomTo(x, y, 8, 1600)\n    })\n\n    $('#burgsBody > div').hover(focusBurg, unfocus)\n\n    $('#burgsBody > div').click(function() {\n      if (!$('#changeCapital').hasClass('pressed')) return\n      const s = +$('#burgsEditor').attr('data-state')\n      const newCap = +$(this).attr('id').slice(5)\n      const oldCap = +states[s].capital\n      if (newCap === oldCap) {\n        tip('This burg is already a capital! Please select a different burg', null, 'error')\n        return\n      }\n      $('#changeCapital').removeClass('pressed')\n      states[s].capital = newCap\n      if (!isNaN(oldCap)) moveBurgToGroup(oldCap, 'towns')\n      recalculateStateData(s)\n      moveBurgToGroup(newCap, 'capitals')\n    })\n\n    $('.burgName').on('input', function() {\n      const b = +(this.parentNode.id).slice(5)\n      manors[b].name = this.value\n      labels.select('[data-id=\\'' + b + '\\']').text(this.value)\n      if (b === s && $('#countriesEditor').is(':visible')) {\n        $('#state' + s + ' > .stateCapital').val(this.value)\n      }\n    })\n    $('.ui-dialog-title > .stateColor').on('change', function() {\n      states[s].color = this.value\n      regions.selectAll('.region' + s).attr('fill', this.value).attr('stroke', this.value)\n      if ($('#countriesEditor').is(':visible')) {\n        $('#state' + s + ' > .stateColor').val(this.value)\n      }\n    })\n    $('.burgPopulation').on('change', function() {\n      const b = +(this.parentNode.id).slice(5)\n      const pop = getInteger(this.value)\n      if (!Number.isInteger(pop) || pop < 10) {\n        const orig = _.round(manors[b].population * urbanization.value * populationRate.value * 1000,\n          2)\n        this.value = si(orig)\n        return\n      }\n      populationRaw = _.round(pop / urbanization.value / populationRate.value / 1000, 2)\n      const change = populationRaw - manors[b].population\n      manors[b].population = populationRaw\n      $(this).parent().attr('data-population', populationRaw)\n      this.value = si(pop)\n      let state = manors[b].region\n      if (state === 'neutral') {state = states.length - 1}\n      states[state].urbanPopulation += change\n      updateCountryPopulationUI(state)\n      const average = states[state].urbanPopulation / states[state].burgs * urbanization.value * populationRate.value * 1000\n      burgsFooterPopulation.value = _.round(average, -1)\n    })\n    $('#burgsFooterPopulation').on('change', function() {\n      const state = +$('#burgsEditor').attr('data-state')\n      const newPop = +this.value\n      const avPop = states[state].urbanPopulation / states[state].burgs * urbanization.value * populationRate.value * 1000\n      if (!Number.isInteger(newPop) || newPop < 10) {\n        this.value = _.round(avPop, -1)\n        return\n      }\n      const change = +this.value / avPop\n      $('#burgsBody > div').each(function(e, i) {\n        const b = +(this.id).slice(5)\n        const pop = _.round(manors[b].population * change, 2)\n        manors[b].population = pop\n        $(this).attr('data-population', pop)\n        let popUI = pop * urbanization.value * populationRate.value * 1000\n        popUI = popUI > 1e4 ? si(popUI) : _.round(popUI, -1)\n        $(this).children().filter('.burgPopulation').val(popUI)\n      })\n      states[state].urbanPopulation = _.round(states[state].urbanPopulation * change, 2)\n      updateCountryPopulationUI(state)\n    })\n    $('#burgsBody .icon-trash-empty').on('click', function() {\n      alertMessage.innerHTML = `Are you sure you want to remove the burg?`\n      const b = +(this.parentNode.id).slice(5)\n      $('#alert').dialog({\n        resizable: false, title: 'Remove burg',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            const state = +$('#burgsEditor').attr('data-state')\n            $('#burgs' + b).remove()\n            const cell = manors[b].cell\n            manors[b].region = 'removed'\n            cells[cell].manor = undefined\n            states[state].burgs = states[state].burgs - 1\n            burgsFooterBurgs.innerHTML = states[state].burgs\n            countriesFooterBurgs.innerHTML = +countriesFooterBurgs.innerHTML - 1\n            states[state].urbanPopulation = states[state].urbanPopulation - manors[b].population\n            const avPop = states[state].urbanPopulation / states[state].burgs * urbanization.value * populationRate.value * 1000\n            burgsFooterPopulation.value = _.round(avPop, -1)\n            if ($('#countriesEditor').is(':visible')) {\n              $('#state' + state + ' > .stateBurgs').text(states[state].burgs)\n            }\n            labels.select('[data-id=\\'' + b + '\\']').remove()\n            icons.select('[data-id=\\'' + b + '\\']').remove()\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n  }\n\n  // onhover style functions\n  function focusOnState() {\n    const s = +(this.id).slice(5)\n    labels.select('#regionLabel' + s).classed('drag', true)\n    document.getElementsByClassName('region' + s)[0].style.stroke = 'red'\n    document.getElementsByClassName('region' + s)[0].setAttribute('filter', 'url(#blur1)')\n  }\n\n  function unfocusState() {\n    const s = +(this.id).slice(5)\n    labels.select('#regionLabel' + s).classed('drag', false)\n    document.getElementsByClassName('region' + s)[0].style.stroke = 'none'\n    document.getElementsByClassName('region' + s)[0].setAttribute('filter', null)\n  }\n\n  function focusCapital() {\n    const s = +(this.parentNode.id).slice(5)\n    const capital = states[s].capital\n    labels.select('[data-id=\\'' + capital + '\\']').classed('drag', true)\n    icons.select('[data-id=\\'' + capital + '\\']').classed('drag', true)\n  }\n\n  function focusBurgs() {\n    const s = +(this.parentNode.id).slice(5)\n    const stateManors = $.grep(manors, function(e) {\n      return (e.region === s)\n    })\n    stateManors.map(function(m) {\n      labels.select('[data-id=\\'' + m.i + '\\']').classed('drag', true)\n      icons.select('[data-id=\\'' + m.i + '\\']').classed('drag', true)\n    })\n  }\n\n  function focusBurg() {\n    const b = +(this.id).slice(5)\n    const l = labels.select('[data-id=\\'' + b + '\\']')\n    l.classed('drag', true)\n  }\n\n  function unfocus() {$('.drag').removeClass('drag')}\n\n  // save dialog position if \"stable\" dialog window is dragged\n  $('.stable').on('dialogdragstop', function(event, ui) {\n    sessionStorage.setItem(this.id, [ui.offset.left, ui.offset.top])\n  })\n\n  // restore saved dialog position on \"stable\" dialog window open\n  $('.stable').on('dialogopen', function(event, ui) {\n    let pos = sessionStorage.getItem(this.id)\n    if (!pos) {return}\n    pos = pos.split(',')\n    if (pos[0] > $(window).width() - 100 || pos[1] > $(window).width() - 40) {return} // prevent showing out of screen\n    const at = `left+${pos[0]} top+${pos[1]}`\n    $(this).dialog('option', 'position', {my: 'left top', at: at, of: 'svg'})\n  })\n\n  // open editCultures dialog\n  function editCultures() {\n    if (!cults.selectAll('path').size()) $('#toggleCultures').click()\n    if (regions.style('display') !== 'none') $('#toggleCountries').click()\n    layoutPreset.value = 'layoutCultural'\n    $('#culturesBody').empty()\n    $('#culturesHeader').children().removeClass(\n      'icon-sort-name-up icon-sort-name-down icon-sort-number-up icon-sort-number-down')\n\n    // collect data\n    const cellsC = [], areas = [], rurPops = [], urbPops = []\n    const unit = areaUnit.value === 'square' ? ' ' + distanceUnit.value + '²' :\n                 ' ' + areaUnit.value\n    land.map(function(l) {\n      const c = l.culture\n      if (c === undefined) return\n      cellsC[c] = cellsC[c] ? cellsC[c] + 1 : 1\n      areas[c] = areas[c] ? areas[c] + l.area : l.area\n      rurPops[c] = rurPops[c] ? rurPops[c] + l.pop : l.pop\n    })\n\n    manors.map(function(m) {\n      const c = m.culture\n      if (isNaN(c)) return\n      urbPops[c] = urbPops[c] ? urbPops[c] + m.population : m.population\n    })\n\n    if (!nameBases[0]) applyDefaultNamesData()\n    for (let c = 0; c < cultures.length; c++) {\n      $('#culturesBody').append('<div class=\"states cultures\" id=\"culture' + c + '\"></div>')\n      if (cellsC[c] === undefined) {\n        cellsC[c] = 0\n        areas[c] = 0\n        rurPops[c] = 0\n      }\n      if (urbPops[c] === undefined) urbPops[c] = 0\n      const area = Math.round(areas[c] * Math.pow(distanceScale.value, 2))\n      const areaConv = si(area) + unit\n      const urban = Math.round(urbPops[c] * +urbanization.value * populationRate.value)\n      const rural = Math.round(rurPops[c] * populationRate.value)\n      const population = (urban + rural) * 1000\n      const populationConv = si(population)\n      const title = '\\'Total population: ' + populationConv + '; Rural population: ' + rural + 'K; Urban population: ' + urban + 'K\\''\n      let b = cultures[c].base\n      if (b >= nameBases.length) b = 0\n      const base = nameBases[b].name\n      const el = $('#culturesBody div:last-child')\n      el.append(\n        '<input onmouseover=\"tip(\\'Culture color. Click to change\\')\" class=\"stateColor\" type=\"color\" value=\"' + cultures[c].color + '\"/>')\n      el.append(\n        '<input onmouseover=\"tip(\\'Culture name. Click and type to change\\')\" class=\"cultureName\" value=\"' + cultures[c].name + '\" autocorrect=\"off\" spellcheck=\"false\"/>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Culture cells count\\')\" class=\"icon-check-empty\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Culture cells count\\')\" class=\"stateCells\">' + cellsC[c] + '</div>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Culture area: ' + areaConv + '\\')\" style=\"padding-right: 4px\" class=\"icon-map-o\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(\\'Culture area: ' + areaConv + '\\')\" class=\"stateArea\">' + areaConv + '</div>')\n      el.append('<span onmouseover=\"tip(' + title + ')\" class=\"icon-male\"></span>')\n      el.append(\n        '<div onmouseover=\"tip(' + title + ')\" class=\"culturePopulation\">' + populationConv + '</div>')\n      el.append(\n        '<span onmouseover=\"tip(\\'Click to re-generate names for burgs with this culture assigned\\')\" class=\"icon-arrows-cw\"></span>')\n      el.append(\n        '<select onmouseover=\"tip(\\'Culture namesbase. Click to change\\')\" class=\"cultureBase\"></select>')\n      if (cultures.length > 1) {\n        el.append(\n          '<span onmouseover=\"tip(\\'Remove culture. Remaining cultures will be recalculated\\')\" class=\"icon-trash-empty\"></span>')\n      }\n      el.attr('data-color', cultures[c].color).attr('data-culture', cultures[c].name)\n        .attr('data-cells', cellsC[c]).attr('data-area', area).attr('data-population', population)\n        .attr('data-base', base)\n    }\n\n    addCultureBaseOptions()\n    drawCultureCenters()\n\n    let activeCultures = cellsC.reduce(function(s, v) {if (v) {return s + 1} else {return s}},\n      0)\n    culturesFooterCultures.innerHTML = activeCultures + '/' + cultures.length\n    culturesFooterCells.innerHTML = land.length\n    let totalArea = areas.reduce(function(s, v) {return s + v})\n    totalArea = Math.round(totalArea * Math.pow(distanceScale.value, 2))\n    culturesFooterArea.innerHTML = si(totalArea) + unit\n    let totalPopulation = rurPops.reduce(function(s, v) {return s + v}) * urbanization.value\n    totalPopulation += urbPops.reduce(function(s, v) {return s + v})\n    culturesFooterPopulation.innerHTML = si(totalPopulation * 1000 * populationRate.value)\n\n    // initialize jQuery dialog\n    if (!$('#culturesEditor').is(':visible')) {\n      $('#culturesEditor').dialog({\n        title: 'Cultures Editor',\n        minHeight: 'auto', minWidth: Math.min(svgWidth, 336),\n        position: {my: 'right top', at: 'right-10 top+10', of: 'svg'},\n        close: function() {\n          debug.select('#cultureCenters').selectAll('*').remove()\n          exitCulturesManualAssignment()\n        }\n      })\n    }\n\n    $('.cultures').hover(function() {\n      const c = +(this.id).slice(7)\n      debug.select('#cultureCenter' + c).attr('stroke', '#000000e6')\n    }, function() {\n      const c = +(this.id).slice(7)\n      debug.select('#cultureCenter' + c).attr('stroke', '#00000080')\n    })\n\n    $('.cultures').on('click', function() {\n      if (customization !== 4) return\n      const c = +(this.id).slice(7)\n      $('.selected').removeClass('selected')\n      $(this).addClass('selected')\n      let color = cultures[c].color\n      debug.selectAll('.circle').attr('stroke', color)\n    })\n\n    $('.cultures .stateColor').on('input', function() {\n      const c = +(this.parentNode.id).slice(7)\n      const old = cultures[c].color\n      cultures[c].color = this.value\n      debug.select('#cultureCenter' + c).attr('fill', this.value)\n      cults.selectAll('[fill=\"' + old + '\"]').attr('fill', this.value).attr('stroke', this.value)\n    })\n\n    $('.cultures .cultureName').on('input', function() {\n      const c = +(this.parentNode.id).slice(7)\n      cultures[c].name = this.value\n    })\n\n    $('.cultures .icon-arrows-cw').on('click', function() {\n      const c = +(this.parentNode.id).slice(7)\n      manors.forEach(function(m) {\n        if (m.region === 'removed') return\n        if (m.culture !== c) return\n        m.name = generateName(c)\n        labels.select('[data-id=\\'' + m.i + '\\']').text(m.name)\n      })\n    })\n\n    $('#culturesBody .icon-trash-empty').on('click', function() {\n      const c = +(this.parentNode.id).slice(7)\n      cultures.splice(c, 1)\n      const centers = cultures.map(function(c) {return c.center})\n      cultureTree = d3.quadtree(centers)\n      recalculateCultures('fullRedraw')\n      editCultures()\n    })\n\n    if (modules.editCultures) return\n    modules.editCultures = true\n\n    function addCultureBaseOptions() {\n      $('.cultureBase').each(function() {\n        const c = +(this.parentNode.id).slice(7)\n        for (let i = 0; i < nameBases.length; i++) {\n          this.options.add(new Option(nameBases[i].name, i))\n        }\n        this.value = cultures[c].base\n        this.addEventListener('change', function() {\n          cultures[c].base = +this.value\n        })\n      })\n    }\n\n    function drawCultureCenters() {\n      let cultureCenters = debug.select('#cultureCenters')\n      if (cultureCenters.size()) {cultureCenters.selectAll('*').remove()} else {\n        cultureCenters = debug.append('g').attr('id', 'cultureCenters')\n      }\n      for (let c = 0; c < cultures.length; c++) {\n        cultureCenters.append('circle').attr('id', 'cultureCenter' + c)\n                      .attr('cx', cultures[c].center[0]).attr('cy', cultures[c].center[1])\n                      .attr('r', 6).attr('stroke-width', 2).attr('stroke', '#00000080')\n                      .attr('fill', cultures[c].color)\n                      .on('mousemove', cultureCenterTip)\n                      .on('mouseleave', function() {tip('', true)})\n                      .call(d3.drag().on('start', cultureCenterDrag))\n      }\n    }\n\n    function cultureCenterTip() {\n      tip('Drag to move culture center and re-calculate cultures', true)\n    }\n\n    function cultureCenterDrag() {\n      const el = d3.select(this)\n      const c = +this.id.slice(13)\n\n      d3.event.on('drag', function() {\n        const x = d3.event.x, y = d3.event.y\n        el.attr('cx', x).attr('cy', y)\n        cultures[c].center = [x, y]\n        const centers = cultures.map(function(c) {return c.center})\n        cultureTree = d3.quadtree(centers)\n        recalculateCultures()\n      })\n    }\n\n    $('#culturesPercentage').on('click', function() {\n      const el = $('#culturesEditor')\n      if (el.attr('data-type') === 'absolute') {\n        el.attr('data-type', 'percentage')\n        const totalCells = land.length\n        let totalArea = culturesFooterArea.innerHTML\n        totalArea = getInteger(totalArea.split(' ')[0])\n        const totalPopulation = getInteger(culturesFooterPopulation.innerHTML)\n        $('#culturesBody > .cultures').each(function() {\n          const cells = Math.round($(this).attr('data-cells') / totalCells * 100)\n          const area = Math.round($(this).attr('data-area') / totalArea * 100)\n          const population = Math.round($(this).attr('data-population') / totalPopulation * 100)\n          $(this).children().filter('.stateCells').text(cells + '%')\n          $(this).children().filter('.stateArea').text(area + '%')\n          $(this).children().filter('.culturePopulation').text(population + '%')\n        })\n      } else {\n        el.attr('data-type', 'absolute')\n        editCultures()\n      }\n    })\n\n    $('#culturesManually').on('click', function() {\n      customization = 4\n      tip('Click to select a culture, drag the circle to re-assign', true)\n      $('#culturesBottom').children().hide()\n      $('#culturesManuallyButtons').show()\n      viewbox.style('cursor', 'crosshair').call(drag).on('click', changeSelectedOnClick)\n      debug.select('#cultureCenters').selectAll('*').remove()\n    })\n\n    $('#culturesManuallyComplete').on('click', function() {\n      const changed = cults.selectAll('[data-culture]')\n      changed.each(function() {\n        const i = +(this.id).slice(4)\n        const c = +this.getAttribute('data-culture')\n        this.removeAttribute('data-culture')\n        cells[i].culture = c\n        const manor = cells[i].manor\n        if (manor !== undefined) manors[manor].culture = c\n      })\n      exitCulturesManualAssignment()\n      if (changed.size()) editCultures()\n    })\n\n    $('#culturesManuallyCancel').on('click', function() {\n      cults.selectAll('[data-culture]').each(function() {\n        const i = +(this.id).slice(4)\n        const c = cells[i].culture\n        this.removeAttribute('data-culture')\n        const color = cultures[c].color\n        this.setAttribute('fill', color)\n        this.setAttribute('stroke', color)\n      })\n      exitCulturesManualAssignment()\n      drawCultureCenters()\n    })\n\n    function exitCulturesManualAssignment() {\n      debug.selectAll('.circle').remove()\n      $('#culturesBottom').children().show()\n      $('#culturesManuallyButtons').hide()\n      $('.selected').removeClass('selected')\n      customization = 0\n      restoreDefaultEvents()\n    }\n\n    $('#culturesRandomize').on('click', function() {\n      const centers = cultures.map(function(c) {\n        const x = Math.floor(Math.random() * graphWidth * 0.8 + graphWidth * 0.1)\n        const y = Math.floor(Math.random() * graphHeight * 0.8 + graphHeight * 0.1)\n        const center = [x, y]\n        c.center = center\n        return center\n      })\n      cultureTree = d3.quadtree(centers)\n      recalculateCultures()\n      drawCultureCenters()\n      editCultures()\n    })\n\n    $('#culturesExport').on('click', function() {\n      const unit = areaUnit.value === 'square' ? distanceUnit.value + '2' : areaUnit.value\n      let data = 'Culture,Cells,Area (' + unit + '),Population,Namesbase\\n' // headers\n      $('#culturesBody > .cultures').each(function() {\n        data += $(this).attr('data-culture') + ','\n        data += $(this).attr('data-cells') + ','\n        data += $(this).attr('data-area') + ','\n        data += $(this).attr('data-population') + ','\n        data += $(this).attr('data-base') + '\\n'\n      })\n\n      const dataBlob = new Blob([data], {type: 'text/plain'})\n      const url = window.URL.createObjectURL(dataBlob)\n      const link = document.createElement('a')\n      document.body.appendChild(link)\n      link.download = 'cultures_data' + Date.now() + '.csv'\n      link.href = url\n      link.click()\n      window.setTimeout(function() {window.URL.revokeObjectURL(url)}, 2000)\n    })\n\n    $('#culturesRegenerateNames').on('click', function() {\n      manors.forEach(function(m) {\n        if (m.region === 'removed') return\n        const culture = m.culture\n        m.name = generateName(culture)\n        labels.select('[data-id=\\'' + m.i + '\\']').text(m.name)\n      })\n    })\n\n    $('#culturesEditNamesBase').on('click', editNamesbase)\n\n    $('#culturesAdd').on('click', function() {\n      const x = Math.floor(Math.random() * graphWidth * 0.8 + graphWidth * 0.1)\n      const y = Math.floor(Math.random() * graphHeight * 0.8 + graphHeight * 0.1)\n      const center = [x, y]\n\n      let culture, base, name, color\n      if (cultures.length < defaultCultures.length) {\n        // add one of the default cultures\n        culture = cultures.length\n        base = defaultCultures[culture].base\n        color = defaultCultures[culture].color\n        name = defaultCultures[culture].name\n      } else {\n        // add random culture besed on one of the current ones\n        culture = _.random(cultures.length - 1)\n        name = generateName(culture)\n        color = colors20(cultures.length % 20)\n        base = cultures[culture].base\n      }\n      cultures.push({name, color, base, center})\n      const centers = cultures.map(function(c) {return c.center})\n      cultureTree = d3.quadtree(centers)\n      recalculateCultures()\n      editCultures()\n    })\n  }\n\n  // open editNamesbase dialog\n  function editNamesbase() {\n    // update list of bases\n    const select = document.getElementById('namesbaseSelect')\n    for (let i = select.options.length; i < nameBases.length; i++) {\n      const option = new Option(nameBases[i].name, i)\n      select.options.add(option)\n    }\n\n    // restore previous state\n    const textarea = document.getElementById('namesbaseTextarea')\n    let selected = +textarea.getAttribute('data-base')\n    if (selected >= nameBases.length) selected = 0\n    select.value = selected\n    if (textarea.value === '') namesbaseUpdateInputs(selected)\n    const examples = document.getElementById('namesbaseExamples')\n    if (examples.innerHTML === '') namesbaseUpdateExamples(selected)\n\n    // open a dialog\n    $('#namesbaseEditor').dialog({\n      title: 'Namesbase Editor',\n      minHeight: 'auto', minWidth: Math.min(svgWidth, 400),\n      position: {my: 'center', at: 'center', of: 'svg'}\n    })\n\n    if (modules.editNamesbase) return\n    modules.editNamesbase = true\n\n    function namesbaseUpdateInputs(selected) {\n      const textarea = document.getElementById('namesbaseTextarea')\n      textarea.value = nameBase[selected].join(', ')\n      textarea.setAttribute('data-base', selected)\n      const name = document.getElementById('namesbaseName')\n      const method = document.getElementById('namesbaseMethod')\n      const min = document.getElementById('namesbaseMin')\n      const max = document.getElementById('namesbaseMax')\n      const dublication = document.getElementById('namesbaseDouble')\n      name.value = nameBases[selected].name\n      method.value = nameBases[selected].method\n      min.value = nameBases[selected].min\n      max.value = nameBases[selected].max\n      dublication.value = nameBases[selected].d\n    }\n\n    function namesbaseUpdateExamples(selected) {\n      const examples = document.getElementById('namesbaseExamples')\n      let text = ''\n      for (let i = 0; i < 10; i++) {\n        const name = generateName(false, selected)\n        if (name === undefined) {\n          text = 'Cannot generate examples. Please verify the data'\n          break\n        }\n        if (i !== 0) text += ', '\n        text += name\n      }\n      examples.innerHTML = text\n    }\n\n    $('#namesbaseSelect').on('change', function() {\n      const selected = +this.value\n      namesbaseUpdateInputs(selected)\n      namesbaseUpdateExamples(selected)\n    })\n\n    $('#namesbaseName').on('input', function() {\n      const base = +textarea.getAttribute('data-base')\n      const select = document.getElementById('namesbaseSelect')\n      select.options[base].innerHTML = this.value\n      nameBases[base].name = this.value\n    })\n\n    $('#namesbaseTextarea').on('input', function() {\n      const base = +this.getAttribute('data-base')\n      const data = textarea.value.replace(/ /g, '').split(',')\n      nameBase[base] = data\n      if (data.length < 3) {\n        chain[base] = []\n        const examples = document.getElementById('namesbaseExamples')\n        examples.innerHTML = 'Please provide a correct source data'\n        return\n      }\n      const method = document.getElementById('namesbaseMethod').value\n      if (method !== 'selection') chain[base] = calculateChain(base)\n    })\n\n    $('#namesbaseMethod').on('change', function() {\n      const base = +textarea.getAttribute('data-base')\n      nameBases[base].method = this.value\n      if (this.value !== 'selection') chain[base] = calculateChain(base)\n    })\n\n    $('#namesbaseMin').on('change', function() {\n      const base = +textarea.getAttribute('data-base')\n      if (+this.value > nameBases[base].max) {\n        tip('Minimal length cannot be greated that maximal')\n      } else {\n        nameBases[base].min = +this.value\n      }\n    })\n\n    $('#namesbaseMax').on('change', function() {\n      const base = +textarea.getAttribute('data-base')\n      if (+this.value < nameBases[base].min) {\n        tip('Maximal length cannot be less than minimal')\n      } else {\n        nameBases[base].max = +this.value\n      }\n    })\n\n    $('#namesbaseDouble').on('change', function() {\n      const base = +textarea.getAttribute('data-base')\n      nameBases[base].d = this.value\n    })\n\n    $('#namesbaseDefault').on('click', function() {\n      alertMessage.innerHTML = `Are you sure you want to restore the default namesbase?\n      All custom bases will be removed and default ones will be assigned to existing cultures.\n      Meanwhile existing names will not be changed.`\n      $('#alert').dialog({\n        resizable: false, title: 'Restore default data',\n        buttons: {\n          Restore: function() {\n            $(this).dialog('close')\n            $('#namesbaseEditor').dialog('close')\n            const select = document.getElementById('namesbaseSelect')\n            select.options.length = 0\n            document.getElementById('namesbaseTextarea').value = ''\n            document.getElementById('namesbaseTextarea').setAttribute('data-base', 0)\n            document.getElementById('namesbaseExamples').innerHTML === ''\n            applyDefaultNamesData()\n            const baseMax = nameBases.length - 1\n            cultures.forEach(function(c) {if (c.base > baseMax) c.base = baseMax})\n            chains = {}\n            calculateChains()\n            editCultures()\n            editNamesbase()\n          },\n          Cancel: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    $('#namesbaseAdd').on('click', function() {\n      const base = nameBases.length\n      const name = 'Base' + base\n      const method = document.getElementById('namesbaseMethod').value\n      const select = document.getElementById('namesbaseSelect')\n      select.options.add(new Option(name, base))\n      select.value = base\n      nameBases.push({name, method, min: 4, max: 10, d: '', m: 1})\n      nameBase.push([])\n      document.getElementById('namesbaseName').value = name\n      const textarea = document.getElementById('namesbaseTextarea')\n      textarea.value = ''\n      textarea.setAttribute('data-base', base)\n      document.getElementById('namesbaseExamples').innerHTML = ''\n      chain[base] = []\n      editCultures()\n    })\n\n    $('#namesbaseExamples, #namesbaseUpdateExamples').on('click', function() {\n      const select = document.getElementById('namesbaseSelect')\n      namesbaseUpdateExamples(+select.value)\n    })\n\n    $('#namesbaseDownload').on('click', function() {\n      const nameBaseString = JSON.stringify(nameBase) + '\\r\\n'\n      const nameBasesString = JSON.stringify(nameBases)\n      const dataBlob = new Blob([nameBaseString + nameBasesString], {type: 'text/plain'})\n      const url = window.URL.createObjectURL(dataBlob)\n      const link = document.createElement('a')\n      link.download = 'namebase' + Date.now() + '.txt'\n      link.href = url\n      link.click()\n    })\n\n    $('#namesbaseUpload').on('click', function() {namesbaseToLoad.click()})\n    $('#namesbaseToLoad').change(function() {\n      const fileToLoad = this.files[0]\n      this.value = ''\n      const fileReader = new FileReader()\n      fileReader.onload = function(fileLoadedEvent) {\n        const dataLoaded = fileLoadedEvent.target.result\n        const data = dataLoaded.split('\\r\\n')\n        if (data[0] && data[1]) {\n          nameBase = JSON.parse(data[0])\n          nameBases = JSON.parse(data[1])\n          const select = document.getElementById('namesbaseSelect')\n          select.options.length = 0\n          document.getElementById('namesbaseTextarea').value = ''\n          document.getElementById('namesbaseTextarea').setAttribute('data-base', 0)\n          document.getElementById('namesbaseExamples').innerHTML === ''\n          const baseMax = nameBases.length - 1\n          cultures.forEach(function(c) {if (c.base > baseMax) c.base = baseMax})\n          chains = {}\n          calculateChains()\n          editCultures()\n          editNamesbase()\n        } else {\n          tip('Cannot load a namesbase. Please check the data format')\n        }\n      }\n      fileReader.readAsText(fileToLoad, 'UTF-8')\n    })\n  }\n\n  // open editLegends dialog\n  function editLegends(id, name) {\n    // update list of objects\n    const select = document.getElementById('legendSelect')\n    for (let i = select.options.length; i < notes.length; i++) {\n      let option = new Option(notes[i].id, notes[i].id)\n      select.options.add(option)\n    }\n\n    // select an object\n    if (id) {\n      let note = notes.find(note => note.id === id)\n      if (note === undefined) {\n        if (!name) name = id\n        note = {id, name, legend: ''}\n        notes.push(note)\n        let option = new Option(id, id)\n        select.options.add(option)\n      }\n      select.value = id\n      legendName.value = note.name\n      legendText.value = note.legend\n    }\n\n    // open a dialog\n    $('#legendEditor').dialog({\n      title: 'Legends Editor',\n      minHeight: 'auto', minWidth: Math.min(svgWidth, 400),\n      position: {my: 'center', at: 'center', of: 'svg'}\n    })\n\n    if (modules.editLegends) return\n    modules.editLegends = true\n\n    // select another object\n    document.getElementById('legendSelect').addEventListener('change', function() {\n      let note = notes.find(note => note.id === this.value)\n      legendName.value = note.name\n      legendText.value = note.legend\n    })\n\n    // change note name on input\n    document.getElementById('legendName').addEventListener('input', function() {\n      let select = document.getElementById('legendSelect')\n      let id = select.value\n      let note = notes.find(note => note.id === id)\n      note.name = this.value\n    })\n\n    // change note text on input\n    document.getElementById('legendText').addEventListener('input', function() {\n      let select = document.getElementById('legendSelect')\n      let id = select.value\n      let note = notes.find(note => note.id === id)\n      note.legend = this.value\n    })\n\n    // hightlight DOM element\n    document.getElementById('legendFocus').addEventListener('click', function() {\n      let select = document.getElementById('legendSelect')\n      let element = document.getElementById(select.value)\n\n      // if element is not found\n      if (element === null) {\n        const message = 'Related element is not found. Would you like to remove the note (legend item)?'\n        alertMessage.innerHTML = message\n        $('#alert').dialog({\n          resizable: false, title: 'Element not found',\n          buttons: {\n            Remove: function() {\n              $(this).dialog('close')\n              removeLegend()\n            },\n            Keep: function() {$(this).dialog('close')}\n          }\n        })\n        return\n      }\n\n      // if element is found\n      highlightElement(element)\n    })\n\n    function highlightElement(element) {\n      if (debug.select('.highlighted').size()) return // allow only 1 highlight element simultaniosly\n      let box = element.getBBox()\n      let transform = element.getAttribute('transform') || null\n      let t = d3.transition().duration(1000).ease(d3.easeBounceOut)\n      let r = d3.transition().duration(500).ease(d3.easeLinear)\n      let highlight = debug.append('rect').attr('x', box.x).attr('y', box.y)\n                           .attr('width', box.width).attr('height', box.height)\n                           .attr('transform', transform)\n      highlight.classed('highlighted', 1)\n               .transition(t).style('outline-offset', '0px')\n               .transition(r).style('outline-color', 'transparent').remove()\n      let tr = parseTransform(transform)\n      let x = box.x + box.width / 2\n      if (tr[0]) x += tr[0]\n      let y = box.y + box.height / 2\n      if (tr[1]) y += tr[1]\n      if (scale >= 2) zoomTo(x, y, scale, 1600)\n    }\n\n    // download legends object as text file\n    document.getElementById('legendDownload').addEventListener('click', function() {\n      const legendString = JSON.stringify(notes)\n      const dataBlob = new Blob([legendString], {type: 'text/plain'})\n      const url = window.URL.createObjectURL(dataBlob)\n      const link = document.createElement('a')\n      link.download = 'legends' + Date.now() + '.txt'\n      link.href = url\n      link.click()\n    })\n\n    // upload legends object as text file and parse to json\n    document.getElementById('legendUpload').addEventListener('click', function() {\n      document.getElementById('lagendsToLoad').click()\n    })\n    document.getElementById('lagendsToLoad').addEventListener('change', function() {\n      const fileToLoad = this.files[0]\n      this.value = ''\n      const fileReader = new FileReader()\n      fileReader.onload = function(fileLoadedEvent) {\n        const dataLoaded = fileLoadedEvent.target.result\n        if (dataLoaded) {\n          notes = JSON.parse(dataLoaded)\n          const select = document.getElementById('legendSelect')\n          select.options.length = 0\n          editLegends(notes[0].id, notes[0].name)\n        } else {\n          tip('Cannot load a file. Please check the data format')\n        }\n      }\n      fileReader.readAsText(fileToLoad, 'UTF-8')\n    })\n\n    // remove the legend item\n    document.getElementById('legendRemove').addEventListener('click', function() {\n      alertMessage.innerHTML = 'Are you sure you want to remove the selected legend?'\n      $('#alert').dialog({\n        resizable: false, title: 'Remove legend element',\n        buttons: {\n          Remove: function() {\n            $(this).dialog('close')\n            removeLegend()\n          },\n          Keep: function() {$(this).dialog('close')}\n        }\n      })\n    })\n\n    function removeLegend() {\n      let select = document.getElementById('legendSelect')\n      let index = notes.findIndex(n => n.id === select.value)\n      notes.splice(index, 1)\n      select.options.length = 0\n      if (notes.length === 0) {\n        $('#legendEditor').dialog('close')\n        return\n      }\n      editLegends(notes[0].id, notes[0].name)\n    }\n\n  }\n\n  // Map scale and measurements editor\n  function editScale() {\n    $('#ruler').fadeIn()\n    $('#scaleEditor').dialog({\n      title: 'Scale Editor',\n      minHeight: 'auto', width: 'auto', resizable: false,\n      position: {my: 'center bottom', at: 'center bottom-10', of: 'svg'}\n    })\n  }\n\n  // update only UI and sorting value in countryEditor screen\n  function updateCountryPopulationUI(s) {\n    if ($('#countriesEditor').is(':visible')) {\n      const urban = Math.round(states[s].urbanPopulation * +urbanization.value * populationRate.value)\n      const rural = Math.round(states[s].ruralPopulation * populationRate.value)\n      const population = (urban + rural) * 1000\n      $('#state' + s).attr('data-population', population)\n      $('#state' + s).children().filter('.statePopulation').val(si(population))\n    }\n  }\n\n  // update dialogs if measurements are changed\n  function updateCountryEditors() {\n    if ($('#countriesEditor').is(':visible')) {editCountries()}\n    if ($('#burgsEditor').is(':visible')) {\n      const s = +$('#burgsEditor').attr('data-state')\n      editBurgs(this, s)\n    }\n  }\n\n  // remove drawn regions and draw all regions again\n  function redrawRegions() {\n    regions.selectAll('*').remove()\n    borders.selectAll('path').remove()\n    removeAllLabelsInGroup('countries')\n    drawRegions()\n  }\n\n  // remove all labels in group including textPaths\n  function removeAllLabelsInGroup(group) {\n    labels.select('#' + group).selectAll('text').each(function() {\n      defs.select('#textPath_' + this.id).remove()\n      this.remove()\n    })\n    if (group !== 'countries') {\n      labels.select('#' + group).remove()\n      updateLabelGroups()\n    }\n  }\n\n  // restore keeped region / burgs / cultures data on edit heightmap completion\n  function restoreRegions() {\n    borders.selectAll('path').remove()\n    removeAllLabelsInGroup('countries')\n    manors.map(function(m) {\n      const cell = diagram.find(m.x, m.y).index\n      if (cells[cell].height < 20) {\n        // remove manor in ocean\n        m.region = 'removed'\n        m.cell = cell\n        d3.selectAll('[data-id=\\'' + m.i + '\\']').remove()\n      } else {\n        m.cell = cell\n        cells[cell].manor = m.i\n      }\n    })\n    cells.map(function(c) {\n      if (c.height < 20) {\n        // no longer a land cell\n        delete c.region\n        delete c.culture\n        return\n      }\n      if (c.region === undefined) {\n        c.region = 'neutral'\n        if (states[states.length - 1].capital !== 'neutral') {\n          states.push({i: states.length, color: 'neutral', capital: 'neutral', name: 'Neutrals'})\n        }\n      }\n      if (c.culture === undefined) {\n        const closest = cultureTree.find(c.data[0], c.data[1])\n        c.culture = cultureTree.data().indexOf(closest)\n      }\n    })\n    states.map(function(s) {recalculateStateData(s.i)})\n    drawRegions()\n  }\n\n  function regenerateCountries() {\n    regions.selectAll('*').remove()\n    const neutral = neutralInput.value = +countriesNeutral.value\n    manors.forEach(function(m) {\n      if (m.region === 'removed') return\n      let state = 'neutral', closest = neutral\n      states.map(function(s) {\n        if (s.capital === 'neutral' || s.capital === 'select') return\n        const c = manors[s.capital]\n        let dist = Math.hypot(c.x - m.x, c.y - m.y) / s.power\n        if (cells[m.cell].fn !== cells[c.cell].fn) dist *= 3\n        if (dist < closest) {\n          state = s.i\n          closest = dist\n        }\n      })\n      m.region = state\n      cells[m.cell].region = state\n    })\n\n    defineRegions()\n    const temp = regions.append('g').attr('id', 'temp')\n    land.forEach(function(l) {\n      if (l.region === undefined) return\n      if (l.region === 'neutral') return\n      const color = states[l.region].color\n      temp.append('path')\n          .attr('data-cell', l.index).attr('data-state', l.region)\n          .attr('d', 'M' + polygons[l.index].join('L') + 'Z')\n          .attr('fill', color).attr('stroke', color)\n    })\n    const neutralCells = $.grep(cells, function(e) {return e.region === 'neutral'})\n    const last = states.length - 1\n    const type = states[last].color\n    if (type === 'neutral' && !neutralCells.length) {\n      // remove neutral line\n      $('#state' + last).remove()\n      states.splice(-1)\n    }\n    // recalculate data for all countries\n    states.map(function(s) {\n      recalculateStateData(s.i)\n      $('#state' + s.i + ' > .stateCells').text(s.cells)\n      $('#state' + s.i + ' > .stateBurgs').text(s.burgs)\n      const area = Math.round(s.area * Math.pow(distanceScale.value, 2))\n      const unit = areaUnit.value === 'square' ? ' ' + distanceUnit.value + '²' :\n                   ' ' + areaUnit.value\n      $('#state' + s.i + ' > .stateArea').text(si(area) + unit)\n      const urban = Math.round(s.urbanPopulation * urbanization.value * populationRate.value)\n      const rural = Math.round(s.ruralPopulation * populationRate.value)\n      const population = (urban + rural) * 1000\n      $('#state' + s.i + ' > .statePopulation').val(si(population))\n      $('#state' + s.i).attr('data-cells', s.cells).attr('data-burgs', s.burgs)\n                       .attr('data-area', area).attr('data-population', population)\n    })\n    if (type !== 'neutral' && neutralCells.length) {\n      // add neutral line\n      states.push({i: states.length, color: 'neutral', capital: 'neutral', name: 'Neutrals'})\n      recalculateStateData(states.length - 1)\n      editCountries()\n    }\n  }\n\n  // enter state edit mode\n  function mockRegions() {\n    if (grid.style('display') !== 'inline') {toggleGrid.click()}\n    if (labels.style('display') !== 'none') {toggleLabels.click()}\n    stateBorders.selectAll('*').remove()\n    neutralBorders.selectAll('*').remove()\n  }\n\n  // handle DOM elements sorting on header click\n  $('.sortable').on('click', function() {\n    const el = $(this)\n    // remove sorting for all siglings except of clicked element\n    el.siblings().removeClass(\n      'icon-sort-name-up icon-sort-name-down icon-sort-number-up icon-sort-number-down')\n    const type = el.hasClass('alphabetically') ? 'name' : 'number'\n    let state = 'no'\n    if (el.is('[class*=\\'down\\']')) {state = 'asc'}\n    if (el.is('[class*=\\'up\\']')) {state = 'desc'}\n    const sortby = el.attr('data-sortby')\n    const list = el.parent().next() // get list container element (e.g. \"countriesBody\")\n    const lines = list.children('div') // get list elements\n    if (state === 'no' || state === 'asc') { // sort desc\n      el.removeClass('icon-sort-' + type + '-down')\n      el.addClass('icon-sort-' + type + '-up')\n      lines.sort(function(a, b) {\n        let an = a.getAttribute('data-' + sortby)\n        if (an === 'bottom') {return 1}\n        let bn = b.getAttribute('data-' + sortby)\n        if (bn === 'bottom') {return -1}\n        if (type === 'number') {\n          an = +an\n          bn = +bn\n        }\n        if (an > bn) {return 1}\n        if (an < bn) {return -1}\n        return 0\n      })\n    }\n    if (state === 'desc') { // sort asc\n      el.removeClass('icon-sort-' + type + '-up')\n      el.addClass('icon-sort-' + type + '-down')\n      lines.sort(function(a, b) {\n        let an = a.getAttribute('data-' + sortby)\n        if (an === 'bottom') {return 1}\n        let bn = b.getAttribute('data-' + sortby)\n        if (bn === 'bottom') {return -1}\n        if (type === 'number') {\n          an = +an\n          bn = +bn\n        }\n        if (an < bn) {return 1}\n        if (an > bn) {return -1}\n        return 0\n      })\n    }\n    lines.detach().appendTo(list)\n  })\n\n  // load text file with new burg names\n  $('#burgsListToLoad').change(function() {\n    const fileToLoad = this.files[0]\n    this.value = ''\n    const fileReader = new FileReader()\n    fileReader.onload = function(fileLoadedEvent) {\n      const dataLoaded = fileLoadedEvent.target.result\n      const data = dataLoaded.split('\\r\\n')\n      if (data.length === 0) {return}\n      let change = []\n      let message = `Burgs will be renamed as below. Please confirm`\n      message +=\n        `<div class=\"overflow-div\"><table class=\"overflow-table\"><tr><th>Id</th><th>Current name</th><th>New Name</th></tr>`\n      for (let i = 0; i < data.length && i < manors.length; i++) {\n        const v = data[i]\n        if (v === '' || v === undefined) {continue}\n        if (v === manors[i].name) {continue}\n        change.push({i, name: v})\n        message +=\n          `<tr><td style=\"width:20%\">${i}</td><td style=\"width:40%\">${manors[i].name}</td><td style=\"width:40%\">${v}</td></tr>`\n      }\n      message += `</tr></table></div>`\n      alertMessage.innerHTML = message\n      $('#alert').dialog({\n        title: 'Burgs bulk renaming', position: {my: 'center', at: 'center', of: 'svg'},\n        buttons: {\n          Cancel: function() {$(this).dialog('close')},\n          Confirm: function() {\n            for (let i = 0; i < change.length; i++) {\n              const id = change[i].i\n              manors[id].name = change[i].name\n              labels.select('[data-id=\\'' + id + '\\']').text(change[i].name)\n            }\n            $(this).dialog('close')\n            updateCountryEditors()\n          }\n        }\n      })\n    }\n    fileReader.readAsText(fileToLoad, 'UTF-8')\n  })\n\n  // just apply map size that was already set, apply graph size!\n  function applyMapSize() {\n    svgWidth = graphWidth = +mapWidthInput.value\n    svgHeight = graphHeight = +mapHeightInput.value\n    svg.attr('width', svgWidth).attr('height', svgHeight)\n    // set extent to map borders + 100px to get infinity world reception\n    voronoi = d3.voronoi().extent([[-1, -1], [graphWidth + 1, graphHeight + 1]])\n    zoom.translateExtent([[0, 0], [graphWidth, graphHeight]]).scaleExtent([1, 20])\n        .scaleTo(svg, 1)\n    viewbox.attr('transform', null)\n    ocean.selectAll('rect').attr('x', 0).attr('y', 0).attr('width', graphWidth)\n         .attr('height', graphHeight)\n  }\n\n  // change svg size on manual size change or window resize, do not change graph size\n  function changeMapSize() {\n    fitScaleBar()\n    svgWidth = +mapWidthInput.value\n    svgHeight = +mapHeightInput.value\n    svg.attr('width', svgWidth).attr('height', svgHeight)\n    const width = Math.max(svgWidth, graphWidth)\n    const height = Math.max(svgHeight, graphHeight)\n    zoom.translateExtent([[0, 0], [width, height]])\n    svg.select('#ocean').selectAll('rect').attr('x', 0)\n       .attr('y', 0).attr('width', width).attr('height', height)\n  }\n\n  // fit full-screen map if window is resized\n  $(window).resize(function(e) {\n    // trick to prevent resize on download bar opening\n    if (autoResize === false) return\n    mapWidthInput.value = window.innerWidth\n    mapHeightInput.value = window.innerHeight\n    changeMapSize()\n  })\n\n  // fit ScaleBar to map size\n  function fitScaleBar() {\n    const el = d3.select('#scaleBar')\n    if (!el.select('rect').size()) return\n    const bbox = el.select('rect').node().getBBox()\n    let tr = [svgWidth - bbox.width, svgHeight - (bbox.height - 10)]\n    if (sessionStorage.getItem('scaleBar')) {\n      const scalePos = sessionStorage.getItem('scaleBar').split(',')\n      tr = [+scalePos[0] - bbox.width, +scalePos[1] - bbox.height]\n    }\n    el.attr('transform', 'translate(' + Math.round(tr[0]) + ',' + Math.round(tr[1]) + ')')\n  }\n\n  // Other Options handlers\n  $('input, select').on('input change', function() {\n    const id = this.id\n    if (id === 'hideLabels') invokeActiveZooming()\n    if (id === 'mapWidthInput' || id === 'mapHeightInput') {\n      changeMapSize()\n      autoResize = false\n      localStorage.setItem('mapWidth', mapWidthInput.value)\n      localStorage.setItem('mapHeight', mapHeightInput.value)\n    }\n    if (id === 'sizeInput') {\n      graphSize = sizeOutput.value = +this.value\n      if (graphSize === 3) {sizeOutput.style.color = 'red'}\n      if (graphSize === 2) {sizeOutput.style.color = 'yellow'}\n      if (graphSize === 1) {sizeOutput.style.color = 'green'}\n      // localStorage.setItem(\"graphSize\", this.value); - temp off to always start with size 1\n    }\n    if (id === 'templateInput') {localStorage.setItem('template', this.value)}\n    if (id === 'manorsInput') {\n      manorsOutput.value = this.value\n      localStorage.setItem('manors', this.value)\n    }\n    if (id === 'regionsInput') {\n      regionsOutput.value = this.value\n      let size = Math.round(6 - this.value / 20)\n      if (size < 3) {size = 3}\n      burgLabels.select('#capitals').attr('data-size', size)\n      size = Math.round(18 - this.value / 6)\n      if (size < 4) {size = 4}\n      labels.select('#countries').attr('data-size', size)\n      localStorage.setItem('regions', this.value)\n    }\n    if (id === 'powerInput') {\n      powerOutput.value = this.value\n      localStorage.setItem('power', this.value)\n    }\n    if (id === 'neutralInput') {\n      neutralOutput.value = countriesNeutral.value = this.value\n      localStorage.setItem('neutal', this.value)\n    }\n    if (id === 'culturesInput') {\n      culturesOutput.value = this.value\n      localStorage.setItem('cultures', this.value)\n    }\n    if (id === 'precInput') {\n      precOutput.value = +precInput.value\n      localStorage.setItem('prec', this.value)\n    }\n    if (id === 'swampinessInput') {\n      swampinessOutput.value = this.value\n      localStorage.setItem('swampiness', this.value)\n    }\n    if (id === 'outlineLayersInput') localStorage.setItem('outlineLayers', this.value)\n    if (id === 'transparencyInput') changeDialogsTransparency(this.value)\n    if (id === 'pngResolutionInput') localStorage.setItem('pngResolution', this.value)\n    if (id === 'zoomExtentMin' || id === 'zoomExtentMax') {\n      zoom.scaleExtent([+zoomExtentMin.value, +zoomExtentMax.value])\n      zoom.scaleTo(svg, +this.value)\n    }\n\n    if (id === 'convertOverlay') {\n      canvas.style.opacity = convertOverlayValue.innerHTML = +this.value\n    }\n    if (id === 'populationRate') {\n      populationRateOutput.value = si(+populationRate.value * 1000)\n      updateCountryEditors()\n    }\n    if (id === 'urbanization') {\n      urbanizationOutput.value = this.value\n      updateCountryEditors()\n    }\n    if (id === 'distanceUnit' || id === 'distanceScale' || id === 'areaUnit') {\n      const dUnit = distanceUnit.value\n      if (id === 'distanceUnit' && dUnit === 'custom_name') {\n        const custom = prompt('Provide a custom name for distance unit')\n        if (custom) {\n          const opt = document.createElement('option')\n          opt.value = opt.innerHTML = custom\n          distanceUnit.add(opt)\n          distanceUnit.value = custom\n        } else {\n          this.value = 'km'\n          return\n        }\n      }\n      const scale = distanceScale.value\n      scaleOutput.value = scale + ' ' + dUnit\n      ruler.selectAll('g').each(function() {\n        let label\n        const g = d3.select(this)\n        const area = +g.select('text').attr('data-area')\n        if (area) {\n          const areaConv = area * Math.pow(scale, 2) // convert area to distanceScale\n          let unit = areaUnit.value\n          if (unit === 'square') {unit = dUnit + '²'} else {unit = areaUnit.value}\n          label = si(areaConv) + ' ' + unit\n        } else {\n          const dist = +g.select('text').attr('data-dist')\n          label = Math.round(dist * scale) + ' ' + dUnit\n        }\n        g.select('text').text(label)\n      })\n      ruler.selectAll('.gray').attr('stroke-dasharray', _.round(30 / scale, 2))\n      drawScaleBar()\n      updateCountryEditors()\n    }\n    if (id === 'barSize') {\n      barSizeOutput.innerHTML = this.value\n      $('#scaleBar').removeClass('hidden')\n      drawScaleBar()\n    }\n    if (id === 'barLabel') {\n      $('#scaleBar').removeClass('hidden')\n      drawScaleBar()\n    }\n    if (id === 'barBackOpacity' || id === 'barBackColor') {\n      d3.select('#scaleBar > rect')\n        .attr('opacity', +barBackOpacity.value)\n        .attr('fill', barBackColor.value)\n      $('#scaleBar').removeClass('hidden')\n    }\n  })\n\n  $('#scaleOutput').change(function() {\n    if (this.value === '' || isNaN(+this.value) || this.value < 0.01 || this.value > 10) {\n      tip('Manually entered distance scale should be a number in a [0.01; 10] range')\n      this.value = distanceScale.value + ' ' + distanceUnit.value\n      return\n    }\n    distanceScale.value = +this.value\n    scaleOutput.value = this.value + ' ' + distanceUnit.value\n    updateCountryEditors()\n  })\n\n  $('#populationRateOutput').change(function() {\n    if (this.value === '' || isNaN(+this.value) || this.value < 0.001 || this.value > 10) {\n      tip('Manually entered population rate should be a number in a [0.001; 10] range')\n      this.value = si(populationRate.value * 1000)\n      return\n    }\n    populationRate.value = +this.value\n    populationRateOutput.value = si(this.value * 1000)\n    updateCountryEditors()\n  })\n\n  $('#urbanizationOutput').change(function() {\n    if (this.value === '' || isNaN(+this.value) || this.value < 0 || this.value > 10) {\n      tip('Manually entered urbanization rate should be a number in a [0; 10] range')\n      this.value = urbanization.value\n      return\n    }\n    const val = parseFloat(+this.value)\n    if (val > 2) urbanization.setAttribute('max', val)\n    urbanization.value = urbanizationOutput.value = val\n    updateCountryEditors()\n  })\n\n  // lock manually changed option to restrict it randomization\n  $('#optionsContent input, #optionsContent select').change(function() {\n    const icon = 'lock' + this.id.charAt(0).toUpperCase() + this.id.slice(1)\n    const el = document.getElementById(icon)\n    if (!el) return\n    el.setAttribute('data-locked', 1)\n    el.className = 'icon-lock'\n  })\n\n  $('#optionsReset').click(restoreDefaultOptions)\n\n  $('#rescaler').change(function() {\n    const change = _.round((+this.value - 5), 2)\n    modifyHeights('all', change, 1)\n    updateHeightmap()\n    updateHistory()\n    rescaler.value = 5\n  })\n\n  $('#layoutPreset').on('change', function() {\n    const preset = this.value\n    $('#mapLayers li').not('#toggleOcean').addClass('buttonoff')\n    $('#toggleOcean').removeClass('buttonoff')\n    $('#oceanPattern').fadeIn()\n    $('#rivers, #terrain, #borders, #regions, #icons, #labels, #routes, #grid, #markers')\n      .fadeOut()\n    cults.selectAll('path').remove()\n    terrs.selectAll('path').remove()\n    if (preset === 'layoutPolitical') {\n      toggleRivers.click()\n      toggleRelief.click()\n      toggleBorders.click()\n      toggleCountries.click()\n      toggleIcons.click()\n      toggleLabels.click()\n      toggleRoutes.click()\n      toggleMarkers.click()\n    }\n    if (preset === 'layoutCultural') {\n      toggleRivers.click()\n      toggleRelief.click()\n      toggleBorders.click()\n      $('#toggleCultures').click()\n      toggleIcons.click()\n      toggleLabels.click()\n      toggleMarkers.click()\n    }\n    if (preset === 'layoutHeightmap') {\n      $('#toggleHeight').click()\n      toggleRivers.click()\n    }\n  })\n\n  // UI Button handlers\n  $('.tab > button').on('click', function() {\n    $('.tabcontent').hide()\n    $('.tab > button').removeClass('active')\n    $(this).addClass('active')\n    const id = this.id\n    if (id === 'layoutTab') {$('#layoutContent').show()}\n    if (id === 'styleTab') {$('#styleContent').show()}\n    if (id === 'optionsTab') {$('#optionsContent').show()}\n    if (id === 'customizeTab') {$('#customizeContent').show()}\n    if (id === 'aboutTab') {$('#aboutContent').show()}\n  })\n\n  // re-load page with provided seed\n  $('#optionsSeedGenerate').on('click', function() {\n    if ($('#optionsSeed').value == seed) return\n    seed = $('#optionsSeed').value\n    const url = new URL(window.location.href)\n    window.location.href = url.pathname + '?seed=' + seed\n  })\n\n  // Pull request from @evyatron\n  // https://github.com/Azgaar/Fantasy-Map-Generator/pull/49\n  function addDragToUpload() {\n    document.addEventListener('dragover', function(e) {\n      e.stopPropagation()\n      e.preventDefault()\n      $('#map-dragged').show()\n    })\n\n    document.addEventListener('dragleave', function(e) {\n      $('#map-dragged').hide()\n    })\n\n    document.addEventListener('drop', function(e) {\n      e.stopPropagation()\n      e.preventDefault()\n      $('#map-dragged').hide()\n      // no files or more than one\n      if (e.dataTransfer.items == null || e.dataTransfer.items.length != 1) {return}\n      const file = e.dataTransfer.items[0].getAsFile()\n      // not a .map file\n      if (file.name.indexOf('.map') == -1) {\n        alertMessage.innerHTML =\n          'Please upload a <b>.map</b> file you have previously downloaded'\n        $('#alert').dialog({\n          resizable: false, title: 'Invalid file format',\n          width: 400, buttons: {\n            Close: function() { $(this).dialog('close') }\n          }, position: {my: 'center', at: 'center', of: 'svg'}\n        })\n        return\n      }\n      // all good - show uploading text and load the map\n      $('#map-dragged > p').text('Uploading<span>.</span><span>.</span><span>.</span>')\n      uploadFile(file, function onUploadFinish() {\n        $('#map-dragged > p').text('Drop to upload')\n      })\n    })\n  }\n}\n\nfunction tip(tip, main, error) {\n  const tooltip = d3.select('#tooltip')\n  const reg = 'linear-gradient(0.1turn, #ffffff00, #5e5c5c4d, #ffffff00)'\n  const red = 'linear-gradient(0.1turn, #ffffff00, #c71d1d66, #ffffff00)'\n  tooltip.text(tip).style('background', error ? red : reg)\n  if (main) tooltip.attr('data-main', tip)\n}\n\nwindow.tip = tip\n\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\nh3 {\n  margin: 40px 0 0;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n</style>\n"]}]}